"use strict";

/*!
 * jQuery JavaScript Library v1.11.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:19Z
 */
(function (global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    // For CommonJS and CommonJS-like environments where a proper window is present,
    // execute the factory and get jQuery
    // For environments that do not inherently posses a window with a document
    // (such as Node.js), expose a jQuery-making factory as module.exports
    // This accentuates the need for the creation of a real window
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }

      return factory(w);
    };
  } else {
    factory(global);
  } // Pass this if window is not defined yet

})(typeof window !== "undefined" ? window : void 0, function (window, noGlobal) {
  // Can't do this because several apps including ASP.NET trace
  // the stack via arguments.caller.callee and Firefox dies if
  // you try to trace through "use strict" call chains. (#13335)
  // Support: Firefox 18+
  //
  var deletedIds = [];
  var slice = deletedIds.slice;
  var concat = deletedIds.concat;
  var push = deletedIds.push;
  var indexOf = deletedIds.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};

  var version = "1.11.3",
      // Define a local copy of jQuery
  jQuery = function (selector, context) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init(selector, context);
  },
      // Support: Android<4.1, IE<9
  // Make sure we trim BOM and NBSP
  rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      // Matches dashed string for camelizing
  rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
      // Used by jQuery.camelCase as callback to replace()
  fcamelCase = function (all, letter) {
    return letter.toUpperCase();
  };

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,
    constructor: jQuery,
    // Start with an empty selector
    selector: "",
    // The default length of a jQuery object is 0
    length: 0,
    toArray: function () {
      return slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function (num) {
      return num != null ? // Return just the one element from the set
      num < 0 ? this[num + this.length] : this[num] : // Return all the elements in a clean array
      slice.call(this);
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function (elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

      ret.prevObject = this;
      ret.context = this.context; // Return the newly-formed element set

      return ret;
    },
    // Execute a callback for every element in the matched set.
    // (You can seed the arguments with an array of args, but this is
    // only used internally.)
    each: function (callback, args) {
      return jQuery.each(this, callback, args);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function () {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function () {
      return this.prevObject || this.constructor(null);
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: deletedIds.sort,
    splice: deletedIds.splice
  };

  jQuery.extend = jQuery.fn.extend = function () {
    var src,
        copyIsArray,
        copy,
        name,
        options,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false; // Handle a deep copy situation

    if (typeof target === "boolean") {
      deep = target; // skip the boolean and the target

      target = arguments[i] || {};
      i++;
    } // Handle case when target is a string or something (possible in deep copy)


    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    } // extend jQuery itself if only one argument is passed


    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name]; // Prevent never-ending loop

          if (target === copy) {
            continue;
          } // Recurse if we're merging plain objects or arrays


          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            } // Never move original objects, clone them


            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object


    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    // Assume jQuery is ready without the ready module
    isReady: true,
    error: function (msg) {
      throw new Error(msg);
    },
    noop: function () {},
    // See test/unit/core.js for details concerning isFunction.
    // Since version 1.3, DOM methods and functions like alert
    // aren't supported. They return false on IE (#2968).
    isFunction: function (obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray || function (obj) {
      return jQuery.type(obj) === "array";
    },
    isWindow: function (obj) {
      /* jshint eqeqeq: false */
      return obj != null && obj == obj.window;
    },
    isNumeric: function (obj) {
      // parseFloat NaNs numeric-cast false positives (null|true|false|"")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      // adding 1 corrects loss of precision from parseFloat (#15100)
      return !jQuery.isArray(obj) && obj - parseFloat(obj) + 1 >= 0;
    },
    isEmptyObject: function (obj) {
      var name;

      for (name in obj) {
        return false;
      }

      return true;
    },
    isPlainObject: function (obj) {
      var key; // Must be an Object.
      // Because of IE, we also have to check the presence of the constructor property.
      // Make sure that DOM nodes and window objects don't pass through, as well

      if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }

      try {
        // Not own constructor property must be Object
        if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
          return false;
        }
      } catch (e) {
        // IE8,9 Will throw exceptions on certain host objects #9897
        return false;
      } // Support: IE<9
      // Handle iteration over inherited properties before own properties.


      if (support.ownLast) {
        for (key in obj) {
          return hasOwn.call(obj, key);
        }
      } // Own properties are enumerated firstly, so to speed up,
      // if last one is own, then all properties are own.


      for (key in obj) {}

      return key === undefined || hasOwn.call(obj, key);
    },
    type: function (obj) {
      if (obj == null) {
        return obj + "";
      }

      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    // Evaluates a script in a global context
    // Workarounds based on findings by Jim Driscoll
    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
    globalEval: function (data) {
      if (data && jQuery.trim(data)) {
        // We use execScript on Internet Explorer
        // We use an anonymous function so that context is window
        // rather than jQuery in Firefox
        (window.execScript || function (data) {
          window["eval"].call(window, data);
        })(data);
      }
    },
    // Convert dashed to camelCase; used by the css and data modules
    // Microsoft forgot to hump their vendor prefix (#9572)
    camelCase: function (string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function (elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    // args is for internal usage only
    each: function (obj, callback, args) {
      var value,
          i = 0,
          length = obj.length,
          isArray = isArraylike(obj);

      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);

            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);

            if (value === false) {
              break;
            }
          }
        } // A special, fast, case for the most common use of each

      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);

            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);

            if (value === false) {
              break;
            }
          }
        }
      }

      return obj;
    },
    // Support: Android<4.1, IE<9
    trim: function (text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    // results is for internal usage only
    makeArray: function (arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },
    inArray: function (elem, arr, i) {
      var len;

      if (arr) {
        if (indexOf) {
          return indexOf.call(arr, elem, i);
        }

        len = arr.length;
        i = i ? i < 0 ? Math.max(0, len + i) : i : 0;

        for (; i < len; i++) {
          // Skip accessing in sparse arrays
          if (i in arr && arr[i] === elem) {
            return i;
          }
        }
      }

      return -1;
    },
    merge: function (first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;

      while (j < len) {
        first[i++] = second[j++];
      } // Support: IE<9
      // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)


      if (len !== len) {
        while (second[j] !== undefined) {
          first[i++] = second[j++];
        }
      }

      first.length = i;
      return first;
    },
    grep: function (elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert; // Go through the array, only saving the items
      // that pass the validator function

      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);

        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },
    // arg is for internal usage only
    map: function (elems, callback, arg) {
      var value,
          i = 0,
          length = elems.length,
          isArray = isArraylike(elems),
          ret = []; // Go through the array, translating each of the items to their new values

      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        } // Go through every key on the object,

      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      } // Flatten any nested arrays


      return concat.apply([], ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // Bind a function to a context, optionally partially applying any
    // arguments.
    proxy: function (fn, context) {
      var args, proxy, tmp;

      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      } // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.


      if (!jQuery.isFunction(fn)) {
        return undefined;
      } // Simulated bind


      args = slice.call(arguments, 2);

      proxy = function () {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      }; // Set the guid of unique handler to the same of original handler, so it can be removed


      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: function () {
      return +new Date();
    },
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  }); // Populate the class2type map

  jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArraylike(obj) {
    // Support: iOS 8.2 (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = "length" in obj && obj.length,
        type = jQuery.type(obj);

    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }

    if (obj.nodeType === 1 && length) {
      return true;
    }

    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }

  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.2.0-pre
   * http://sizzlejs.com/
   *
   * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
   * Released under the MIT license
   * http://jquery.org/license
   *
   * Date: 2014-12-16
   */
  function (window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        // Local document vars
    setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        // Instance-specific data
    expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function (a, b) {
      if (a === b) {
        hasDuplicate = true;
      }

      return 0;
    },
        // General-purpose constants
    MAX_NEGATIVE = 1 << 31,
        // Instance methods
    hasOwn = {}.hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
    // http://jsperf.com/thor-indexof-vs-for/5
    indexOf = function (list, elem) {
      var i = 0,
          len = list.length;

      for (; i < len; i++) {
        if (list[i] === elem) {
          return i;
        }
      }

      return -1;
    },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions
    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
        // http://www.w3.org/TR/css3-syntax/#characters
    characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        // Loosely modeled on CSS identifier characters
    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
    identifier = characterEncoding.replace("w", "w#"),
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + characterEncoding + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
    ".*" + ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
      "ID": new RegExp("^#(" + characterEncoding + ")"),
      "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
      "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function (_, escaped, escapedWhitespace) {
      var high = "0x" + escaped - 0x10000; // NaN means non-codepoint
      // Support: Firefox<24
      // Workaround erroneous numeric interpretation of +"0x"

      return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
      String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
      String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    },
        // Used for iframes
    // See setDocument()
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE
    unloadHandler = function () {
      setDocument();
    }; // Optimize for push.apply( _, NodeList )


    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
      // Detect silently failing push.apply

      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? // Leverage slice if possible
        function (target, els) {
          push_native.apply(target, slice.call(els));
        } : // Support: IE<9
        // Otherwise append directly
        function (target, els) {
          var j = target.length,
              i = 0; // Can't trust NodeList.length

          while (target[j++] = els[i++]) {}

          target.length = j - 1;
        }
      };
    }

    function Sizzle(selector, context, results, seed) {
      var match, elem, m, nodeType, // QSA vars
      i, groups, old, nid, newContext, newSelector;

      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }

      context = context || document;
      results = results || [];
      nodeType = context.nodeType;

      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }

      if (!seed && documentIsHTML) {
        // Try to shortcut find operations when possible (e.g., not under DocumentFragment)
        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
          // Speed-up: Sizzle("#ID")
          if (m = match[1]) {
            if (nodeType === 9) {
              elem = context.getElementById(m); // Check parentNode to catch when Blackberry 4.6 returns
              // nodes that are no longer in the document (jQuery #6963)

              if (elem && elem.parentNode) {
                // Handle the case where IE, Opera, and Webkit return items
                // by name instead of ID
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              // Context is not a document
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            } // Speed-up: Sizzle("TAG")

          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results; // Speed-up: Sizzle(".CLASS")
          } else if ((m = match[3]) && support.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        } // QSA path


        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType !== 1 && selector; // qSA works strangely on Element-rooted queries
          // We can work around this by specifying an extra ID on the root
          // and working up from there (Thanks to Andrew Dupont for the technique)
          // IE 8 doesn't work on object elements

          if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
            groups = tokenize(selector);

            if (old = context.getAttribute("id")) {
              nid = old.replace(rescape, "\\$&");
            } else {
              context.setAttribute("id", nid);
            }

            nid = "[id='" + nid + "'] ";
            i = groups.length;

            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }

            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            newSelector = groups.join(",");
          }

          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {} finally {
              if (!old) {
                context.removeAttribute("id");
              }
            }
          }
        }
      } // All others


      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    /**
     * Create key-value caches of limited size
     * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */


    function createCache() {
      var keys = [];

      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + " ") > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }

        return cache[key + " "] = value;
      }

      return cache;
    }
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */


    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created div and expects a boolean result
     */


    function assert(fn) {
      var div = document.createElement("div");

      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        } // release memory in IE


        div = null;
      }
    }
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */


    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = attrs.length;

      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */


    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE); // Use IE sourceIndex if available on both nodes

      if (diff) {
        return diff;
      } // Check if b follows a


      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */


    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */


    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */


    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length; // Match elements found at the specified indexes

          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */


    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    } // Expose support vars for convenience


    support = Sizzle.support = {};
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */

    isXML = Sizzle.isXML = function (elem) {
      // documentElement is verified for cases where it doesn't yet exist
      // (such as loading iframes in IE - #4833)
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */


    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare,
          parent,
          doc = node ? node.ownerDocument || node : preferredDoc; // If no document and documentElement is available, return

      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      } // Set our document


      document = doc;
      docElem = doc.documentElement;
      parent = doc.defaultView; // Support: IE>8
      // If iframe document is assigned to "document" variable and if iframe has been reloaded,
      // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
      // IE6-8 do not support the defaultView property so parent will be undefined

      if (parent && parent !== parent.top) {
        // IE11 does not have attachEvent, so all must suffer
        if (parent.addEventListener) {
          parent.addEventListener("unload", unloadHandler, false);
        } else if (parent.attachEvent) {
          parent.attachEvent("onunload", unloadHandler);
        }
      }
      /* Support tests
      ---------------------------------------------------------------------- */


      documentIsHTML = !isXML(doc);
      /* Attributes
      ---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)

      support.attributes = assert(function (div) {
        div.className = "i";
        return !div.getAttribute("className");
      });
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements

      support.getElementsByTagName = assert(function (div) {
        div.appendChild(doc.createComment(""));
        return !div.getElementsByTagName("*").length;
      }); // Support: IE<9

      support.getElementsByClassName = rnative.test(doc.getElementsByClassName); // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programatically-set names,
      // so use a roundabout getElementsByName test

      support.getById = assert(function (div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      }); // ID find and filter

      if (support.getById) {
        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var m = context.getElementById(id); // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963

            return m && m.parentNode ? [m] : [];
          }
        };

        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
      } else {
        // Support: IE6/7
        // getElementById is not reliable as a find shortcut
        delete Expr.find["ID"];

        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
      } // Tag


      Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem,
            tmp = [],
            i = 0,
            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName(tag); // Filter out possible comments

        if (tag === "*") {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }

          return tmp;
        }

        return results;
      }; // Class

      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
        if (documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See http://bugs.jquery.com/ticket/13378

      rbuggyQSA = [];

      if (support.qsa = rnative.test(doc.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (div) {
          // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // http://bugs.jquery.com/ticket/12359
          docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

          if (div.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          } // Support: IE8
          // Boolean attributes and "value" are not treated correctly


          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          } // Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+


          if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          } // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests


          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          } // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibing-combinator selector` fails


          if (!div.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function (div) {
          // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment
          var input = doc.createElement("input");
          input.setAttribute("type", "hidden");
          div.appendChild(input).setAttribute("name", "D"); // Support: IE8
          // Enforce case-sensitivity of name attribute

          if (div.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests


          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Opera 10-11 does not throw on post-comma invalid pseudos


          div.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }

      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (div) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(div, "div"); // This should fail with an exception
          // Gecko does not error, returns false instead

          matches.call(div, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      /* Contains
      ---------------------------------------------------------------------- */

      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
      // Purposefully does not implement inclusive descendent
      // As in, an element does not contain itself

      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }

        return false;
      };
      /* Sorting
      ---------------------------------------------------------------------- */
      // Document order sorting

      sortOrder = hasCompare ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } // Sort on method existence if only one input has compareDocumentPosition


        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

        if (compare) {
          return compare;
        } // Calculate position if both inputs belong to the same document


        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
        1; // Disconnected nodes

        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          // Choose the first element that is related to our preferred document
          if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }

          if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          } // Maintain original order


          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }

        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b]; // Parentless nodes are either documents or disconnected

        if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        } // Otherwise we need full lists of their ancestors for comparison


        cur = a;

        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }

        cur = b;

        while (cur = cur.parentNode) {
          bp.unshift(cur);
        } // Walk down the tree looking for a discrepancy


        while (ap[i] === bp[i]) {
          i++;
        }

        return i ? // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
        ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };

    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };

    Sizzle.matchesSelector = function (elem, expr) {
      // Set document vars if needed
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      } // Make sure that attribute selectors are quoted


      expr = expr.replace(rattributeQuotes, "='$1']");

      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }

      return Sizzle(expr, document, null, [elem]).length > 0;
    };

    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }

      return contains(context, elem);
    };

    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }

      var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };

    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */


    Sizzle.uniqueSort = function (results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0; // Unless we *know* we can detect duplicates, assume their presence

      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);

      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }

        while (j--) {
          results.splice(duplicates[j], 1);
        }
      } // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225


      sortInput = null;
      return results;
    };
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */


    getText = Sizzle.getText = function (elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while (node = elem[i++]) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      } // Do not include comment or processing instruction nodes


      return ret;
    };

    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        "ATTR": function (match) {
          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }

          return match.slice(0, 4);
        },
        "CHILD": function (match) {
          /* matches from matchExpr["CHILD"]
          	1 type (only|nth|...)
          	2 what (child|of-type)
          	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          	4 xn-component of xn+y argument ([+-]?\d*n|)
          	5 sign of xn-component
          	6 x of xn-component
          	7 sign of y-component
          	8 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if (match[1].slice(0, 3) === "nth") {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            } // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1


            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }

          return match;
        },
        "PSEUDO": function (match) {
          var excess,
              unquoted = !match[6] && match[2];

          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          } // Accept quoted arguments as-is


          if (match[3]) {
            match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
          excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          } // Return only captures needed by the pseudo filter method (type and argument)


          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function (className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === "!=";
            }

            if (!operator) {
              return true;
            }

            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function (type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
          function (elem) {
            return !!elem.parentNode;
          } : function (elem, context, xml) {
            var cache,
                outerCache,
                node,
                diff,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType;

            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;

                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  } // Reverse direction for :only-* (if we haven't yet done so)


                  start = dir = type === "only" && !start && "nextSibling";
                }

                return true;
              }

              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];

                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                } // Use previously-cached element index if available

              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1]; // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
              } else {
                // Use the same loop as above to seek `elem` from the start
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    // Cache the index of each encountered element
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                    }

                    if (node === elem) {
                      break;
                    }
                  }
                }
              } // Incorporate the offset, then check against cycle size


              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        "PSEUDO": function (pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does

          if (fn[expando]) {
            return fn(argument);
          } // But maintain support for old signatures


          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;

              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }

          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length; // Match elements unmatched by `matcher`

            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results); // Don't keep the element (issue #299)

            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }

          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;

            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);

            return false;
          };
        }),
        // Miscellaneous
        "target": function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function (elem) {
          return elem === docElem;
        },
        "focus": function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        "enabled": function (elem) {
          return elem.disabled === false;
        },
        "disabled": function (elem) {
          return elem.disabled === true;
        },
        "checked": function (elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        "selected": function (elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },
        // Contents
        "empty": function (elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }

          return true;
        },
        "parent": function (elem) {
          return !Expr.pseudos["empty"](elem);
        },
        // Element/input types
        "header": function (elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function (elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function (elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
          // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
          (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        // Position-in-collection
        "first": createPositionalPseudo(function () {
          return [0];
        }),
        "last": createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;

          for (; --i >= 0;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;

          for (; ++i < length;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }

    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    } // Easy API for creating new setFilters


    function setFilters() {}

    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }

          groups.push(tokens = []);
        }

        matched = false; // Combinators

        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        } // Filters


        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        if (!matched) {
          break;
        }
      } // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens


      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    };

    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";

      for (; i < len; i++) {
        selector += tokens[i].value;
      }

      return selector;
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        var oldCache,
            outerCache,
            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching

        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});

              if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                // Assign to newCache so results back-propagate to previous elements
                return newCache[2] = oldCache[2];
              } else {
                // Reuse newcache so results back-propagate to previous elements
                outerCache[dir] = newCache; // A match means we're done; a fail means we have to keep checking

                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }
      };
    }

    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;

        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }

        return true;
      } : matchers[0];
    }

    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;

      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }

      return results;
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);

            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }

      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }

      return markFunction(function (seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
        [] : // ...otherwise use results directly
        results : matcherIn; // Find primary matches

        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        } // Apply postFilter


        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

          i = temp.length;

          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;

              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }

              postFinder(null, matcherOut = [], temp, xml);
            } // Move matched elements from seed to results to keep them synchronized


            i = matcherOut.length;

            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          } // Add elements to results, through postFinder if defined

        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator(function (elem) {
        return elem === checkContext;
      }, implicitRelative, true),
          matchAnyContext = addCombinator(function (elem) {
        return indexOf(checkContext, elem) > -1;
      }, implicitRelative, true),
          matchers = [function (elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

        checkContext = null;
        return ret;
      }];

      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;

            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }

            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice(0, i - 1).concat({
              value: tokens[i - 2].type === " " ? "*" : ""
            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }

          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function (seed, context, xml, results, outermost) {
        var elem,
            j,
            matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
            // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
            len = elems.length;

        if (outermost) {
          outermostContext = context !== document && context;
        } // Add elements passing elementMatchers directly to results
        // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0;

            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context, xml)) {
                results.push(elem);
                break;
              }
            }

            if (outermost) {
              dirruns = dirrunsUnique;
            }
          } // Track unmatched elements for set filters


          if (bySet) {
            // They will have gone through all possible matchers
            if (elem = !matcher && elem) {
              matchedCount--;
            } // Lengthen the array for every element, matched or not


            if (seed) {
              unmatched.push(elem);
            }
          }
        } // Apply set filters to unmatched elements


        matchedCount += i;

        if (bySet && i !== matchedCount) {
          j = 0;

          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }

          if (seed) {
            // Reintegrate element matches to eliminate the need for sorting
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            } // Discard index placeholder values to get only actual matches


            setMatched = condense(setMatched);
          } // Add matches to results


          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        } // Override manipulation of globals by nested matchers


        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }

        return unmatched;
      };

      return bySet ? markFunction(superMatcher) : superMatcher;
    }

    compile = Sizzle.compile = function (selector, match
    /* Internal Use Only */
    ) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }

        i = match.length;

        while (i--) {
          cached = matcherFromTokens(match[i]);

          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        } // Cache the compiled function


        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

        cached.selector = selector;
      }

      return cached;
    };
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */


    select = Sizzle.select = function (selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || []; // Try to minimize operations if there is no seed and only one group

      if (match.length === 1) {
        // Take a shortcut and set the context if the root selector is an ID
        tokens = match[0] = match[0].slice(0);

        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

          if (!context) {
            return results; // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }

          selector = selector.slice(tokens.shift().value.length);
        } // Fetch a seed set for right-to-left matching


        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

        while (i--) {
          token = tokens[i]; // Abort if we hit a combinator

          if (Expr.relative[type = token.type]) {
            break;
          }

          if (find = Expr.find[type]) {
            // Search, expanding context for leading sibling combinators
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);

              if (!selector) {
                push.apply(results, seed);
                return results;
              }

              break;
            }
          }
        }
      } // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above


      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    }; // One-time assignments
    // Sort stability


    support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function

    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*

    support.sortDetached = assert(function (div1) {
      // Should return 1, but returns 4 (following)
      return div1.compareDocumentPosition(document.createElement("div")) & 1;
    }); // Support: IE<8
    // Prevent attribute/property "interpolation"
    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

    if (!assert(function (div) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    } // Support: IE<9
    // Use defaultValue in place of getAttribute("value")


    if (!support.attributes || !assert(function (div) {
      div.innerHTML = "<input/>";
      div.firstChild.setAttribute("value", "");
      return div.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    } // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies


    if (!assert(function (div) {
      return div.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;

        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }

    return Sizzle;
  }(window);

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
  var risSimple = /^.[^:#\[\.,]*$/; // Implement the identical functionality for filter and not

  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        /* jshint -W018 */
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }

    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    }

    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }

      qualifier = jQuery.filter(qualifier, elements);
    }

    return jQuery.grep(elements, function (elem) {
      return jQuery.inArray(elem, qualifier) >= 0 !== not;
    });
  }

  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };

  jQuery.fn.extend({
    find: function (selector) {
      var i,
          ret = [],
          self = this,
          len = self.length;

      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      } // Needed because $( selector, context ) becomes $( context ).find( selector )


      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function (selector) {
      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  }); // Initialize a jQuery object
  // A central reference to the root jQuery(document)

  var rootjQuery,
      // Use the correct document accordingly with window argument (sandbox)
  document = window.document,
      // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      init = jQuery.fn.init = function (selector, context) {
    var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

    if (!selector) {
      return this;
    } // Handle HTML strings


    if (typeof selector === "string") {
      if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [null, selector, null];
      } else {
        match = rquickExpr.exec(selector);
      } // Match html or make sure no context is specified for #id


      if (match && (match[1] || !context)) {
        // HANDLE: $(html) -> $(array)
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context; // scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present

          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {
              // Properties of context are called as methods if possible
              if (jQuery.isFunction(this[match])) {
                this[match](context[match]); // ...and otherwise set as attributes
              } else {
                this.attr(match, context[match]);
              }
            }
          }

          return this; // HANDLE: $(#id)
        } else {
          elem = document.getElementById(match[2]); // Check parentNode to catch when Blackberry 4.6 returns
          // nodes that are no longer in the document #6963

          if (elem && elem.parentNode) {
            // Handle the case where IE and Opera return items
            // by name instead of ID
            if (elem.id !== match[2]) {
              return rootjQuery.find(selector);
            } // Otherwise, we inject the element directly into the jQuery object


            this.length = 1;
            this[0] = elem;
          }

          this.context = document;
          this.selector = selector;
          return this;
        } // HANDLE: $(expr, $(...))

      } else if (!context || context.jquery) {
        return (context || rootjQuery).find(selector); // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor(context).find(selector);
      } // HANDLE: $(DOMElement)

    } else if (selector.nodeType) {
      this.context = this[0] = selector;
      this.length = 1;
      return this; // HANDLE: $(function)
      // Shortcut for document ready
    } else if (jQuery.isFunction(selector)) {
      return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : // Execute immediately if ready is not present
      selector(jQuery);
    }

    if (selector.selector !== undefined) {
      this.selector = selector.selector;
      this.context = selector.context;
    }

    return jQuery.makeArray(selector, this);
  }; // Give the init function the jQuery prototype for later instantiation


  init.prototype = jQuery.fn; // Initialize central reference

  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      // methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };
  jQuery.extend({
    dir: function (elem, dir, until) {
      var matched = [],
          cur = elem[dir];

      while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
        if (cur.nodeType === 1) {
          matched.push(cur);
        }

        cur = cur[dir];
      }

      return matched;
    },
    sibling: function (n, elem) {
      var r = [];

      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          r.push(n);
        }
      }

      return r;
    }
  });
  jQuery.fn.extend({
    has: function (target) {
      var i,
          targets = jQuery(target, this),
          len = targets.length;
      return this.filter(function () {
        for (i = 0; i < len; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function (selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          // Always skip document fragments
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : // Don't pass non-elements to Sizzle
          cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }

      return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
    },
    // Determine the position of an element within
    // the matched set of elements
    index: function (elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      } // index in selector


      if (typeof elem === "string") {
        return jQuery.inArray(this[0], jQuery(elem));
      } // Locate the position of the desired element


      return jQuery.inArray( // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem, this);
    },
    add: function (selector, context) {
      return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });

  function sibling(cur, dir) {
    do {
      cur = cur[dir];
    } while (cur && cur.nodeType !== 1);

    return cur;
  }

  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return jQuery.dir(elem, "parentNode");
    },
    parentsUntil: function (elem, i, until) {
      return jQuery.dir(elem, "parentNode", until);
    },
    next: function (elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function (elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function (elem) {
      return jQuery.dir(elem, "nextSibling");
    },
    prevAll: function (elem) {
      return jQuery.dir(elem, "previousSibling");
    },
    nextUntil: function (elem, i, until) {
      return jQuery.dir(elem, "nextSibling", until);
    },
    prevUntil: function (elem, i, until) {
      return jQuery.dir(elem, "previousSibling", until);
    },
    siblings: function (elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function (elem) {
      return jQuery.nodeName(elem, "iframe") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var ret = jQuery.map(this, fn, until);

      if (name.slice(-5) !== "Until") {
        selector = until;
      }

      if (selector && typeof selector === "string") {
        ret = jQuery.filter(selector, ret);
      }

      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          ret = jQuery.unique(ret);
        } // Reverse order for parents* and prev-derivatives


        if (rparentsprev.test(name)) {
          ret = ret.reverse();
        }
      }

      return this.pushStack(ret);
    };
  });
  var rnotwhite = /\S+/g; // String to Object options format cache

  var optionsCache = {}; // Convert String-formatted options into Object-formatted ones and store in cache

  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
    firing,
        // Last fire value (for non-forgettable lists)
    memory,
        // Flag to know if list was already fired
    fired,
        // End of the loop when firing
    firingLength,
        // Index of currently firing callback (modified by remove if needed)
    firingIndex,
        // First callback to fire (used internally by add and fireWith)
    firingStart,
        // Actual callback list
    list = [],
        // Stack of fire calls for repeatable lists
    stack = !options.once && [],
        // Fire callbacks
    fire = function (data) {
      memory = options.memory && data;
      fired = true;
      firingIndex = firingStart || 0;
      firingStart = 0;
      firingLength = list.length;
      firing = true;

      for (; list && firingIndex < firingLength; firingIndex++) {
        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
          memory = false; // To prevent further calls using add

          break;
        }
      }

      firing = false;

      if (list) {
        if (stack) {
          if (stack.length) {
            fire(stack.shift());
          }
        } else if (memory) {
          list = [];
        } else {
          self.disable();
        }
      }
    },
        // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function () {
        if (list) {
          // First, we save the current length
          var start = list.length;

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              var type = jQuery.type(arg);

              if (type === "function") {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && type !== "string") {
                // Inspect recursively
                add(arg);
              }
            });
          })(arguments); // Do we need to add the callbacks to the
          // current firing batch?


          if (firing) {
            firingLength = list.length; // With memory, if we're not firing then
            // we should call right away
          } else if (memory) {
            firingStart = start;
            fire(memory);
          }
        }

        return this;
      },
      // Remove a callback from the list
      remove: function () {
        if (list) {
          jQuery.each(arguments, function (_, arg) {
            var index;

            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1); // Handle firing indexes

              if (firing) {
                if (index <= firingLength) {
                  firingLength--;
                }

                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            }
          });
        }

        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function (fn) {
        return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
      },
      // Remove all callbacks from the list
      empty: function () {
        list = [];
        firingLength = 0;
        return this;
      },
      // Have the list do nothing anymore
      disable: function () {
        list = stack = memory = undefined;
        return this;
      },
      // Is it disabled?
      disabled: function () {
        return !list;
      },
      // Lock the list in its current state
      lock: function () {
        stack = undefined;

        if (!memory) {
          self.disable();
        }

        return this;
      },
      // Is it locked?
      locked: function () {
        return !stack;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function (context, args) {
        if (list && (!fired || stack)) {
          args = args || [];
          args = [context, args.slice ? args.slice() : args];

          if (firing) {
            stack.push(args);
          } else {
            fire(args);
          }
        }

        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function () {
        self.fireWith(this, arguments);
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function () {
        return !!fired;
      }
    };

    return self;
  };

  jQuery.extend({
    Deferred: function (func) {
      var tuples = [// action, add listener, listener list, final state
      ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
          state = "pending",
          promise = {
        state: function () {
          return state;
        },
        always: function () {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        then: function ()
        /* fnDone, fnFail, fnProgress */
        {
          var fns = arguments;
          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (i, tuple) {
              var fn = jQuery.isFunction(fns[i]) && fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer

              deferred[tuple[1]](function () {
                var returned = fn && fn.apply(this, arguments);

                if (returned && jQuery.isFunction(returned.promise)) {
                  returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                } else {
                  newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                }
              });
            });
            fns = null;
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function (obj) {
          return obj != null ? jQuery.extend(obj, promise) : promise;
        }
      },
          deferred = {}; // Keep pipe for back-compat

      promise.pipe = promise.then; // Add list-specific methods

      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
            stateString = tuple[3]; // promise[ done | fail | progress ] = list.add

        promise[tuple[1]] = list.add; // Handle state

        if (stateString) {
          list.add(function () {
            // state = [ resolved | rejected ]
            state = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        } // deferred[ resolve | reject | notify ]


        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };

        deferred[tuple[0] + "With"] = list.fireWith;
      }); // Make the deferred a promise

      promise.promise(deferred); // Call given func if any

      if (func) {
        func.call(deferred, deferred);
      } // All done!


      return deferred;
    },
    // Deferred helper
    when: function (subordinate
    /* , ..., subordinateN */
    ) {
      var i = 0,
          resolveValues = slice.call(arguments),
          length = resolveValues.length,
          // the count of uncompleted subordinates
      remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
          // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
      deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
          // Update function for both resolve and progress values
      updateFunc = function (i, contexts, values) {
        return function (value) {
          contexts[i] = this;
          values[i] = arguments.length > 1 ? slice.call(arguments) : value;

          if (values === progressValues) {
            deferred.notifyWith(contexts, values);
          } else if (! --remaining) {
            deferred.resolveWith(contexts, values);
          }
        };
      },
          progressValues,
          progressContexts,
          resolveContexts; // add listeners to Deferred subordinates; treat others as resolved


      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);

        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      } // if we're not waiting on anything, resolve the master


      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }

      return deferred.promise();
    }
  }); // The deferred used on DOM ready

  var readyList;

  jQuery.fn.ready = function (fn) {
    // Add the callback
    jQuery.ready.promise().done(fn);
    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,
    // Hold (or release) the ready event
    holdReady: function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    // Handle when the DOM is ready
    ready: function (wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      } // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).


      if (!document.body) {
        return setTimeout(jQuery.ready);
      } // Remember that the DOM is ready


      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      } // If there are functions bound, to execute


      readyList.resolveWith(document, [jQuery]); // Trigger any bound ready events

      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });
  /**
   * Clean-up method for dom ready events
   */

  function detach() {
    if (document.addEventListener) {
      document.removeEventListener("DOMContentLoaded", completed, false);
      window.removeEventListener("load", completed, false);
    } else {
      document.detachEvent("onreadystatechange", completed);
      window.detachEvent("onload", completed);
    }
  }
  /**
   * The ready event handler and self cleanup method
   */


  function completed() {
    // readyState === "complete" is good enough for us to call the dom ready in oldIE
    if (document.addEventListener || event.type === "load" || document.readyState === "complete") {
      detach();
      jQuery.ready();
    }
  }

  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred(); // Catch cases where $(document).ready() is called after the browser event has already occurred.
      // we once tried to use readyState "interactive" here, but it caused issues like the one
      // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15

      if (document.readyState === "complete") {
        // Handle it asynchronously to allow scripts the opportunity to delay ready
        setTimeout(jQuery.ready); // Standards-based browsers support DOMContentLoaded
      } else if (document.addEventListener) {
        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed, false); // A fallback to window.onload, that will always work

        window.addEventListener("load", completed, false); // If IE event model is used
      } else {
        // Ensure firing before onload, maybe late but safe also for iframes
        document.attachEvent("onreadystatechange", completed); // A fallback to window.onload, that will always work

        window.attachEvent("onload", completed); // If IE and not a frame
        // continually check to see if the document is ready

        var top = false;

        try {
          top = window.frameElement == null && document.documentElement;
        } catch (e) {}

        if (top && top.doScroll) {
          (function doScrollCheck() {
            if (!jQuery.isReady) {
              try {
                // Use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                top.doScroll("left");
              } catch (e) {
                return setTimeout(doScrollCheck, 50);
              } // detach all dom ready events


              detach(); // and execute any waiting functions

              jQuery.ready();
            }
          })();
        }
      }
    }

    return readyList.promise(obj);
  };

  var strundefined = typeof undefined; // Support: IE<9
  // Iteration over object's inherited properties before its own

  var i;

  for (i in jQuery(support)) {
    break;
  }

  support.ownLast = i !== "0"; // Note: most support tests are defined in their respective modules.
  // false until the test is run

  support.inlineBlockNeedsLayout = false; // Execute ASAP in case we need to set body.style.zoom

  jQuery(function () {
    // Minified: var a,b,c,d
    var val, div, body, container;
    body = document.getElementsByTagName("body")[0];

    if (!body || !body.style) {
      // Return for frameset docs that don't have a body
      return;
    } // Setup


    div = document.createElement("div");
    container = document.createElement("div");
    container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
    body.appendChild(container).appendChild(div);

    if (typeof div.style.zoom !== strundefined) {
      // Support: IE<8
      // Check if natively block-level elements act like inline-block
      // elements when setting their display to 'inline' and giving
      // them layout
      div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";
      support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;

      if (val) {
        // Prevent IE 6 from affecting layout for positioned elements #11048
        // Prevent IE from shrinking the body in IE 7 mode #12869
        // Support: IE<8
        body.style.zoom = 1;
      }
    }

    body.removeChild(container);
  });

  (function () {
    var div = document.createElement("div"); // Execute the test only if not already executed in another module.

    if (support.deleteExpando == null) {
      // Support: IE<9
      support.deleteExpando = true;

      try {
        delete div.test;
      } catch (e) {
        support.deleteExpando = false;
      }
    } // Null elements to avoid leaks in IE.


    div = null;
  })();
  /**
   * Determines whether an object can have data
   */


  jQuery.acceptData = function (elem) {
    var noData = jQuery.noData[(elem.nodeName + " ").toLowerCase()],
        nodeType = +elem.nodeType || 1; // Do not set data on non-element DOM nodes because it will not be cleared (#8335).

    return nodeType !== 1 && nodeType !== 9 ? false : // Nodes accept data unless otherwise specified; rejection can be conditional
    !noData || noData !== true && elem.getAttribute("classid") === noData;
  };

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /([A-Z])/g;

  function dataAttr(elem, key, data) {
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if (data === undefined && elem.nodeType === 1) {
      var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = data === "true" ? true : data === "false" ? false : data === "null" ? null : // Only convert to a number if it doesn't change the string
          +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {} // Make sure we set the data so it isn't changed later


        jQuery.data(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  } // checks a cache object for emptiness


  function isEmptyDataObject(obj) {
    var name;

    for (name in obj) {
      // if the public data object is empty, the private is still empty
      if (name === "data" && jQuery.isEmptyObject(obj[name])) {
        continue;
      }

      if (name !== "toJSON") {
        return false;
      }
    }

    return true;
  }

  function internalData(elem, name, data, pvt
  /* Internal Use Only */
  ) {
    if (!jQuery.acceptData(elem)) {
      return;
    }

    var ret,
        thisCache,
        internalKey = jQuery.expando,
        // We have to handle DOM nodes and JS objects differently because IE6-7
    // can't GC object references properly across the DOM-JS boundary
    isNode = elem.nodeType,
        // Only DOM nodes need the global jQuery cache; JS object data is
    // attached directly to the object so GC can occur automatically
    cache = isNode ? jQuery.cache : elem,
        // Only defining an ID for JS objects if its cache already exists allows
    // the code to shortcut on the same path as a DOM node with no cache
    id = isNode ? elem[internalKey] : elem[internalKey] && internalKey; // Avoid doing any more work than we need to when trying to get data on an
    // object that has no data at all

    if ((!id || !cache[id] || !pvt && !cache[id].data) && data === undefined && typeof name === "string") {
      return;
    }

    if (!id) {
      // Only DOM nodes need a new unique ID for each element since their data
      // ends up in the global cache
      if (isNode) {
        id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
      } else {
        id = internalKey;
      }
    }

    if (!cache[id]) {
      // Avoid exposing jQuery metadata on plain JS objects when the object
      // is serialized using JSON.stringify
      cache[id] = isNode ? {} : {
        toJSON: jQuery.noop
      };
    } // An object can be passed to jQuery.data instead of a key/value pair; this gets
    // shallow copied over onto the existing cache


    if (typeof name === "object" || typeof name === "function") {
      if (pvt) {
        cache[id] = jQuery.extend(cache[id], name);
      } else {
        cache[id].data = jQuery.extend(cache[id].data, name);
      }
    }

    thisCache = cache[id]; // jQuery data() is stored in a separate object inside the object's internal data
    // cache in order to avoid key collisions between internal data and user-defined
    // data.

    if (!pvt) {
      if (!thisCache.data) {
        thisCache.data = {};
      }

      thisCache = thisCache.data;
    }

    if (data !== undefined) {
      thisCache[jQuery.camelCase(name)] = data;
    } // Check for both converted-to-camel and non-converted data property names
    // If a data property was specified


    if (typeof name === "string") {
      // First Try to find as-is property data
      ret = thisCache[name]; // Test for null|undefined property data

      if (ret == null) {
        // Try to find the camelCased property
        ret = thisCache[jQuery.camelCase(name)];
      }
    } else {
      ret = thisCache;
    }

    return ret;
  }

  function internalRemoveData(elem, name, pvt) {
    if (!jQuery.acceptData(elem)) {
      return;
    }

    var thisCache,
        i,
        isNode = elem.nodeType,
        // See jQuery.data for more information
    cache = isNode ? jQuery.cache : elem,
        id = isNode ? elem[jQuery.expando] : jQuery.expando; // If there is already no cache entry for this object, there is no
    // purpose in continuing

    if (!cache[id]) {
      return;
    }

    if (name) {
      thisCache = pvt ? cache[id] : cache[id].data;

      if (thisCache) {
        // Support array or space separated string names for data keys
        if (!jQuery.isArray(name)) {
          // try the string as a key before any manipulation
          if (name in thisCache) {
            name = [name];
          } else {
            // split the camel cased version by spaces unless a key with the spaces exists
            name = jQuery.camelCase(name);

            if (name in thisCache) {
              name = [name];
            } else {
              name = name.split(" ");
            }
          }
        } else {
          // If "name" is an array of keys...
          // When data is initially created, via ("key", "val") signature,
          // keys will be converted to camelCase.
          // Since there is no way to tell _how_ a key was added, remove
          // both plain key and camelCase key. #12786
          // This will only penalize the array argument path.
          name = name.concat(jQuery.map(name, jQuery.camelCase));
        }

        i = name.length;

        while (i--) {
          delete thisCache[name[i]];
        } // If there is no data left in the cache, we want to continue
        // and let the cache object itself get destroyed


        if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
          return;
        }
      }
    } // See jQuery.data for more information


    if (!pvt) {
      delete cache[id].data; // Don't destroy the parent cache unless the internal data object
      // had been the only thing left in it

      if (!isEmptyDataObject(cache[id])) {
        return;
      }
    } // Destroy the cache


    if (isNode) {
      jQuery.cleanData([elem], true); // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)

      /* jshint eqeqeq: false */
    } else if (support.deleteExpando || cache != cache.window) {
      /* jshint eqeqeq: true */
      delete cache[id]; // When all else fails, null
    } else {
      cache[id] = null;
    }
  }

  jQuery.extend({
    cache: {},
    // The following elements (space-suffixed to avoid Object.prototype collisions)
    // throw uncatchable exceptions if you attempt to set expando properties
    noData: {
      "applet ": true,
      "embed ": true,
      // ...but Flash objects (which have this classid) *can* handle expandos
      "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
    },
    hasData: function (elem) {
      elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
      return !!elem && !isEmptyDataObject(elem);
    },
    data: function (elem, name, data) {
      return internalData(elem, name, data);
    },
    removeData: function (elem, name) {
      return internalRemoveData(elem, name);
    },
    // For internal use only.
    _data: function (elem, name, data) {
      return internalData(elem, name, data, true);
    },
    _removeData: function (elem, name) {
      return internalRemoveData(elem, name, true);
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes; // Special expections of .data basically thwart jQuery.access,
      // so implement the relevant behavior ourselves
      // Gets all values

      if (key === undefined) {
        if (this.length) {
          data = jQuery.data(elem);

          if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
            i = attrs.length;

            while (i--) {
              // Support: IE11+
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;

                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }

            jQuery._data(elem, "parsedAttrs", true);
          }
        }

        return data;
      } // Sets multiple values


      if (typeof key === "object") {
        return this.each(function () {
          jQuery.data(this, key);
        });
      }

      return arguments.length > 1 ? // Sets one value
      this.each(function () {
        jQuery.data(this, key, value);
      }) : // Gets one value
      // Try to fetch any internally stored data first
      elem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;
    },
    removeData: function (key) {
      return this.each(function () {
        jQuery.removeData(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = jQuery._data(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = jQuery._data(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }

        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function () {
        jQuery.dequeue(elem, type);
      }; // If the fx queue is dequeued, always remove the progress sentinel


      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        } // clear up the last queue stop function


        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // not intended for public consumption - generates a queueHooks object, or returns the current one
    _queueHooks: function (elem, type) {
      var key = type + "queueHooks";
      return jQuery._data(elem, key) || jQuery._data(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          jQuery._removeData(elem, type + "queue");

          jQuery._removeData(elem, key);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data); // ensure a hooks for this queue

        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function (type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function (type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function () {
        if (! --count) {
          defer.resolveWith(elements, [elements]);
        }
      };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }

      type = type || "fx";

      while (i--) {
        tmp = jQuery._data(elements[i], type + "queueHooks");

        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }

      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var cssExpand = ["Top", "Right", "Bottom", "Left"];

  var isHidden = function (elem, el) {
    // isHidden might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  }; // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function


  var access = jQuery.access = function (elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        length = elems.length,
        bulk = key == null; // Sets many values

    if (jQuery.type(key) === "object") {
      chainable = true;

      for (i in key) {
        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
      } // Sets one value

    } else if (value !== undefined) {
      chainable = true;

      if (!jQuery.isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null; // ...except when executing function values
        } else {
          bulk = fn;

          fn = function (elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < length; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }

    return chainable ? elems : // Gets
    bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
  };

  var rcheckableType = /^(?:checkbox|radio)$/i;

  (function () {
    // Minified: var a,b,c
    var input = document.createElement("input"),
        div = document.createElement("div"),
        fragment = document.createDocumentFragment(); // Setup

    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>"; // IE strips leading whitespace when .innerHTML is used

    support.leadingWhitespace = div.firstChild.nodeType === 3; // Make sure that tbody elements aren't automatically inserted
    // IE will insert them into empty tables

    support.tbody = !div.getElementsByTagName("tbody").length; // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE

    support.htmlSerialize = !!div.getElementsByTagName("link").length; // Makes sure cloning an html5 element does not cause problems
    // Where outerHTML is undefined, this still works

    support.html5Clone = document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>"; // Check if a disconnected checkbox will retain its checked
    // value of true after appended to the DOM (IE6/7)

    input.type = "checkbox";
    input.checked = true;
    fragment.appendChild(input);
    support.appendChecked = input.checked; // Make sure textarea (and checkbox) defaultValue is properly cloned
    // Support: IE6-IE11+

    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // #11217 - WebKit loses check when the name is after the checked attribute

    fragment.appendChild(div);
    div.innerHTML = "<input type='radio' checked='checked' name='t'/>"; // Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
    // old WebKit doesn't clone checked state correctly in fragments

    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE<9
    // Opera does not clone events (and typeof div.attachEvent === undefined).
    // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()

    support.noCloneEvent = true;

    if (div.attachEvent) {
      div.attachEvent("onclick", function () {
        support.noCloneEvent = false;
      });
      div.cloneNode(true).click();
    } // Execute the test only if not already executed in another module.


    if (support.deleteExpando == null) {
      // Support: IE<9
      support.deleteExpando = true;

      try {
        delete div.test;
      } catch (e) {
        support.deleteExpando = false;
      }
    }
  })();

  (function () {
    var i,
        eventName,
        div = document.createElement("div"); // Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)

    for (i in {
      submit: true,
      change: true,
      focusin: true
    }) {
      eventName = "on" + i;

      if (!(support[i + "Bubbles"] = eventName in window)) {
        // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
        div.setAttribute(eventName, "t");
        support[i + "Bubbles"] = div.attributes[eventName].expando === false;
      }
    } // Null elements to avoid leaks in IE.


    div = null;
  })();

  var rformElems = /^(?:input|select|textarea)$/i,
      rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
      rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  }

  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var tmp,
          events,
          t,
          handleObjIn,
          special,
          eventHandle,
          handleObj,
          handlers,
          type,
          namespaces,
          origType,
          elemData = jQuery._data(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)


      if (!elemData) {
        return;
      } // Caller can pass in an object of custom data in lieu of the handler


      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      } // Make sure that the handler has a unique ID, used to find/remove it later


      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      } // Init the element's event structure and main handler, if this is the first


      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }

      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
        }; // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events


        eventHandle.elem = elem;
      } // Handle multiple events separated by a space


      types = (types || "").match(rnotwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

        if (!type) {
          continue;
        } // If event changes its type, use the special event handlers for the changed type


        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn); // Init the event handler queue if we're the first

        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0; // Only use addEventListener/attachEvent if the special events handler returns false

          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            // Bind the global event handler to the element
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            } else if (elem.attachEvent) {
              elem.attachEvent("on" + type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        } // Add to the element's handler list, delegates in front


        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        } // Keep track of which events have ever been used, for event optimization


        jQuery.event.global[type] = true;
      } // Nullify elem to prevent memory leaks in IE


      elem = null;
    },
    // Detach an event or set of events from an element
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j,
          handleObj,
          tmp,
          origCount,
          t,
          events,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = jQuery.hasData(elem) && jQuery._data(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      } // Once for each type.namespace in types; type may be omitted


      types = (types || "").match(rnotwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }

          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

        origCount = j = handlers.length;

        while (j--) {
          handleObj = handlers[j];

          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }

            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        } // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)


        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      } // Remove the expando if it's no longer used


      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle; // removeData also checks for emptiness and clears the expando if empty
        // so use it instead of delete

        jQuery._removeData(elem, "events");
      }
    },
    trigger: function (event, data, elem, onlyHandlers) {
      var handle,
          ontype,
          cur,
          bubbleType,
          special,
          tmp,
          i,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document; // Don't do events on text and comment nodes

      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      } // focus/blur morphs to focusin/out; ensure we're not firing them right now


      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") >= 0) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }

      ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

      event.result = undefined;

      if (!event.target) {
        event.target = elem;
      } // Clone any incoming data and prepend the event, creating the handler arg list


      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

      special = jQuery.event.special[type] || {};

      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      } // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;

        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }

        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      } // Fire handlers on the event path


      i = 0;

      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

        handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        } // Native handler


        handle = ontype && cur[ontype];

        if (handle && handle.apply && jQuery.acceptData(cur)) {
          event.result = handle.apply(cur, data);

          if (event.result === false) {
            event.preventDefault();
          }
        }
      }

      event.type = type; // If nobody prevented the default action, do it now

      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          // Call a native DOM method on the target with the same name name as the event.
          // Can't use an .isFunction() check here because IE6/7 fails that test.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && elem[type] && !jQuery.isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            } // Prevent re-triggering of the same event, since we already bubbled it above


            jQuery.event.triggered = type;

            try {
              elem[type]();
            } catch (e) {// IE<9 dies on focus/blur to hidden element (#1486,#12518)
              // only reproducible on winXP IE8 native, not IE9 in IE8 mode
            }

            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },
    dispatch: function (event) {
      // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(event);
      var i,
          ret,
          handleObj,
          matched,
          j,
          handlerQueue = [],
          args = slice.call(arguments),
          handlers = (jQuery._data(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

      args[0] = event;
      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      } // Determine handlers


      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

      i = 0;

      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;

        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // Triggered event must either 1) have no namespace, or
          // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      } // Call the postDispatch hook for the mapped type


      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },
    handlers: function (event, handlers) {
      var sel,
          handleObj,
          matches,
          i,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target; // Find delegate handlers
      // Black-hole SVG <use> instance trees (#13180)
      // Avoid non-left-click bubbling in Firefox (#3861)

      if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
        /* jshint eqeqeq: false */
        for (; cur != this; cur = cur.parentNode || this) {
          /* jshint eqeqeq: true */
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
            matches = [];

            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i]; // Don't conflict with Object.prototype properties (#13203)

              sel = handleObj.selector + " ";

              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }

              if (matches[sel]) {
                matches.push(handleObj);
              }
            }

            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      } // Add the remaining (directly-bound) handlers


      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }

      return handlerQueue;
    },
    fix: function (event) {
      if (event[jQuery.expando]) {
        return event;
      } // Create a writable copy of the event object and normalize some properties


      var i,
          prop,
          copy,
          type = event.type,
          originalEvent = event,
          fixHook = this.fixHooks[type];

      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }

      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;

      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      } // Support: IE<9
      // Fix target property (#1925)


      if (!event.target) {
        event.target = originalEvent.srcElement || document;
      } // Support: Chrome 23+, Safari?
      // Target should not be a text node (#504, #13143)


      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      } // Support: IE<9
      // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)


      event.metaKey = !!event.metaKey;
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    // Includes some event props shared by KeyEvent and MouseEvent
    props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function (event, original) {
        // Add which for key events
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }

        return event;
      }
    },
    mouseHooks: {
      props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
      filter: function (event, original) {
        var body,
            eventDoc,
            doc,
            button = original.button,
            fromElement = original.fromElement; // Calculate pageX/Y if missing and clientX/Y available

        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        } // Add relatedTarget, if necessary


        if (!event.relatedTarget && fromElement) {
          event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
        } // Add which for click: 1 === left; 2 === middle; 3 === right
        // Note: button is not normalized, so don't use it


        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }

        return event;
      }
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      focus: {
        // Fire native event if possible so blur/focus sequence is correct
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            try {
              this.focus();
              return false;
            } catch (e) {// Support: IE<9
              // If we error on focus to hidden element (#1486, #12518),
              // let .trigger() run the handlers
            }
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        // For checkbox, fire native event so checked state will be right
        trigger: function () {
          if (jQuery.nodeName(this, "input") && this.type === "checkbox" && this.click) {
            this.click();
            return false;
          }
        },
        // For cross-browser consistency, don't fire native .click() on links
        _default: function (event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },
    simulate: function (type, elem, event, bubble) {
      // Piggyback on a donor event to simulate a different one.
      // Fake originalEvent to avoid donor's stopPropagation, but if the
      // simulated event prevents default then we do the same on the donor.
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true,
        originalEvent: {}
      });

      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }

      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  } : function (elem, type, handle) {
    var name = "on" + type;

    if (elem.detachEvent) {
      // #8545, #7054, preventing memory leaks for custom events in IE6-8
      // detachEvent needed property on element, by name of that event, to properly expose it to GC
      if (typeof elem[name] === strundefined) {
        elem[name] = null;
      }

      elem.detachEvent(name, handle);
    }
  };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    } // Event object


    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: IE < 9, Android < 4.0
      src.returnValue === false ? returnTrue : returnFalse; // Event type
    } else {
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props) {
      jQuery.extend(this, props);
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || jQuery.now(); // Mark it as fixed

    this[jQuery.expando] = true;
  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;

      if (!e) {
        return;
      } // If preventDefault exists, run it on the original event


      if (e.preventDefault) {
        e.preventDefault(); // Support: IE
        // Otherwise set the returnValue property of the original event to false
      } else {
        e.returnValue = false;
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;

      if (!e) {
        return;
      } // If stopPropagation exists, run it on the original event


      if (e.stopPropagation) {
        e.stopPropagation();
      } // Support: IE
      // Set the cancelBubble property of the original event to true


      e.cancelBubble = true;
    },
    stopImmediatePropagation: function () {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;

      if (e && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  }; // Create mouseenter/leave events using mouseover/out and event-time checks

  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj; // For mousenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window

        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  }); // IE submit delegation

  if (!support.submitBubbles) {
    jQuery.event.special.submit = {
      setup: function () {
        // Only need this for delegated form submit events
        if (jQuery.nodeName(this, "form")) {
          return false;
        } // Lazy-add a submit handler when a descendant form may potentially be submitted


        jQuery.event.add(this, "click._submit keypress._submit", function (e) {
          // Node name check avoids a VML-related crash in IE (#9807)
          var elem = e.target,
              form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined;

          if (form && !jQuery._data(form, "submitBubbles")) {
            jQuery.event.add(form, "submit._submit", function (event) {
              event._submit_bubble = true;
            });

            jQuery._data(form, "submitBubbles", true);
          }
        }); // return undefined since we don't need an event listener
      },
      postDispatch: function (event) {
        // If form was submitted by the user, bubble the event up the tree
        if (event._submit_bubble) {
          delete event._submit_bubble;

          if (this.parentNode && !event.isTrigger) {
            jQuery.event.simulate("submit", this.parentNode, event, true);
          }
        }
      },
      teardown: function () {
        // Only need this for delegated form submit events
        if (jQuery.nodeName(this, "form")) {
          return false;
        } // Remove delegated handlers; cleanData eventually reaps submit handlers attached above


        jQuery.event.remove(this, "._submit");
      }
    };
  } // IE change delegation and checkbox/radio fix


  if (!support.changeBubbles) {
    jQuery.event.special.change = {
      setup: function () {
        if (rformElems.test(this.nodeName)) {
          // IE doesn't fire change on a check/radio until blur; trigger it on click
          // after a propertychange. Eat the blur-change in special.change.handle.
          // This still fires onchange a second time for check/radio after blur.
          if (this.type === "checkbox" || this.type === "radio") {
            jQuery.event.add(this, "propertychange._change", function (event) {
              if (event.originalEvent.propertyName === "checked") {
                this._just_changed = true;
              }
            });
            jQuery.event.add(this, "click._change", function (event) {
              if (this._just_changed && !event.isTrigger) {
                this._just_changed = false;
              } // Allow triggered, simulated change events (#11500)


              jQuery.event.simulate("change", this, event, true);
            });
          }

          return false;
        } // Delegated event; lazy-add a change handler on descendant inputs


        jQuery.event.add(this, "beforeactivate._change", function (e) {
          var elem = e.target;

          if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "changeBubbles")) {
            jQuery.event.add(elem, "change._change", function (event) {
              if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                jQuery.event.simulate("change", this.parentNode, event, true);
              }
            });

            jQuery._data(elem, "changeBubbles", true);
          }
        });
      },
      handle: function (event) {
        var elem = event.target; // Swallow native change events from checkbox/radio, we already triggered them above

        if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== "radio" && elem.type !== "checkbox") {
          return event.handleObj.handler.apply(this, arguments);
        }
      },
      teardown: function () {
        jQuery.event.remove(this, "._change");
        return !rformElems.test(this.nodeName);
      }
    };
  } // Create "bubbling" focus and blur events


  if (!support.focusinBubbles) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function (event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };

      jQuery.event.special[fix] = {
        setup: function () {
          var doc = this.ownerDocument || this,
              attaches = jQuery._data(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }

          jQuery._data(doc, fix, (attaches || 0) + 1);
        },
        teardown: function () {
          var doc = this.ownerDocument || this,
              attaches = jQuery._data(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);

            jQuery._removeData(doc, fix);
          } else {
            jQuery._data(doc, fix, attaches);
          }
        }
      };
    });
  }

  jQuery.fn.extend({
    on: function (types, selector, data, fn,
    /*INTERNAL*/
    one) {
      var type, origFn; // Types can be a map of types/handlers

      if (typeof types === "object") {
        // ( types-Object, selector, data )
        if (typeof selector !== "string") {
          // ( types-Object, data )
          data = data || selector;
          selector = undefined;
        }

        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }

        return this;
      }

      if (data == null && fn == null) {
        // ( types, fn )
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          // ( types, selector, fn )
          fn = data;
          data = undefined;
        } else {
          // ( types, data, fn )
          fn = data;
          data = selector;
          selector = undefined;
        }
      }

      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }

      if (one === 1) {
        origFn = fn;

        fn = function (event) {
          // Can use an empty set, since event contains the info
          jQuery().off(event);
          return origFn.apply(this, arguments);
        }; // Use same guid so caller can remove using origFn


        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }

      return this.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function (types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;

      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }

      if (typeof types === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }

        return this;
      }

      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }

      if (fn === false) {
        fn = returnFalse;
      }

      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];

      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });

  function createSafeFragment(document) {
    var list = nodeNames.split("|"),
        safeFrag = document.createDocumentFragment();

    if (safeFrag.createElement) {
      while (list.length) {
        safeFrag.createElement(list.pop());
      }
    }

    return safeFrag;
  }

  var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" + "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
      rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
      rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
      rleadingWhitespace = /^\s+/,
      rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
      rtagName = /<([\w:]+)/,
      rtbody = /<tbody/i,
      rhtml = /<|&#?\w+;/,
      rnoInnerhtml = /<(?:script|style|link)/i,
      // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptType = /^$|\/(?:java|ecma)script/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
      // We have to close these tags to support XHTML (#13200)
  wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    legend: [1, "<fieldset>", "</fieldset>"],
    area: [1, "<map>", "</map>"],
    param: [1, "<object>", "</object>"],
    thead: [1, "<table>", "</table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
    // unless wrapped in a div with non-breaking characters in front of it.
    _default: support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
  },
      safeFragment = createSafeFragment(document),
      fragmentDiv = safeFragment.appendChild(document.createElement("div"));
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;

  function getAll(context, tag) {
    var elems,
        elem,
        i = 0,
        found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== strundefined ? context.querySelectorAll(tag || "*") : undefined;

    if (!found) {
      for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {
        if (!tag || jQuery.nodeName(elem, tag)) {
          found.push(elem);
        } else {
          jQuery.merge(found, getAll(elem, tag));
        }
      }
    }

    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;
  } // Used in buildFragment, fixes the defaultChecked property


  function fixDefaultChecked(elem) {
    if (rcheckableType.test(elem.type)) {
      elem.defaultChecked = elem.checked;
    }
  } // Support: IE<8
  // Manipulating tables requires a tbody


  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
  } // Replace/restore the type attribute of script elements for safe DOM manipulation


  function disableScript(elem) {
    elem.type = (jQuery.find.attr(elem, "type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);

    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  } // Mark scripts as having already been evaluated


  function setGlobalEval(elems, refElements) {
    var elem,
        i = 0;

    for (; (elem = elems[i]) != null; i++) {
      jQuery._data(elem, "globalEval", !refElements || jQuery._data(refElements[i], "globalEval"));
    }
  }

  function cloneCopyEvent(src, dest) {
    if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
      return;
    }

    var type,
        i,
        l,
        oldData = jQuery._data(src),
        curData = jQuery._data(dest, oldData),
        events = oldData.events;

    if (events) {
      delete curData.handle;
      curData.events = {};

      for (type in events) {
        for (i = 0, l = events[type].length; i < l; i++) {
          jQuery.event.add(dest, type, events[type][i]);
        }
      }
    } // make the cloned public data object a copy from the original


    if (curData.data) {
      curData.data = jQuery.extend({}, curData.data);
    }
  }

  function fixCloneNodeIssues(src, dest) {
    var nodeName, e, data; // We do not need to do anything for non-Elements

    if (dest.nodeType !== 1) {
      return;
    }

    nodeName = dest.nodeName.toLowerCase(); // IE6-8 copies events bound via attachEvent when using cloneNode.

    if (!support.noCloneEvent && dest[jQuery.expando]) {
      data = jQuery._data(dest);

      for (e in data.events) {
        jQuery.removeEvent(dest, e, data.handle);
      } // Event data gets referenced instead of copied if the expando gets copied too


      dest.removeAttribute(jQuery.expando);
    } // IE blanks contents when cloning scripts, and tries to evaluate newly-set text


    if (nodeName === "script" && dest.text !== src.text) {
      disableScript(dest).text = src.text;
      restoreScript(dest); // IE6-10 improperly clones children of object elements using classid.
      // IE10 throws NoModificationAllowedError if parent is null, #12132.
    } else if (nodeName === "object") {
      if (dest.parentNode) {
        dest.outerHTML = src.outerHTML;
      } // This path appears unavoidable for IE9. When cloning an object
      // element in IE9, the outerHTML strategy above is not sufficient.
      // If the src has innerHTML and the destination does not,
      // copy the src.innerHTML into the dest.innerHTML. #10324


      if (support.html5Clone && src.innerHTML && !jQuery.trim(dest.innerHTML)) {
        dest.innerHTML = src.innerHTML;
      }
    } else if (nodeName === "input" && rcheckableType.test(src.type)) {
      // IE6-8 fails to persist the checked state of a cloned checkbox
      // or radio button. Worse, IE6-7 fail to give the cloned element
      // a checked appearance if the defaultChecked value isn't also set
      dest.defaultChecked = dest.checked = src.checked; // IE6-7 get confused and end up setting the value of a cloned
      // checkbox/radio button to an empty string instead of "on"

      if (dest.value !== src.value) {
        dest.value = src.value;
      } // IE6-8 fails to return the selected option to the default selected
      // state when cloning options

    } else if (nodeName === "option") {
      dest.defaultSelected = dest.selected = src.defaultSelected; // IE6-8 fails to set the defaultValue to the correct value when
      // cloning other types of input fields
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  jQuery.extend({
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var destElements,
          node,
          clone,
          i,
          srcElements,
          inPage = jQuery.contains(elem.ownerDocument, elem);

      if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) {
        clone = elem.cloneNode(true); // IE<=8 does not properly clone detached, unknown element nodes
      } else {
        fragmentDiv.innerHTML = elem.outerHTML;
        fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
      }

      if ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem); // Fix all IE cloning issues

        for (i = 0; (node = srcElements[i]) != null; ++i) {
          // Ensure that the destination node is not null; Fixes #9587
          if (destElements[i]) {
            fixCloneNodeIssues(node, destElements[i]);
          }
        }
      } // Copy the events from the original to the clone


      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0; (node = srcElements[i]) != null; i++) {
            cloneCopyEvent(node, destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      } // Preserve script evaluation history


      destElements = getAll(clone, "script");

      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }

      destElements = srcElements = node = null; // Return the cloned set

      return clone;
    },
    buildFragment: function (elems, context, scripts, selection) {
      var j,
          elem,
          contains,
          tmp,
          tag,
          tbody,
          wrap,
          l = elems.length,
          // Ensure a safe fragment
      safe = createSafeFragment(context),
          nodes = [],
          i = 0;

      for (; i < l; i++) {
        elem = elems[i];

        if (elem || elem === 0) {
          // Add nodes directly
          if (jQuery.type(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
          } else {
            tmp = tmp || safe.appendChild(context.createElement("div")); // Deserialize a standard representation

            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2]; // Descend through wrappers to the right content

            j = wrap[0];

            while (j--) {
              tmp = tmp.lastChild;
            } // Manually add leading whitespace removed by IE


            if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
              nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
            } // Remove IE's autoinserted <tbody> from table fragments


            if (!support.tbody) {
              // String was a <table>, *may* have spurious <tbody>
              elem = tag === "table" && !rtbody.test(elem) ? tmp.firstChild : // String was a bare <thead> or <tfoot>
              wrap[1] === "<table>" && !rtbody.test(elem) ? tmp : 0;
              j = elem && elem.childNodes.length;

              while (j--) {
                if (jQuery.nodeName(tbody = elem.childNodes[j], "tbody") && !tbody.childNodes.length) {
                  elem.removeChild(tbody);
                }
              }
            }

            jQuery.merge(nodes, tmp.childNodes); // Fix #12392 for WebKit and IE > 9

            tmp.textContent = ""; // Fix #12392 for oldIE

            while (tmp.firstChild) {
              tmp.removeChild(tmp.firstChild);
            } // Remember the top-level container for proper cleanup


            tmp = safe.lastChild;
          }
        }
      } // Fix #11356: Clear elements from fragment


      if (tmp) {
        safe.removeChild(tmp);
      } // Reset defaultChecked for any radios and checkboxes
      // about to be appended to the DOM in IE 6/7 (#8060)


      if (!support.appendChecked) {
        jQuery.grep(getAll(nodes, "input"), fixDefaultChecked);
      }

      i = 0;

      while (elem = nodes[i++]) {
        // #4087 - If origin and destination elements are the same, and this is
        // that element, do not do anything
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }

        contains = jQuery.contains(elem.ownerDocument, elem); // Append to fragment

        tmp = getAll(safe.appendChild(elem), "script"); // Preserve script evaluation history

        if (contains) {
          setGlobalEval(tmp);
        } // Capture executables


        if (scripts) {
          j = 0;

          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }

      tmp = null;
      return safe;
    },
    cleanData: function (elems,
    /* internal */
    acceptData) {
      var elem,
          type,
          id,
          data,
          i = 0,
          internalKey = jQuery.expando,
          cache = jQuery.cache,
          deleteExpando = support.deleteExpando,
          special = jQuery.event.special;

      for (; (elem = elems[i]) != null; i++) {
        if (acceptData || jQuery.acceptData(elem)) {
          id = elem[internalKey];
          data = id && cache[id];

          if (data) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            } // Remove cache only if it was not already removed by jQuery.event.remove


            if (cache[id]) {
              delete cache[id]; // IE does not allow us to delete expando properties from nodes,
              // nor does it have a removeAttribute function on Document nodes;
              // we must handle all of these cases

              if (deleteExpando) {
                delete elem[internalKey];
              } else if (typeof elem.removeAttribute !== strundefined) {
                elem.removeAttribute(internalKey);
              } else {
                elem[internalKey] = null;
              }

              deletedIds.push(id);
            }
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    text: function (value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
      }, null, value, arguments.length);
    },
    append: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function (selector, keepData
    /* Internal Use Only */
    ) {
      var elem,
          elems = selector ? jQuery.filter(selector, this) : this,
          i = 0;

      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }

        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, "script"));
          }

          elem.parentNode.removeChild(elem);
        }
      }

      return this;
    },
    empty: function () {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        // Remove element nodes and prevent memory leaks
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
        } // Remove any remaining nodes


        while (elem.firstChild) {
          elem.removeChild(elem.firstChild);
        } // If this is a select, ensure that it displays empty (#12336)
        // Support: IE<9


        if (elem.options && jQuery.nodeName(elem, "select")) {
          elem.options.length = 0;
        }
      }

      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return access(this, function (value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;

        if (value === undefined) {
          return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, "") : undefined;
        } // See if we can take a shortcut and just use innerHTML


        if (typeof value === "string" && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, "<$1></$2>");

          try {
            for (; i < l; i++) {
              // Remove element nodes and prevent memory leaks
              elem = this[i] || {};

              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }

            elem = 0; // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }

        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var arg = arguments[0]; // Make the changes, replacing each context element with the new content

      this.domManip(arguments, function (elem) {
        arg = this.parentNode;
        jQuery.cleanData(getAll(this));

        if (arg) {
          arg.replaceChild(elem, this);
        }
      }); // Force removal if there was no new content (e.g., from empty arguments)

      return arg && (arg.length || arg.nodeType) ? this : this.remove();
    },
    detach: function (selector) {
      return this.remove(selector, true);
    },
    domManip: function (args, callback) {
      // Flatten any nested arrays
      args = concat.apply([], args);
      var first,
          node,
          hasScripts,
          scripts,
          doc,
          fragment,
          i = 0,
          l = this.length,
          set = this,
          iNoClone = l - 1,
          value = args[0],
          isFunction = jQuery.isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

      if (isFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return this.each(function (index) {
          var self = set.eq(index);

          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }

          self.domManip(args, callback);
        });
      }

      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
        first = fragment.firstChild;

        if (fragment.childNodes.length === 1) {
          fragment = first;
        }

        if (first) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length; // Use the original fragment for the last item instead of the first because it can end up
          // being emptied incorrectly in certain situations (#8070).

          for (; i < l; i++) {
            node = fragment;

            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }

            callback.call(this[i], node, i);
          }

          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

            jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];

              if (rscriptType.test(node.type || "") && !jQuery._data(node, "globalEval") && jQuery.contains(doc, node)) {
                if (node.src) {
                  // Optional AJAX dependency, but won't run scripts if not present
                  if (jQuery._evalUrl) {
                    jQuery._evalUrl(node.src);
                  }
                } else {
                  jQuery.globalEval((node.text || node.textContent || node.innerHTML || "").replace(rcleanScript, ""));
                }
              }
            }
          } // Fix #11809: Avoid leaking memory


          fragment = first = null;
        }
      }

      return this;
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
          i = 0,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1;

      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems); // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()

        push.apply(ret, elems.get());
      }

      return this.pushStack(ret);
    };
  });
  var iframe,
      elemdisplay = {};
  /**
   * Retrieve the actual display of a element
   * @param {String} name nodeName of the element
   * @param {Object} doc Document object
   */
  // Called only from within defaultDisplay

  function actualDisplay(name, doc) {
    var style,
        elem = jQuery(doc.createElement(name)).appendTo(doc.body),
        // getDefaultComputedStyle might be reliably used only on attached element
    display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? // Use of this method is a temporary fix (more like optmization) until something better comes along,
    // since it was removed from specification and supported only in FF
    style.display : jQuery.css(elem[0], "display"); // We don't have any data stored on the element,
    // so use "detach" method as fast way to get rid of the element

    elem.detach();
    return display;
  }
  /**
   * Try to determine the default display value of an element
   * @param {String} nodeName
   */


  function defaultDisplay(nodeName) {
    var doc = document,
        display = elemdisplay[nodeName];

    if (!display) {
      display = actualDisplay(nodeName, doc); // If the simple way fails, read from inside an iframe

      if (display === "none" || !display) {
        // Use the already-created iframe if possible
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement); // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse

        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document; // Support: IE

        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      } // Store the correct default display


      elemdisplay[nodeName] = display;
    }

    return display;
  }

  (function () {
    var shrinkWrapBlocksVal;

    support.shrinkWrapBlocks = function () {
      if (shrinkWrapBlocksVal != null) {
        return shrinkWrapBlocksVal;
      } // Will be changed later if needed.


      shrinkWrapBlocksVal = false; // Minified: var b,c,d

      var div, body, container;
      body = document.getElementsByTagName("body")[0];

      if (!body || !body.style) {
        // Test fired too early or in an unsupported environment, exit.
        return;
      } // Setup


      div = document.createElement("div");
      container = document.createElement("div");
      container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
      body.appendChild(container).appendChild(div); // Support: IE6
      // Check if elements with layout shrink-wrap their children

      if (typeof div.style.zoom !== strundefined) {
        // Reset CSS: box-sizing; display; margin; border
        div.style.cssText = // Support: Firefox<29, Android 2.3
        // Vendor-prefix box-sizing
        "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;" + "padding:1px;width:1px;zoom:1";
        div.appendChild(document.createElement("div")).style.width = "5px";
        shrinkWrapBlocksVal = div.offsetWidth !== 3;
      }

      body.removeChild(container);
      return shrinkWrapBlocksVal;
    };
  })();

  var rmargin = /^margin/;
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles,
      curCSS,
      rposition = /^(top|right|bottom|left)$/;

  if (window.getComputedStyle) {
    getStyles = function (elem) {
      // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
      // IE throws on elements created in popups
      // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
      if (elem.ownerDocument.defaultView.opener) {
        return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
      }

      return window.getComputedStyle(elem, null);
    };

    curCSS = function (elem, name, computed) {
      var width,
          minWidth,
          maxWidth,
          ret,
          style = elem.style;
      computed = computed || getStyles(elem); // getPropertyValue is only needed for .css('filter') in IE9, see #12537

      ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

      if (computed) {
        if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
          ret = jQuery.style(elem, name);
        } // A tribute to the "awesome hack by Dean Edwards"
        // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
        // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
        // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values


        if (rnumnonpx.test(ret) && rmargin.test(name)) {
          // Remember the original values
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth; // Put in the new values to get a computed value out

          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width; // Revert the changed values

          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      } // Support: IE
      // IE returns zIndex value as an integer.


      return ret === undefined ? ret : ret + "";
    };
  } else if (document.documentElement.currentStyle) {
    getStyles = function (elem) {
      return elem.currentStyle;
    };

    curCSS = function (elem, name, computed) {
      var left,
          rs,
          rsLeft,
          ret,
          style = elem.style;
      computed = computed || getStyles(elem);
      ret = computed ? computed[name] : undefined; // Avoid setting ret to empty string here
      // so we don't default to auto

      if (ret == null && style && style[name]) {
        ret = style[name];
      } // From the awesome hack by Dean Edwards
      // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
      // If we're not dealing with a regular pixel number
      // but a number that has a weird ending, we need to convert it to pixels
      // but not position css attributes, as those are proportional to the parent element instead
      // and we can't measure the parent instead because it might trigger a "stacking dolls" problem


      if (rnumnonpx.test(ret) && !rposition.test(name)) {
        // Remember the original values
        left = style.left;
        rs = elem.runtimeStyle;
        rsLeft = rs && rs.left; // Put in the new values to get a computed value out

        if (rsLeft) {
          rs.left = elem.currentStyle.left;
        }

        style.left = name === "fontSize" ? "1em" : ret;
        ret = style.pixelLeft + "px"; // Revert the changed values

        style.left = left;

        if (rsLeft) {
          rs.left = rsLeft;
        }
      } // Support: IE
      // IE returns zIndex value as an integer.


      return ret === undefined ? ret : ret + "" || "auto";
    };
  }

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function () {
        var condition = conditionFn();

        if (condition == null) {
          // The test was not ready at this point; screw the hook this time
          // but check again when needed next time.
          return;
        }

        if (condition) {
          // Hook not needed (or it's not possible to use it due to missing dependency),
          // remove it.
          // Since there are no other hooks for marginRight, remove the whole object.
          delete this.get;
          return;
        } // Hook needed; redefine it so that the support test is not executed again.


        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }

  (function () {
    // Minified: var b,c,d,e,f,g, h,i
    var div, style, a, pixelPositionVal, boxSizingReliableVal, reliableHiddenOffsetsVal, reliableMarginRightVal; // Setup

    div = document.createElement("div");
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName("a")[0];
    style = a && a.style; // Finish early in limited (non-browser) environments

    if (!style) {
      return;
    }

    style.cssText = "float:left;opacity:.5"; // Support: IE<9
    // Make sure that element opacity exists (as opposed to filter)

    support.opacity = style.opacity === "0.5"; // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)

    support.cssFloat = !!style.cssFloat;
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box"; // Support: Firefox<29, Android 2.3
    // Vendor-prefix box-sizing

    support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" || style.WebkitBoxSizing === "";
    jQuery.extend(support, {
      reliableHiddenOffsets: function () {
        if (reliableHiddenOffsetsVal == null) {
          computeStyleTests();
        }

        return reliableHiddenOffsetsVal;
      },
      boxSizingReliable: function () {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }

        return boxSizingReliableVal;
      },
      pixelPosition: function () {
        if (pixelPositionVal == null) {
          computeStyleTests();
        }

        return pixelPositionVal;
      },
      // Support: Android 2.3
      reliableMarginRight: function () {
        if (reliableMarginRightVal == null) {
          computeStyleTests();
        }

        return reliableMarginRightVal;
      }
    });

    function computeStyleTests() {
      // Minified: var b,c,d,j
      var div, body, container, contents;
      body = document.getElementsByTagName("body")[0];

      if (!body || !body.style) {
        // Test fired too early or in an unsupported environment, exit.
        return;
      } // Setup


      div = document.createElement("div");
      container = document.createElement("div");
      container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
      body.appendChild(container).appendChild(div);
      div.style.cssText = // Support: Firefox<29, Android 2.3
      // Vendor-prefix box-sizing
      "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute"; // Support: IE<9
      // Assume reasonable values in the absence of getComputedStyle

      pixelPositionVal = boxSizingReliableVal = false;
      reliableMarginRightVal = true; // Check for getComputedStyle so that this code is not run in IE<9.

      if (window.getComputedStyle) {
        pixelPositionVal = (window.getComputedStyle(div, null) || {}).top !== "1%";
        boxSizingReliableVal = (window.getComputedStyle(div, null) || {
          width: "4px"
        }).width === "4px"; // Support: Android 2.3
        // Div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container (#3333)
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right

        contents = div.appendChild(document.createElement("div")); // Reset CSS: box-sizing; display; margin; border; padding

        contents.style.cssText = div.style.cssText = // Support: Firefox<29, Android 2.3
        // Vendor-prefix box-sizing
        "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
        contents.style.marginRight = contents.style.width = "0";
        div.style.width = "1px";
        reliableMarginRightVal = !parseFloat((window.getComputedStyle(contents, null) || {}).marginRight);
        div.removeChild(contents);
      } // Support: IE8
      // Check if table cells still have offsetWidth/Height when they are set
      // to display:none and there are still other visible table cells in a
      // table row; if so, offsetWidth/Height are not reliable for use when
      // determining if an element has been hidden directly using
      // display:none (it is still safe to use offsets if a parent element is
      // hidden; don safety goggles and see bug #4512 for more information).


      div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
      contents = div.getElementsByTagName("td");
      contents[0].style.cssText = "margin:0;border:0;padding:0;display:none";
      reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;

      if (reliableHiddenOffsetsVal) {
        contents[0].style.display = "";
        contents[1].style.display = "none";
        reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
      }

      body.removeChild(container);
    }
  })(); // A method for quickly swapping in/out CSS properties to get correct calculations.


  jQuery.swap = function (elem, options, callback, args) {
    var ret,
        name,
        old = {}; // Remember the old values, and insert the new ones

    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.apply(elem, args || []); // Revert the old values

    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };

  var ralpha = /alpha\([^)]*\)/i,
      ropacity = /opacity\s*=\s*([^)]*)/,
      // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
  // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
      rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
      cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  },
      cssPrefixes = ["Webkit", "O", "Moz", "ms"]; // return a css property mapped to a potentially vendor prefixed property

  function vendorPropName(style, name) {
    // shortcut for names that are not vendor prefixed
    if (name in style) {
      return name;
    } // check for vendor prefixed names


    var capName = name.charAt(0).toUpperCase() + name.slice(1),
        origName = name,
        i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;

      if (name in style) {
        return name;
      }
    }

    return origName;
  }

  function showHide(elements, show) {
    var display,
        elem,
        hidden,
        values = [],
        index = 0,
        length = elements.length;

    for (; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      values[index] = jQuery._data(elem, "olddisplay");
      display = elem.style.display;

      if (show) {
        // Reset the inline display of this element to learn if it is
        // being hidden by cascaded rules or not
        if (!values[index] && display === "none") {
          elem.style.display = "";
        } // Set elements which have been overridden with display: none
        // in a stylesheet to whatever the default browser style is
        // for such an element


        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = jQuery._data(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);

        if (display && display !== "none" || !hidden) {
          jQuery._data(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    } // Set the display of most of the elements in a second loop
    // to avoid the constant reflow


    for (index = 0; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }

    return elements;
  }

  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
  }

  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ? // If we already have the right measurement, avoid augmentation
    4 : // Otherwise initialize for horizontal or vertical properties
    name === "width" ? 1 : 0,
        val = 0;

    for (; i < 4; i += 2) {
      // both box models exclude margin, so add it if we want it
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }

      if (isBorderBox) {
        // border-box includes padding, so remove it if we want content
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        } // at this point, extra isn't border nor margin, so remove border


        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        // at this point, extra isn't content, so add padding
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // at this point, extra isn't content nor padding, so add border

        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }

    return val;
  }

  function getWidthOrHeight(elem, name, extra) {
    // Start with offset property, which is equivalent to the border-box value
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles(elem),
        isBorderBox = support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668

    if (val <= 0 || val == null) {
      // Fall back to computed then uncomputed css if necessary
      val = curCSS(elem, name, styles);

      if (val < 0 || val == null) {
        val = elem.style[name];
      } // Computed unit is not pixels. Stop here and return.


      if (rnumnonpx.test(val)) {
        return val;
      } // we need the check for style in case a browser which returns unreliable values
      // for getComputedStyle silently falls back to the reliable elem.style


      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]); // Normalize "", auto, and prepare for extra

      val = parseFloat(val) || 0;
    } // use the active box-sizing model to add/subtract irrelevant styles


    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {
      // normalize float css property
      "float": support.cssFloat ? "cssFloat" : "styleFloat"
    },
    // Get and set the style property on a DOM Node
    style: function (elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      } // Make sure that we're working with the right name


      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName)); // gets hook for the prefixed version
      // followed by the unprefixed version

      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

      if (value !== undefined) {
        type = typeof value; // convert relative number strings (+= or -=) to relative numbers. #7345

        if (type === "string" && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name)); // Fixes bug #9237

          type = "number";
        } // Make sure that null and NaN values aren't set. See: #7116


        if (value == null || value !== value) {
          return;
        } // If a number was passed in, add 'px' to the (except for certain CSS properties)


        if (type === "number" && !jQuery.cssNumber[origName]) {
          value += "px";
        } // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
        // but it would mean to define eight (for every problematic property) identical functions


        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        } // If a hook was provided, use that value, otherwise just set the specified value


        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          // Support: IE
          // Swallow errors from 'invalid' CSS values (#5509)
          try {
            style[name] = value;
          } catch (e) {}
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        } // Otherwise just get the value from the style object


        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var num,
          val,
          hooks,
          origName = jQuery.camelCase(name); // Make sure that we're working with the right name

      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName)); // gets hook for the prefixed version
      // followed by the unprefixed version

      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      } // Otherwise, if a way to get the computed value exists, use that


      if (val === undefined) {
        val = curCSS(elem, name, styles);
      } //convert "normal" to computed value


      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      } // Return, converting to number if forced or a qualifier was provided and val looks numeric


      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }

      return val;
    }
  });
  jQuery.each(["height", "width"], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function (elem, computed, extra) {
        if (computed) {
          // certain elements can have dimension info if we invisibly show them
          // however, it must have a current display style that would benefit from this
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function (elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing && jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
      }
    };
  });

  if (!support.opacity) {
    jQuery.cssHooks.opacity = {
      get: function (elem, computed) {
        // IE uses filters for opacity
        return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ? 0.01 * parseFloat(RegExp.$1) + "" : computed ? "1" : "";
      },
      set: function (elem, value) {
        var style = elem.style,
            currentStyle = elem.currentStyle,
            opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
            filter = currentStyle && currentStyle.filter || style.filter || ""; // IE has trouble with opacity if it does not have layout
        // Force it by setting the zoom level

        style.zoom = 1; // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
        // if value === "", then remove inline opacity #12685

        if ((value >= 1 || value === "") && jQuery.trim(filter.replace(ralpha, "")) === "" && style.removeAttribute) {
          // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
          // if "filter:" is present at all, clearType is disabled, we want to avoid this
          // style.removeAttribute is IE Only, but so apparently is this code path...
          style.removeAttribute("filter"); // if there is no filter style applied in a css rule or unset inline opacity, we are done

          if (value === "" || currentStyle && !currentStyle.filter) {
            return;
          }
        } // otherwise, set new filter values


        style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + " " + opacity;
      }
    };
  }

  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
    if (computed) {
      // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
      // Work around by temporarily setting element display to inline-block
      return jQuery.swap(elem, {
        "display": "inline-block"
      }, curCSS, [elem, "marginRight"]);
    }
  }); // These hooks are used by animate to expand properties

  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0,
            expanded = {},
            // assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value];

        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function (name, value) {
      return access(this, function (elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;

        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;

          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }

          return map;
        }

        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function () {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }

  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || "swing";
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }

      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }

      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result;

        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        } // passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails
        // so, simple values such as "10px" are parsed to Float.
        // complex values such as "rotate(1rad)" are returned as is.


        result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

        return !result || result === "auto" ? 0 : result;
      },
      set: function (tween) {
        // use step hook for back compat - use cssHook if its there - use .style if its
        // available and use plain properties where available
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  }; // Support: IE <=9
  // Panic based approach to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.fx = Tween.prototype.init; // Back Compat <1.8 extension point

  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
      rrun = /queueHooks$/,
      animationPrefilters = [defaultPrefilter],
      tweeners = {
    "*": [function (prop, value) {
      var tween = this.createTween(prop, value),
          target = tween.cur(),
          parts = rfxnum.exec(value),
          unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
          // Starting value computation is required for potential unit mismatches
      start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
          scale = 1,
          maxIterations = 20;

      if (start && start[3] !== unit) {
        // Trust units reported by jQuery.css
        unit = unit || start[3]; // Make sure we update the tween properties later on

        parts = parts || []; // Iteratively approximate from a nonzero starting point

        start = +target || 1;

        do {
          // If previous iteration zeroed out, double until we get *something*
          // Use a string for doubling factor so we don't accidentally see scale as unchanged below
          scale = scale || ".5"; // Adjust and apply

          start = start / scale;
          jQuery.style(tween.elem, prop, start + unit); // Update scale, tolerating zero or NaN from tween.cur()
          // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
        } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
      } // Update tween properties


      if (parts) {
        start = tween.start = +start || +target || 0;
        tween.unit = unit; // If a +=/-= token was provided, we're doing a relative animation

        tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
      }

      return tween;
    }]
  }; // Animations created synchronously will run synchronously

  function createFxNow() {
    setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = jQuery.now();
  } // Generate parameters to create a standard animation


  function genFx(type, includeWidth) {
    var which,
        attrs = {
      height: type
    },
        i = 0; // if we include width, step value is 1 to do all cssExpand values,
    // if we don't include width, step value is 2 to skip over Left and Right

    includeWidth = includeWidth ? 1 : 0;

    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
        collection = (tweeners[prop] || []).concat(tweeners["*"]),
        index = 0,
        length = collection.length;

    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // we're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    /* jshint validthis: true */
    var prop,
        value,
        toggle,
        tween,
        hooks,
        oldfire,
        display,
        checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden(elem),
        dataShow = jQuery._data(elem, "fxshow"); // handle queue: false promises


    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");

      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;

        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }

      hooks.unqueued++;
      anim.always(function () {
        // doing this makes sure that the complete handler will be called
        // before this completes
        anim.always(function () {
          hooks.unqueued--;

          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    } // height/width overflow pass


    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      // Make sure that nothing sneaks out
      // Record all 3 overflow attributes because IE does not
      // change the overflow attribute when overflowX and
      // overflowY are set to the same value
      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Set display property to inline-block for height/width
      // animations on inline elements that are having width/height animated

      display = jQuery.css(elem, "display"); // Test default display if display is currently "none"

      checkDisplay = display === "none" ? jQuery._data(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        // inline-level elements accept inline-block;
        // block-level elements need to be inline with layout
        if (!support.inlineBlockNeedsLayout || defaultDisplay(elem.nodeName) === "inline") {
          style.display = "inline-block";
        } else {
          style.zoom = 1;
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";

      if (!support.shrinkWrapBlocks()) {
        anim.always(function () {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
    } // show/hide pass


    for (prop in props) {
      value = props[prop];

      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";

        if (value === (hidden ? "hide" : "show")) {
          // If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }

        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop); // Any non-fx value stops us from restoring the original display value
      } else {
        display = undefined;
      }
    }

    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = jQuery._data(elem, "fxshow", {});
      } // store state if its toggle - enables .stop().toggle() to "reverse"


      if (toggle) {
        dataShow.hidden = !hidden;
      }

      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }

      anim.done(function () {
        var prop;

        jQuery._removeData(elem, "fxshow");

        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });

      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;

          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      } // If this is a noop like .hide().hide(), restore an overwritten display value

    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];

      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];

      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name]; // not quite $.extend, this wont overwrite keys already present.
        // also - reusing 'index' from above because we have the correct "name"

        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = animationPrefilters.length,
        deferred = jQuery.Deferred().always(function () {
      // don't match elem in the :animated selector
      delete tick.elem;
    }),
        tick = function () {
      if (stopped) {
        return false;
      }

      var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
      temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }

      deferred.notifyWith(elem, [animation, percent, remaining]);

      if (percent < 1 && length) {
        return remaining;
      } else {
        deferred.resolveWith(elem, [animation]);
        return false;
      }
    },
        animation = deferred.promise({
      elem: elem,
      props: jQuery.extend({}, properties),
      opts: jQuery.extend(true, {
        specialEasing: {}
      }, options),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function (prop, end) {
        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
        animation.tweens.push(tween);
        return tween;
      },
      stop: function (gotoEnd) {
        var index = 0,
            // if we are going to the end, we want to run all the tweens
        // otherwise we skip this part
        length = gotoEnd ? animation.tweens.length : 0;

        if (stopped) {
          return this;
        }

        stopped = true;

        for (; index < length; index++) {
          animation.tweens[index].run(1);
        } // resolve when we played the last frame
        // otherwise, reject


        if (gotoEnd) {
          deferred.resolveWith(elem, [animation, gotoEnd]);
        } else {
          deferred.rejectWith(elem, [animation, gotoEnd]);
        }

        return this;
      }
    }),
        props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);

      if (result) {
        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }

    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    })); // attach callbacks from options

    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function (props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.split(" ");
      }

      var prop,
          index = 0,
          length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function (callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default; // normalize opt.queue - true/undefined/null -> "fx"

    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    } // Queueing


    opt.old = opt.complete;

    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      // show any hidden elements after setting opacity to 0
      return this.filter(isHidden).css("opacity", 0).show() // animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function () {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

        if (empty || jQuery._data(this, "finish")) {
          anim.stop(true);
        }
      };

      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }

      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = jQuery._data(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        } // start the next in the queue if the last step wasn't forced
        // timers currently will call their complete callbacks, which will dequeue
        // but only if they were gotoEnd


        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || "fx";
      }

      return this.each(function () {
        var index,
            data = jQuery._data(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0; // enable finishing flag on private data


        data.finish = true; // empty the queue first

        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        } // look for any active animations, and finish them


        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        } // look for any animations in the old queue and finish them


        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        } // turn off finishing flag


        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function (i, name) {
    var cssFn = jQuery.fn[name];

    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  }); // Generate shortcuts for custom animations

  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];

  jQuery.fx.tick = function () {
    var timer,
        timers = jQuery.timers,
        i = 0;
    fxNow = jQuery.now();

    for (; i < timers.length; i++) {
      timer = timers[i]; // Checks the timer has not already been removed

      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }

    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);

    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function () {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };

  jQuery.fx.stop = function () {
    clearInterval(timerId);
    timerId = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  }; // Based off of the plugin by Clint Helfers, with permission.
  // http://blindsignals.com/index.php/2009/07/jquery-delay/

  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = setTimeout(next, time);

      hooks.stop = function () {
        clearTimeout(timeout);
      };
    });
  };

  (function () {
    // Minified: var a,b,c,d,e
    var input, div, select, a, opt; // Setup

    div = document.createElement("div");
    div.setAttribute("className", "t");
    div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
    a = div.getElementsByTagName("a")[0]; // First batch of tests.

    select = document.createElement("select");
    opt = select.appendChild(document.createElement("option"));
    input = div.getElementsByTagName("input")[0];
    a.style.cssText = "top:1px"; // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)

    support.getSetAttribute = div.className !== "t"; // Get the style information from getAttribute
    // (IE uses .cssText instead)

    support.style = /top/.test(a.getAttribute("style")); // Make sure that URLs aren't manipulated
    // (IE normalizes it by default)

    support.hrefNormalized = a.getAttribute("href") === "/a"; // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)

    support.checkOn = !!input.value; // Make sure that a selected-by-default option has a working selected property.
    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)

    support.optSelected = opt.selected; // Tests for enctype support on a form (#6743)

    support.enctype = !!document.createElement("form").enctype; // Make sure that the options inside disabled selects aren't marked as disabled
    // (WebKit marks them as disabled)

    select.disabled = true;
    support.optDisabled = !opt.disabled; // Support: IE8 only
    // Check if we can trust getAttribute("value")

    input = document.createElement("input");
    input.setAttribute("value", "");
    support.input = input.getAttribute("value") === ""; // Check if an input maintains its value after becoming a radio

    input.value = "t";
    input.setAttribute("type", "radio");
    support.radioValue = input.value === "t";
  })();

  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function (value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value;
          return typeof ret === "string" ? // handle most common string cases
          ret.replace(rreturn, "") : // handle cases where value is null/undef or number
          ret == null ? "" : ret;
        }

        return;
      }

      isFunction = jQuery.isFunction(value);
      return this.each(function (i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        } // Treat null/undefined as ""; convert numbers to string


        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : // Support: IE10-11+
          // option.text throws exceptions (#14686, #14858)
          jQuery.trim(jQuery.text(elem));
        }
      },
      select: {
        get: function (elem) {
          var value,
              option,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one" || index < 0,
              values = one ? null : [],
              max = one ? index + 1 : options.length,
              i = index < 0 ? max : one ? index : 0; // Loop through all the selected options

          for (; i < max; i++) {
            option = options[i]; // oldIE doesn't update selected after form reset (#2551)

            if ((option.selected || i === index) && ( // Don't return options that are disabled or in a disabled optgroup
            support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val(); // We don't need an array for one selects

              if (one) {
                return value;
              } // Multi-Selects return an array


              values.push(value);
            }
          }

          return values;
        },
        set: function (elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;

          while (i--) {
            option = options[i];

            if (jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) {
              // Support: IE6
              // When new option element is added to select box we need to
              // force reflow of newly added node in order to workaround delay
              // of initialization properties
              try {
                option.selected = optionSet = true;
              } catch (_) {
                // Will be executed only in IE6
                option.scrollHeight;
              }
            } else {
              option.selected = false;
            }
          } // Force browsers to behave consistently when non-matching value is set


          if (!optionSet) {
            elem.selectedIndex = -1;
          }

          return options;
        }
      }
    }
  }); // Radios and checkboxes getter/setter

  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (jQuery.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
        }
      }
    };

    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        // Support: Webkit
        // "" is returned instead of "on" if a value isn't specified
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  var nodeHook,
      boolHook,
      attrHandle = jQuery.expr.attrHandle,
      ruseDefault = /^(?:checked|selected)$/i,
      getSetAttribute = support.getSetAttribute,
      getSetInput = support.input;
  jQuery.fn.extend({
    attr: function (name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function (elem, name, value) {
      var hooks,
          ret,
          nType = elem.nodeType; // don't get/set attributes on text, comment and attribute nodes

      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      } // Fallback to prop when attributes are not supported


      if (typeof elem.getAttribute === strundefined) {
        return jQuery.prop(elem, name, value);
      } // All attributes are lowercase
      // Grab necessary hook if one is defined


      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + "");
          return value;
        }
      } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function (elem, value) {
      var name,
          propName,
          i = 0,
          attrNames = value && value.match(rnotwhite);

      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          propName = jQuery.propFix[name] || name; // Boolean attributes get special treatment (#10870)

          if (jQuery.expr.match.bool.test(name)) {
            // Set corresponding property to false
            if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
              elem[propName] = false; // Support: IE<9
              // Also clear defaultChecked/defaultSelected (if appropriate)
            } else {
              elem[jQuery.camelCase("default-" + name)] = elem[propName] = false;
            } // See #9699 for explanation of this approach (setting first, then removal)

          } else {
            jQuery.attr(elem, name, "");
          }

          elem.removeAttribute(getSetAttribute ? name : propName);
        }
      }
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            // Setting the type on a radio button after the value resets the value in IE6-9
            // Reset value to default in case type is set after value during creation
            var val = elem.value;
            elem.setAttribute("type", value);

            if (val) {
              elem.value = val;
            }

            return value;
          }
        }
      }
    }
  }); // Hook for boolean attributes

  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
        // IE<8 needs the *property* name
        elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name); // Use defaultChecked and defaultSelected for oldIE
      } else {
        elem[jQuery.camelCase("default-" + name)] = elem[name] = true;
      }

      return name;
    }
  }; // Retrieve booleans specially

  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function (elem, name, isXML) {
      var ret, handle;

      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }

      return ret;
    } : function (elem, name, isXML) {
      if (!isXML) {
        return elem[jQuery.camelCase("default-" + name)] ? name.toLowerCase() : null;
      }
    };
  }); // fix oldIE attroperties

  if (!getSetInput || !getSetAttribute) {
    jQuery.attrHooks.value = {
      set: function (elem, value, name) {
        if (jQuery.nodeName(elem, "input")) {
          // Does not return so that setAttribute is also used
          elem.defaultValue = value;
        } else {
          // Use nodeHook if defined (#1954); otherwise setAttribute is fine
          return nodeHook && nodeHook.set(elem, value, name);
        }
      }
    };
  } // IE6/7 do not support getting/setting some attributes with get/setAttribute


  if (!getSetAttribute) {
    // Use this for any attribute in IE6/7
    // This fixes almost every IE6/7 issue
    nodeHook = {
      set: function (elem, value, name) {
        // Set the existing or create a new attribute node
        var ret = elem.getAttributeNode(name);

        if (!ret) {
          elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));
        }

        ret.value = value += ""; // Break association with cloned elements by also using setAttribute (#9646)

        if (name === "value" || value === elem.getAttribute(name)) {
          return value;
        }
      }
    }; // Some attributes are constructed with empty-string values when not defined

    attrHandle.id = attrHandle.name = attrHandle.coords = function (elem, name, isXML) {
      var ret;

      if (!isXML) {
        return (ret = elem.getAttributeNode(name)) && ret.value !== "" ? ret.value : null;
      }
    }; // Fixing value retrieval on a button requires this module


    jQuery.valHooks.button = {
      get: function (elem, name) {
        var ret = elem.getAttributeNode(name);

        if (ret && ret.specified) {
          return ret.value;
        }
      },
      set: nodeHook.set
    }; // Set contenteditable to false on removals(#10429)
    // Setting to empty string throws an error as an invalid value

    jQuery.attrHooks.contenteditable = {
      set: function (elem, value, name) {
        nodeHook.set(elem, value === "" ? false : value, name);
      }
    }; // Set width and height to auto instead of 0 on empty string( Bug #8150 )
    // This is for removals

    jQuery.each(["width", "height"], function (i, name) {
      jQuery.attrHooks[name] = {
        set: function (elem, value) {
          if (value === "") {
            elem.setAttribute(name, "auto");
            return value;
          }
        }
      };
    });
  }

  if (!support.style) {
    jQuery.attrHooks.style = {
      get: function (elem) {
        // Return undefined in the case of empty string
        // Note: IE uppercases css property names, but if we were to .toLowerCase()
        // .cssText, that would destroy case senstitivity in URL's, like in "background"
        return elem.style.cssText || undefined;
      },
      set: function (elem, value) {
        return elem.style.cssText = value + "";
      }
    };
  }

  var rfocusable = /^(?:input|select|textarea|button|object)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function (name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      name = jQuery.propFix[name] || name;
      return this.each(function () {
        // try/catch handles cases where IE balks (such as removing a property on window)
        try {
          this[name] = undefined;
          delete this[name];
        } catch (e) {}
      });
    }
  });
  jQuery.extend({
    propFix: {
      "for": "htmlFor",
      "class": "className"
    },
    prop: function (elem, name, value) {
      var ret,
          hooks,
          notxml,
          nType = elem.nodeType; // don't get/set properties on text, comment and attribute nodes

      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

      if (notxml) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
      } else {
        return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
          // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");
          return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
        }
      }
    }
  }); // Some attributes require a special call on IE
  // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

  if (!support.hrefNormalized) {
    // href/src property should get the full normalized URL (#10299/#12915)
    jQuery.each(["href", "src"], function (i, name) {
      jQuery.propHooks[name] = {
        get: function (elem) {
          return elem.getAttribute(name, 4);
        }
      };
    });
  } // Support: Safari, IE9+
  // mis-reports the default selected property of an option
  // Accessing the parent's selectedIndex property fixes it


  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex; // Make sure that it also works with optgroups, see #5701

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }

        return null;
      }
    };
  }

  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  }); // IE6/7 call enctype encoding

  if (!support.enctype) {
    jQuery.propFix.enctype = "encoding";
  }

  var rclass = /[\t\r\n\f]/g;
  jQuery.fn.extend({
    addClass: function (value) {
      var classes,
          elem,
          cur,
          clazz,
          j,
          finalValue,
          i = 0,
          len = this.length,
          proceed = typeof value === "string" && value;

      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }

      if (proceed) {
        // The disjunction here is for better compressibility (see removeClass)
        classes = (value || "").match(rnotwhite) || [];

        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            } // only assign if different to avoid unneeded rendering.


            finalValue = jQuery.trim(cur);

            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }

      return this;
    },
    removeClass: function (value) {
      var classes,
          elem,
          cur,
          clazz,
          j,
          finalValue,
          i = 0,
          len = this.length,
          proceed = arguments.length === 0 || typeof value === "string" && value;

      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }

      if (proceed) {
        classes = (value || "").match(rnotwhite) || [];

        for (; i < len; i++) {
          elem = this[i]; // This expression is here for better compressibility (see addClass)

          cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") >= 0) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            } // only assign if different to avoid unneeded rendering.


            finalValue = value ? jQuery.trim(cur) : "";

            if (elem.className !== finalValue) {
              elem.className = finalValue;
            }
          }
        }
      }

      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value;

      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }

      return this.each(function () {
        if (type === "string") {
          // toggle individual class names
          var className,
              i = 0,
              self = jQuery(this),
              classNames = value.match(rnotwhite) || [];

          while (className = classNames[i++]) {
            // check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          } // Toggle whole class name

        } else if (type === strundefined || type === "boolean") {
          if (this.className) {
            // store className if set
            jQuery._data(this, "__className__", this.className);
          } // If the element has a class name or if we're passed "false",
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.


          this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
        }
      });
    },
    hasClass: function (selector) {
      var className = " " + selector + " ",
          i = 0,
          l = this.length;

      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
          return true;
        }
      }

      return false;
    }
  }); // Return jQuery for attributes-only inclusion

  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function (i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    }
  });
  var nonce = jQuery.now();
  var rquery = /\?/;
  var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

  jQuery.parseJSON = function (data) {
    // Attempt to parse using the native JSON parser first
    if (window.JSON && window.JSON.parse) {
      // Support: Android 2.3
      // Workaround failure to string-cast null input
      return window.JSON.parse(data + "");
    }

    var requireNonComma,
        depth = null,
        str = jQuery.trim(data + ""); // Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
    // after removing valid tokens

    return str && !jQuery.trim(str.replace(rvalidtokens, function (token, comma, open, close) {
      // Force termination if we see a misplaced comma
      if (requireNonComma && comma) {
        depth = 0;
      } // Perform no more replacements after returning to outermost depth


      if (depth === 0) {
        return token;
      } // Commas must not follow "[", "{", or ","


      requireNonComma = open || comma; // Determine new depth
      // array/object open ("[" or "{"): depth += true - false (increment)
      // array/object close ("]" or "}"): depth += false - true (decrement)
      // other cases ("," or primitive): depth += true - true (numeric cast)

      depth += !close - !open; // Remove this token

      return "";
    })) ? Function("return " + str)() : jQuery.error("Invalid JSON: " + data);
  }; // Cross-browser xml parsing


  jQuery.parseXML = function (data) {
    var xml, tmp;

    if (!data || typeof data !== "string") {
      return null;
    }

    try {
      if (window.DOMParser) {
        // Standard
        tmp = new DOMParser();
        xml = tmp.parseFromString(data, "text/xml");
      } else {
        // IE
        xml = new ActiveXObject("Microsoft.XMLDOM");
        xml.async = "false";
        xml.loadXML(data);
      }
    } catch (e) {
      xml = undefined;
    }

    if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }

    return xml;
  };

  var // Document location
  ajaxLocParts,
      ajaxLocation,
      rhash = /#.*$/,
      rts = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,
      // IE leaves an \r character at EOL
  // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},
      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat("*"); // #8138, IE may throw an exception when accessing
  // a field from window.location if document.domain has been set

  try {
    ajaxLocation = location.href;
  } catch (e) {
    // Use the href attribute of an A element
    // since IE will modify it given document.location
    ajaxLocation = document.createElement("a");
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
  } // Segment location into parts


  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

      if (jQuery.isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType.charAt(0) === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  } // Base inspection function for prefilters and transports


  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  } // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887


  function ajaxExtend(target, src) {
    var deep,
        key,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }

    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */


  function ajaxHandleResponses(s, jqXHR, responses) {
    var firstDataType,
        ct,
        finalDataType,
        type,
        contents = s.contents,
        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

    while (dataTypes[0] === "*") {
      dataTypes.shift();

      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    } // Check if we're dealing with a known content-type


    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    } // Check to see if we have a response for the expected dataType


    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }

        if (!firstDataType) {
          firstDataType = type;
        }
      } // Or just use first one


      finalDataType = finalDataType || firstDataType;
    } // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response


    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }

      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */


  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift(); // Convert to each sequential dataType

    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      } // Apply the dataFilter if provided


      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev; // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");

              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }

                  break;
                }
              }
            }
          } // Apply converter (if not an equivalence)


          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s["throws"]) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }

    return {
      state: "success",
      data: response
    };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: "GET",
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": jQuery.parseJSON,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function (target, settings) {
      return settings ? // Building a settings object
      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
      ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function (url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (typeof url === "object") {
        options = url;
        url = undefined;
      } // Force options to be an object


      options = options || {};
      var // Cross-domain detection vars
      parts,
          // Loop variable
      i,
          // URL without anti-cache param
      cacheURL,
          // Response headers as string
      responseHeadersString,
          // timeout handle
      timeoutTimer,
          // To know if global events are to be dispatched
      fireGlobals,
          transport,
          // Response headers
      responseHeaders,
          // Create the final options object
      s = jQuery.ajaxSetup({}, options),
          // Callbacks context
      callbackContext = s.context || s,
          // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          // Deferreds
      deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          // Status-dependent callbacks
      statusCode = s.statusCode || {},
          // Headers (they are sent all at once)
      requestHeaders = {},
          requestHeadersNames = {},
          // The jqXHR state
      state = 0,
          // Default abort message
      strAbort = "canceled",
          // Fake xhr
      jqXHR = {
        readyState: 0,
        // Builds headers hashtable if needed
        getResponseHeader: function (key) {
          var match;

          if (state === 2) {
            if (!responseHeaders) {
              responseHeaders = {};

              while (match = rheaders.exec(responseHeadersString)) {
                responseHeaders[match[1].toLowerCase()] = match[2];
              }
            }

            match = responseHeaders[key.toLowerCase()];
          }

          return match == null ? null : match;
        },
        // Raw string
        getAllResponseHeaders: function () {
          return state === 2 ? responseHeadersString : null;
        },
        // Caches the header
        setRequestHeader: function (name, value) {
          var lname = name.toLowerCase();

          if (!state) {
            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
            requestHeaders[name] = value;
          }

          return this;
        },
        // Overrides response content-type header
        overrideMimeType: function (type) {
          if (!state) {
            s.mimeType = type;
          }

          return this;
        },
        // Status-dependent callbacks
        statusCode: function (map) {
          var code;

          if (map) {
            if (state < 2) {
              for (code in map) {
                // Lazy-add the new callback in a way that preserves old ones
                statusCode[code] = [statusCode[code], map[code]];
              }
            } else {
              // Execute the appropriate callbacks
              jqXHR.always(map[jqXHR.status]);
            }
          }

          return this;
        },
        // Cancel the request
        abort: function (statusText) {
          var finalText = statusText || strAbort;

          if (transport) {
            transport.abort(finalText);
          }

          done(0, finalText);
          return this;
        }
      }; // Attach deferreds

      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail; // Remove hash character (#7531: and string promotion)
      // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available

      s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//"); // Alias method option to type as per ticket #12004

      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""]; // A cross-domain request is in order when we have a protocol:host:port mismatch

      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
      } // Convert data if not already a string


      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      } // Apply prefilters


      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

      if (state === 2) {
        return jqXHR;
      } // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      } // Uppercase the type


      s.type = s.type.toUpperCase(); // Determine if request has content

      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on

      cacheURL = s.url; // More options handling for requests with no content

      if (!s.hasContent) {
        // If data is available, append data to url
        if (s.data) {
          cacheURL = s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

          delete s.data;
        } // Add anti-cache in url if needed


        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? // If there is already a '_' parameter, set its value
          cacheURL.replace(rts, "$1_=" + nonce++) : // Otherwise add one to the end
          cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }

        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      } // Set the correct header, if data is being sent


      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      } // Set the Accepts header for the server, depending on the dataType


      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      } // Allow custom headers/mimetypes and early abort


      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        // Abort if not done already and return
        return jqXHR.abort();
      } // aborting is no longer a cancellation


      strAbort = "abort"; // Install callbacks on deferreds

      for (i in {
        success: 1,
        error: 1,
        complete: 1
      }) {
        jqXHR[i](s[i]);
      } // Get transport


      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1; // Send global event

        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        } // Timeout


        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Propagate exception as error if not done
          if (state < 2) {
            done(-1, e); // Simply rethrow otherwise
          } else {
            throw e;
          }
        }
      } // Callback for when everything is done


      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText; // Called once

        if (state === 2) {
          return;
        } // State is "done" now


        state = 2; // Clear timeout if it exists

        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        } // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)


        transport = undefined; // Cache response headers

        responseHeadersString = headers || ""; // Set readyState

        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        } // Convert no matter what (that way responseXXX fields are always set)


        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");

            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }

            modified = jqXHR.getResponseHeader("etag");

            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          } // if no content


          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent"; // if not modified
          } else if (status === 304) {
            statusText = "notmodified"; // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // We extract error from statusText
          // then normalize statusText and status for non-aborts
          error = statusText;

          if (status || !statusText) {
            statusText = "error";

            if (status < 0) {
              status = 0;
            }
          }
        } // Set data for the fake xhr object


        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        } // Status-dependent callbacks


        jqXHR.statusCode(statusCode);
        statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        } // Complete


        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // shift arguments if data argument was omitted
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }

      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });

  jQuery._evalUrl = function (url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };

  jQuery.fn.extend({
    wrapAll: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }

      if (this[0]) {
        // The elements to wrap the target around
        var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function () {
          var elem = this;

          while (elem.firstChild && elem.firstChild.nodeType === 1) {
            elem = elem.firstChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },
    wrapInner: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
            contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function () {
      return this.parent().each(function () {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });

  jQuery.expr.filters.hidden = function (elem) {
    // Support: Opera <= 12.12
    // Opera reports offsetWidths and offsetHeights less than zero on some elements
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !support.reliableHiddenOffsets() && (elem.style && elem.style.display || jQuery.css(elem, "display")) === "none";
  };

  jQuery.expr.filters.visible = function (elem) {
    return !jQuery.expr.filters.hidden(elem);
  };

  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (jQuery.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  } // Serialize an array of form elements or a set of
  // key/values into a query string


  jQuery.param = function (a, traditional) {
    var prefix,
        s = [],
        add = function (key, value) {
      // If value is a function, invoke it and return its value
      value = jQuery.isFunction(value) ? value() : value == null ? "" : value;
      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
    }; // Set traditional to true for jQuery <= 1.3.2 behavior.


    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    } // If an array was passed in, assume that it is an array of form elements.


    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    } // Return the resulting serialization


    return s.join("&").replace(r20, "+");
  };

  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type; // Use .is(":disabled") so that fieldset[disabled] works

        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  }); // Create the request object
  // (This is still attached to ajaxSettings for backward compatibility)

  jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ? // Support: IE6+
  function () {
    // XHR cannot access local files, always use ActiveX for that case
    return !this.isLocal && // Support: IE7-8
    // oldIE XHR does not support non-RFC2616 methods (#13240)
    // See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
    // and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
    // Although this check for six methods instead of eight
    // since IE also does not support "trace" and "connect"
    /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();
  } : // For all other browsers, use the standard XMLHttpRequest object
  createStandardXHR;
  var xhrId = 0,
      xhrCallbacks = {},
      xhrSupported = jQuery.ajaxSettings.xhr(); // Support: IE<10
  // Open requests must be manually aborted on unload (#5280)
  // See https://support.microsoft.com/kb/2856746 for more info

  if (window.attachEvent) {
    window.attachEvent("onunload", function () {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key](undefined, true);
      }
    });
  } // Determine support properties


  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  xhrSupported = support.ajax = !!xhrSupported; // Create transport if the browser can provide an xhr

  if (xhrSupported) {
    jQuery.ajaxTransport(function (options) {
      // Cross domain only allowed if supported through XMLHttpRequest
      if (!options.crossDomain || support.cors) {
        var callback;
        return {
          send: function (headers, complete) {
            var i,
                xhr = options.xhr(),
                id = ++xhrId; // Open the socket

            xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            } // Override mime type if needed


            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            } // X-Requested-With header
            // For cross-domain requests, seeing as conditions for a preflight are
            // akin to a jigsaw puzzle, we simply never set it to be sure.
            // (it can always be set on a per-request basis or even using ajaxSetup)
            // For same-domain requests, won't change header if already provided.


            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            } // Set headers


            for (i in headers) {
              // Support: IE<9
              // IE's ActiveXObject throws a 'Type Mismatch' exception when setting
              // request header to a null-value.
              //
              // To keep consistent with other XHR implementations, cast the value
              // to string and ignore `undefined`.
              if (headers[i] !== undefined) {
                xhr.setRequestHeader(i, headers[i] + "");
              }
            } // Do send the request
            // This may raise an exception which is actually
            // handled in jQuery.ajax (so no try/catch here)


            xhr.send(options.hasContent && options.data || null); // Listener

            callback = function (_, isAbort) {
              var status, statusText, responses; // Was never called and is aborted or complete

              if (callback && (isAbort || xhr.readyState === 4)) {
                // Clean up
                delete xhrCallbacks[id];
                callback = undefined;
                xhr.onreadystatechange = jQuery.noop; // Abort manually if needed

                if (isAbort) {
                  if (xhr.readyState !== 4) {
                    xhr.abort();
                  }
                } else {
                  responses = {};
                  status = xhr.status; // Support: IE<10
                  // Accessing binary-data responseText throws an exception
                  // (#11426)

                  if (typeof xhr.responseText === "string") {
                    responses.text = xhr.responseText;
                  } // Firefox throws an exception when accessing
                  // statusText for faulty cross-domain requests


                  try {
                    statusText = xhr.statusText;
                  } catch (e) {
                    // We normalize with Webkit giving an empty statusText
                    statusText = "";
                  } // Filter status for non standard behaviors
                  // If the request is local and we have data: assume a success
                  // (success with no data won't get notified, that's the best we
                  // can do given current implementations)


                  if (!status && options.isLocal && !options.crossDomain) {
                    status = responses.text ? 200 : 404; // IE - #1450: sometimes returns 1223 when it should be 204
                  } else if (status === 1223) {
                    status = 204;
                  }
                }
              } // Call complete if needed


              if (responses) {
                complete(status, statusText, responses, xhr.getAllResponseHeaders());
              }
            };

            if (!options.async) {
              // if we're in sync mode we fire the callback
              callback();
            } else if (xhr.readyState === 4) {
              // (IE6 & IE7) if it's in cache and has been
              // retrieved directly we need to fire the callback
              setTimeout(callback);
            } else {
              // Add to the list of active xhr callbacks
              xhr.onreadystatechange = xhrCallbacks[id] = callback;
            }
          },
          abort: function () {
            if (callback) {
              callback(undefined, true);
            }
          }
        };
      }
    });
  } // Functions to create xhrs


  function createStandardXHR() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  }

  function createActiveXHR() {
    try {
      return new window.ActiveXObject("Microsoft.XMLHTTP");
    } catch (e) {}
  } // Install script dataType


  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /(?:java|ecma)script/
    },
    converters: {
      "text script": function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  }); // Handle cache's special case and global

  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }

    if (s.crossDomain) {
      s.type = "GET";
      s.global = false;
    }
  }); // Bind script tag hack transport

  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain requests
    if (s.crossDomain) {
      var script,
          head = document.head || jQuery("head")[0] || document.documentElement;
      return {
        send: function (_, callback) {
          script = document.createElement("script");
          script.async = true;

          if (s.scriptCharset) {
            script.charset = s.scriptCharset;
          }

          script.src = s.url; // Attach handlers for all browsers

          script.onload = script.onreadystatechange = function (_, isAbort) {
            if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
              // Handle memory leak in IE
              script.onload = script.onreadystatechange = null; // Remove the script

              if (script.parentNode) {
                script.parentNode.removeChild(script);
              } // Dereference the script


              script = null; // Callback if not abort

              if (!isAbort) {
                callback(200, "success");
              }
            }
          }; // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
          // Use native DOM manipulation to avoid our domManip AJAX trickery


          head.insertBefore(script, head.firstChild);
        },
        abort: function () {
          if (script) {
            script.onload(undefined, true);
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
      this[callback] = true;
      return callback;
    }
  }); // Detect, normalize options and install callbacks for jsonp requests

  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      } // Use data converter to retrieve json after script execution


      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }

        return responseContainer[0];
      }; // force json dataType


      s.dataTypes[0] = "json"; // Install callback

      overwritten = window[callbackName];

      window[callbackName] = function () {
        responseContainer = arguments;
      }; // Clean-up function (fires after converters)


      jqXHR.always(function () {
        // Restore preexisting value
        window[callbackName] = overwritten; // Save back as free

        if (s[callbackName]) {
          // make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback; // save the callback name for future use

          oldCallbacks.push(callbackName);
        } // Call if it was a function and we have a response


        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      }); // Delegate to script

      return "script";
    }
  }); // data: string of html
  // context (optional): If specified, the fragment will be created in this context, defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string

  jQuery.parseHTML = function (data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }

    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }

    context = context || document;
    var parsed = rsingleTag.exec(data),
        scripts = !keepScripts && []; // Single tag

    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = jQuery.buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  }; // Keep a copy of the old load method


  var _load = jQuery.fn.load;
  /**
   * Load a url into a page
   */

  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }

    var selector,
        response,
        type,
        self = this,
        off = url.indexOf(" ");

    if (off >= 0) {
      selector = jQuery.trim(url.slice(off, url.length));
      url = url.slice(0, off);
    } // If it's a function


    if (jQuery.isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined; // Otherwise, build a param string
    } else if (params && typeof params === "object") {
      type = "POST";
    } // If we have elements to modify, make the request


    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        // if "type" variable is undefined, then "GET" method will be used
        type: type,
        dataType: "html",
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
        responseText);
      }).complete(callback && function (jqXHR, status) {
        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
      });
    }

    return this;
  }; // Attach a bunch of functions for handling common AJAX events


  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });

  jQuery.expr.filters.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };

  var docElem = window.document.documentElement;
  /**
   * Gets a window from an element
   */

  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
  }

  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {}; // set position first, in-case top/left are set even on static elem

      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1; // need to be able to calculate position if either top or left is auto and position is either absolute or fixed

      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }

      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    offset: function (options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }

      var docElem,
          win,
          box = {
        top: 0,
        left: 0
      },
          elem = this[0],
          doc = elem && elem.ownerDocument;

      if (!doc) {
        return;
      }

      docElem = doc.documentElement; // Make sure it's not a disconnected DOM node

      if (!jQuery.contains(docElem, elem)) {
        return box;
      } // If we don't have gBCR, just use 0,0 rather than error
      // BlackBerry 5, iOS 3 (original iPhone)


      if (typeof elem.getBoundingClientRect !== strundefined) {
        box = elem.getBoundingClientRect();
      }

      win = getWindow(doc);
      return {
        top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
        left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
      };
    },
    position: function () {
      if (!this[0]) {
        return;
      }

      var offsetParent,
          offset,
          parentOffset = {
        top: 0,
        left: 0
      },
          elem = this[0]; // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent

      if (jQuery.css(elem, "position") === "fixed") {
        // we assume that getBoundingClientRect is available when computed position is fixed
        offset = elem.getBoundingClientRect();
      } else {
        // Get *real* offsetParent
        offsetParent = this.offsetParent(); // Get correct offsets

        offset = this.offset();

        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        } // Add offsetParent borders


        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      } // Subtract parent offsets and element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0


      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent || docElem;

        while (offsetParent && !jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || docElem;
      });
    }
  }); // Create scrollLeft and scrollTop methods

  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = /Y/.test(prop);

    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        var win = getWindow(elem);

        if (val === undefined) {
          return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
        }

        if (win) {
          win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  }); // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // getComputedStyle returns percent when specified for top/left/bottom/right
  // rather than make the css module depend on the offset module, we just check for it here

  jQuery.each(["top", "left"], function (i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop); // if curCSS returns percentage, fallback to offset

        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function (elem, type, value) {
          var doc;

          if (jQuery.isWindow(elem)) {
            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
            // isn't a whole lot we can do. See pull request at this URL for discussion:
            // https://github.com/jquery/jquery/pull/764
            return elem.document.documentElement["client" + name];
          } // Get document width or height


          if (elem.nodeType === 9) {
            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
            // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.

            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }

          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, extra) : // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  }); // The number of elements contained in the matched element set

  jQuery.fn.size = function () {
    return this.length;
  };

  jQuery.fn.andSelf = jQuery.fn.addBack; // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

  if (typeof define === "function" && define.amd) {
    define("jquery", [], function () {
      return jQuery;
    });
  }

  var // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,
      // Map over the $ in case of overwrite
  _$ = window.$;

  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  }; // Expose jQuery and $ identifiers, even in
  // AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)


  if (typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }

  return jQuery;
});
/********************************************
	-	THEMEPUNCH TOOLS Ver. 1.0     -
	 Last Update of Tools 22.01.2013
*********************************************/

/*! Hammer.JS - v1.0.5 - 2013-04-07
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */


(function (t, e) {
  "use strict";

  function n() {
    if (!i.READY) {
      i.event.determineEventTypes();

      for (var t in i.gestures) i.gestures.hasOwnProperty(t) && i.detection.register(i.gestures[t]);

      i.event.onTouch(i.DOCUMENT, i.EVENT_MOVE, i.detection.detect), i.event.onTouch(i.DOCUMENT, i.EVENT_END, i.detection.detect), i.READY = !0;
    }
  }

  var i = function (t, e) {
    return new i.Instance(t, e || {});
  };

  i.defaults = {
    stop_browser_behavior: {
      userSelect: "none",
      touchAction: "none",
      touchCallout: "none",
      contentZooming: "none",
      userDrag: "none",
      tapHighlightColor: "rgba(0,0,0,0)"
    }
  }, i.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled, i.HAS_TOUCHEVENTS = "ontouchstart" in t, i.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i, i.NO_MOUSEEVENTS = i.HAS_TOUCHEVENTS && navigator.userAgent.match(i.MOBILE_REGEX), i.EVENT_TYPES = {}, i.DIRECTION_DOWN = "down", i.DIRECTION_LEFT = "left", i.DIRECTION_UP = "up", i.DIRECTION_RIGHT = "right", i.POINTER_MOUSE = "mouse", i.POINTER_TOUCH = "touch", i.POINTER_PEN = "pen", i.EVENT_START = "start", i.EVENT_MOVE = "move", i.EVENT_END = "end", i.DOCUMENT = document, i.plugins = {}, i.READY = !1, i.Instance = function (t, e) {
    var r = this;
    return n(), this.element = t, this.enabled = !0, this.options = i.utils.extend(i.utils.extend({}, i.defaults), e || {}), this.options.stop_browser_behavior && i.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior), i.event.onTouch(t, i.EVENT_START, function (t) {
      r.enabled && i.detection.startDetect(r, t);
    }), this;
  }, i.Instance.prototype = {
    on: function (t, e) {
      for (var n = t.split(" "), i = 0; n.length > i; i++) this.element.addEventListener(n[i], e, !1);

      return this;
    },
    off: function (t, e) {
      for (var n = t.split(" "), i = 0; n.length > i; i++) this.element.removeEventListener(n[i], e, !1);

      return this;
    },
    trigger: function (t, e) {
      var n = i.DOCUMENT.createEvent("Event");
      n.initEvent(t, !0, !0), n.gesture = e;
      var r = this.element;
      return i.utils.hasParent(e.target, r) && (r = e.target), r.dispatchEvent(n), this;
    },
    enable: function (t) {
      return this.enabled = t, this;
    }
  };
  var r = null,
      o = !1,
      s = !1;
  i.event = {
    bindDom: function (t, e, n) {
      for (var i = e.split(" "), r = 0; i.length > r; r++) t.addEventListener(i[r], n, !1);
    },
    onTouch: function (t, e, n) {
      var a = this;
      this.bindDom(t, i.EVENT_TYPES[e], function (c) {
        var u = c.type.toLowerCase();

        if (!u.match(/mouse/) || !s) {
          (u.match(/touch/) || u.match(/pointerdown/) || u.match(/mouse/) && 1 === c.which) && (o = !0), u.match(/touch|pointer/) && (s = !0);
          var h = 0;
          o && (i.HAS_POINTEREVENTS && e != i.EVENT_END ? h = i.PointerEvent.updatePointer(e, c) : u.match(/touch/) ? h = c.touches.length : s || (h = u.match(/up/) ? 0 : 1), h > 0 && e == i.EVENT_END ? e = i.EVENT_MOVE : h || (e = i.EVENT_END), h || null === r ? r = c : c = r, n.call(i.detection, a.collectEventData(t, e, c)), i.HAS_POINTEREVENTS && e == i.EVENT_END && (h = i.PointerEvent.updatePointer(e, c))), h || (r = null, o = !1, s = !1, i.PointerEvent.reset());
        }
      });
    },
    determineEventTypes: function () {
      var t;
      t = i.HAS_POINTEREVENTS ? i.PointerEvent.getEvents() : i.NO_MOUSEEVENTS ? ["touchstart", "touchmove", "touchend touchcancel"] : ["touchstart mousedown", "touchmove mousemove", "touchend touchcancel mouseup"], i.EVENT_TYPES[i.EVENT_START] = t[0], i.EVENT_TYPES[i.EVENT_MOVE] = t[1], i.EVENT_TYPES[i.EVENT_END] = t[2];
    },
    getTouchList: function (t) {
      return i.HAS_POINTEREVENTS ? i.PointerEvent.getTouchList() : t.touches ? t.touches : [{
        identifier: 1,
        pageX: t.pageX,
        pageY: t.pageY,
        target: t.target
      }];
    },
    collectEventData: function (t, e, n) {
      var r = this.getTouchList(n, e),
          o = i.POINTER_TOUCH;
      return (n.type.match(/mouse/) || i.PointerEvent.matchType(i.POINTER_MOUSE, n)) && (o = i.POINTER_MOUSE), {
        center: i.utils.getCenter(r),
        timeStamp: new Date().getTime(),
        target: n.target,
        touches: r,
        eventType: e,
        pointerType: o,
        srcEvent: n,
        preventDefault: function () {
          this.srcEvent.preventManipulation && this.srcEvent.preventManipulation(), this.srcEvent.preventDefault && this.srcEvent.preventDefault();
        },
        stopPropagation: function () {
          this.srcEvent.stopPropagation();
        },
        stopDetect: function () {
          return i.detection.stopDetect();
        }
      };
    }
  }, i.PointerEvent = {
    pointers: {},
    getTouchList: function () {
      var t = this,
          e = [];
      return Object.keys(t.pointers).sort().forEach(function (n) {
        e.push(t.pointers[n]);
      }), e;
    },
    updatePointer: function (t, e) {
      return t == i.EVENT_END ? this.pointers = {} : (e.identifier = e.pointerId, this.pointers[e.pointerId] = e), Object.keys(this.pointers).length;
    },
    matchType: function (t, e) {
      if (!e.pointerType) return !1;
      var n = {};
      return n[i.POINTER_MOUSE] = e.pointerType == e.MSPOINTER_TYPE_MOUSE || e.pointerType == i.POINTER_MOUSE, n[i.POINTER_TOUCH] = e.pointerType == e.MSPOINTER_TYPE_TOUCH || e.pointerType == i.POINTER_TOUCH, n[i.POINTER_PEN] = e.pointerType == e.MSPOINTER_TYPE_PEN || e.pointerType == i.POINTER_PEN, n[t];
    },
    getEvents: function () {
      return ["pointerdown MSPointerDown", "pointermove MSPointerMove", "pointerup pointercancel MSPointerUp MSPointerCancel"];
    },
    reset: function () {
      this.pointers = {};
    }
  }, i.utils = {
    extend: function (t, n, i) {
      for (var r in n) t[r] !== e && i || (t[r] = n[r]);

      return t;
    },
    hasParent: function (t, e) {
      for (; t;) {
        if (t == e) return !0;
        t = t.parentNode;
      }

      return !1;
    },
    getCenter: function (t) {
      for (var e = [], n = [], i = 0, r = t.length; r > i; i++) e.push(t[i].pageX), n.push(t[i].pageY);

      return {
        pageX: (Math.min.apply(Math, e) + Math.max.apply(Math, e)) / 2,
        pageY: (Math.min.apply(Math, n) + Math.max.apply(Math, n)) / 2
      };
    },
    getVelocity: function (t, e, n) {
      return {
        x: Math.abs(e / t) || 0,
        y: Math.abs(n / t) || 0
      };
    },
    getAngle: function (t, e) {
      var n = e.pageY - t.pageY,
          i = e.pageX - t.pageX;
      return 180 * Math.atan2(n, i) / Math.PI;
    },
    getDirection: function (t, e) {
      var n = Math.abs(t.pageX - e.pageX),
          r = Math.abs(t.pageY - e.pageY);
      return n >= r ? t.pageX - e.pageX > 0 ? i.DIRECTION_LEFT : i.DIRECTION_RIGHT : t.pageY - e.pageY > 0 ? i.DIRECTION_UP : i.DIRECTION_DOWN;
    },
    getDistance: function (t, e) {
      var n = e.pageX - t.pageX,
          i = e.pageY - t.pageY;
      return Math.sqrt(n * n + i * i);
    },
    getScale: function (t, e) {
      return t.length >= 2 && e.length >= 2 ? this.getDistance(e[0], e[1]) / this.getDistance(t[0], t[1]) : 1;
    },
    getRotation: function (t, e) {
      return t.length >= 2 && e.length >= 2 ? this.getAngle(e[1], e[0]) - this.getAngle(t[1], t[0]) : 0;
    },
    isVertical: function (t) {
      return t == i.DIRECTION_UP || t == i.DIRECTION_DOWN;
    },
    stopDefaultBrowserBehavior: function (t, e) {
      var n,
          i = ["webkit", "khtml", "moz", "ms", "o", ""];

      if (e && t.style) {
        for (var r = 0; i.length > r; r++) for (var o in e) e.hasOwnProperty(o) && (n = o, i[r] && (n = i[r] + n.substring(0, 1).toUpperCase() + n.substring(1)), t.style[n] = e[o]);

        "none" == e.userSelect && (t.onselectstart = function () {
          return !1;
        });
      }
    }
  }, i.detection = {
    gestures: [],
    current: null,
    previous: null,
    stopped: !1,
    startDetect: function (t, e) {
      this.current || (this.stopped = !1, this.current = {
        inst: t,
        startEvent: i.utils.extend({}, e),
        lastEvent: !1,
        name: ""
      }, this.detect(e));
    },
    detect: function (t) {
      if (this.current && !this.stopped) {
        t = this.extendEventData(t);

        for (var e = this.current.inst.options, n = 0, r = this.gestures.length; r > n; n++) {
          var o = this.gestures[n];

          if (!this.stopped && e[o.name] !== !1 && o.handler.call(o, t, this.current.inst) === !1) {
            this.stopDetect();
            break;
          }
        }

        return this.current && (this.current.lastEvent = t), t.eventType == i.EVENT_END && !t.touches.length - 1 && this.stopDetect(), t;
      }
    },
    stopDetect: function () {
      this.previous = i.utils.extend({}, this.current), this.current = null, this.stopped = !0;
    },
    extendEventData: function (t) {
      var e = this.current.startEvent;

      if (e && (t.touches.length != e.touches.length || t.touches === e.touches)) {
        e.touches = [];

        for (var n = 0, r = t.touches.length; r > n; n++) e.touches.push(i.utils.extend({}, t.touches[n]));
      }

      var o = t.timeStamp - e.timeStamp,
          s = t.center.pageX - e.center.pageX,
          a = t.center.pageY - e.center.pageY,
          c = i.utils.getVelocity(o, s, a);
      return i.utils.extend(t, {
        deltaTime: o,
        deltaX: s,
        deltaY: a,
        velocityX: c.x,
        velocityY: c.y,
        distance: i.utils.getDistance(e.center, t.center),
        angle: i.utils.getAngle(e.center, t.center),
        direction: i.utils.getDirection(e.center, t.center),
        scale: i.utils.getScale(e.touches, t.touches),
        rotation: i.utils.getRotation(e.touches, t.touches),
        startEvent: e
      }), t;
    },
    register: function (t) {
      var n = t.defaults || {};
      return n[t.name] === e && (n[t.name] = !0), i.utils.extend(i.defaults, n, !0), t.index = t.index || 1e3, this.gestures.push(t), this.gestures.sort(function (t, e) {
        return t.index < e.index ? -1 : t.index > e.index ? 1 : 0;
      }), this.gestures;
    }
  }, i.gestures = i.gestures || {}, i.gestures.Hold = {
    name: "hold",
    index: 10,
    defaults: {
      hold_timeout: 500,
      hold_threshold: 1
    },
    timer: null,
    handler: function (t, e) {
      switch (t.eventType) {
        case i.EVENT_START:
          clearTimeout(this.timer), i.detection.current.name = this.name, this.timer = setTimeout(function () {
            "hold" == i.detection.current.name && e.trigger("hold", t);
          }, e.options.hold_timeout);
          break;

        case i.EVENT_MOVE:
          t.distance > e.options.hold_threshold && clearTimeout(this.timer);
          break;

        case i.EVENT_END:
          clearTimeout(this.timer);
      }
    }
  }, i.gestures.Tap = {
    name: "tap",
    index: 100,
    defaults: {
      tap_max_touchtime: 250,
      tap_max_distance: 10,
      tap_always: !0,
      doubletap_distance: 20,
      doubletap_interval: 300
    },
    handler: function (t, e) {
      if (t.eventType == i.EVENT_END) {
        var n = i.detection.previous,
            r = !1;
        if (t.deltaTime > e.options.tap_max_touchtime || t.distance > e.options.tap_max_distance) return;
        n && "tap" == n.name && t.timeStamp - n.lastEvent.timeStamp < e.options.doubletap_interval && t.distance < e.options.doubletap_distance && (e.trigger("doubletap", t), r = !0), (!r || e.options.tap_always) && (i.detection.current.name = "tap", e.trigger(i.detection.current.name, t));
      }
    }
  }, i.gestures.Swipe = {
    name: "swipe",
    index: 40,
    defaults: {
      swipe_max_touches: 1,
      swipe_velocity: .7
    },
    handler: function (t, e) {
      if (t.eventType == i.EVENT_END) {
        if (e.options.swipe_max_touches > 0 && t.touches.length > e.options.swipe_max_touches) return;
        (t.velocityX > e.options.swipe_velocity || t.velocityY > e.options.swipe_velocity) && (e.trigger(this.name, t), e.trigger(this.name + t.direction, t));
      }
    }
  }, i.gestures.Drag = {
    name: "drag",
    index: 50,
    defaults: {
      drag_min_distance: 10,
      drag_max_touches: 1,
      drag_block_horizontal: !1,
      drag_block_vertical: !1,
      drag_lock_to_axis: !1,
      drag_lock_min_distance: 25
    },
    triggered: !1,
    handler: function (t, n) {
      if (i.detection.current.name != this.name && this.triggered) return n.trigger(this.name + "end", t), this.triggered = !1, e;
      if (!(n.options.drag_max_touches > 0 && t.touches.length > n.options.drag_max_touches)) switch (t.eventType) {
        case i.EVENT_START:
          this.triggered = !1;
          break;

        case i.EVENT_MOVE:
          if (t.distance < n.options.drag_min_distance && i.detection.current.name != this.name) return;
          i.detection.current.name = this.name, (i.detection.current.lastEvent.drag_locked_to_axis || n.options.drag_lock_to_axis && n.options.drag_lock_min_distance <= t.distance) && (t.drag_locked_to_axis = !0);
          var r = i.detection.current.lastEvent.direction;
          t.drag_locked_to_axis && r !== t.direction && (t.direction = i.utils.isVertical(r) ? 0 > t.deltaY ? i.DIRECTION_UP : i.DIRECTION_DOWN : 0 > t.deltaX ? i.DIRECTION_LEFT : i.DIRECTION_RIGHT), this.triggered || (n.trigger(this.name + "start", t), this.triggered = !0), n.trigger(this.name, t), n.trigger(this.name + t.direction, t), (n.options.drag_block_vertical && i.utils.isVertical(t.direction) || n.options.drag_block_horizontal && !i.utils.isVertical(t.direction)) && t.preventDefault();
          break;

        case i.EVENT_END:
          this.triggered && n.trigger(this.name + "end", t), this.triggered = !1;
      }
    }
  }, i.gestures.Transform = {
    name: "transform",
    index: 45,
    defaults: {
      transform_min_scale: .01,
      transform_min_rotation: 1,
      transform_always_block: !1
    },
    triggered: !1,
    handler: function (t, n) {
      if (i.detection.current.name != this.name && this.triggered) return n.trigger(this.name + "end", t), this.triggered = !1, e;
      if (!(2 > t.touches.length)) switch (n.options.transform_always_block && t.preventDefault(), t.eventType) {
        case i.EVENT_START:
          this.triggered = !1;
          break;

        case i.EVENT_MOVE:
          var r = Math.abs(1 - t.scale),
              o = Math.abs(t.rotation);
          if (n.options.transform_min_scale > r && n.options.transform_min_rotation > o) return;
          i.detection.current.name = this.name, this.triggered || (n.trigger(this.name + "start", t), this.triggered = !0), n.trigger(this.name, t), o > n.options.transform_min_rotation && n.trigger("rotate", t), r > n.options.transform_min_scale && (n.trigger("pinch", t), n.trigger("pinch" + (1 > t.scale ? "in" : "out"), t));
          break;

        case i.EVENT_END:
          this.triggered && n.trigger(this.name + "end", t), this.triggered = !1;
      }
    }
  }, i.gestures.Touch = {
    name: "touch",
    index: -1 / 0,
    defaults: {
      prevent_default: !1,
      prevent_mouseevents: !1
    },
    handler: function (t, n) {
      return n.options.prevent_mouseevents && t.pointerType == i.POINTER_MOUSE ? (t.stopDetect(), e) : (n.options.prevent_default && t.preventDefault(), t.eventType == i.EVENT_START && n.trigger(this.name, t), e);
    }
  }, i.gestures.Release = {
    name: "release",
    index: 1 / 0,
    handler: function (t, e) {
      t.eventType == i.EVENT_END && e.trigger(this.name, t);
    }
  }, "object" == typeof module && "object" == typeof module.exports ? module.exports = i : (t.Hammer = i, "function" == typeof t.define && t.define.amd && t.define("hammer", [], function () {
    return i;
  }));
})(void 0), function (t, e) {
  "use strict";

  t !== e && (Hammer.event.bindDom = function (n, i, r) {
    t(n).on(i, function (t) {
      var n = t.originalEvent || t;
      n.pageX === e && (n.pageX = t.pageX, n.pageY = t.pageY), n.target || (n.target = t.target), n.which === e && (n.which = n.button), n.preventDefault || (n.preventDefault = t.preventDefault), n.stopPropagation || (n.stopPropagation = t.stopPropagation), r.call(this, n);
    });
  }, Hammer.Instance.prototype.on = function (e, n) {
    return t(this.element).on(e, n);
  }, Hammer.Instance.prototype.off = function (e, n) {
    return t(this.element).off(e, n);
  }, Hammer.Instance.prototype.trigger = function (e, n) {
    var i = t(this.element);
    return i.has(n.target).length && (i = t(n.target)), i.trigger({
      type: e,
      gesture: n
    });
  }, t.fn.hammer = function (e) {
    return this.each(function () {
      var n = t(this),
          i = n.data("hammer");
      i ? i && e && Hammer.utils.extend(i.options, e) : n.data("hammer", new Hammer(this, e || {}));
    });
  });
}(window.jQuery || window.Zepto);
/*!
 * VERSION: 1.11.5
 * DATE: 2014-02-20
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * @license Copyright (c) 2008-2014, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */

(function (t) {
  "use strict";

  var e = t.GreenSockGlobals || t;

  if (!e.TweenLite) {
    var i,
        s,
        r,
        n,
        a,
        o = function (t) {
      var i,
          s = t.split("."),
          r = e;

      for (i = 0; s.length > i; i++) r[s[i]] = r = r[s[i]] || {};

      return r;
    },
        l = o("com.greensock"),
        h = 1e-10,
        _ = [].slice,
        u = function () {},
        m = function () {
      var t = Object.prototype.toString,
          e = t.call([]);
      return function (i) {
        return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e);
      };
    }(),
        f = {},
        p = function (i, s, r, n) {
      this.sc = f[i] ? f[i].sc : [], f[i] = this, this.gsClass = null, this.func = r;
      var a = [];
      this.check = function (l) {
        for (var h, _, u, m, c = s.length, d = c; --c > -1;) (h = f[s[c]] || new p(s[c], [])).gsClass ? (a[c] = h.gsClass, d--) : l && h.sc.push(this);

        if (0 === d && r) for (_ = ("com.greensock." + i).split("."), u = _.pop(), m = o(_.join("."))[u] = this.gsClass = r.apply(r, a), n && (e[u] = m, "function" == typeof define && define.amd ? define((t.GreenSockAMDPath ? t.GreenSockAMDPath + "/" : "") + i.split(".").join("/"), [], function () {
          return m;
        }) : "undefined" != typeof module && module.exports && (module.exports = m)), c = 0; this.sc.length > c; c++) this.sc[c].check();
      }, this.check(!0);
    },
        c = t._gsDefine = function (t, e, i, s) {
      return new p(t, e, i, s);
    },
        d = l._class = function (t, e, i) {
      return e = e || function () {}, c(t, [], function () {
        return e;
      }, i), e;
    };

    c.globals = e;

    var v = [0, 0, 1, 1],
        g = [],
        T = d("easing.Ease", function (t, e, i, s) {
      this._func = t, this._type = i || 0, this._power = s || 0, this._params = e ? v.concat(e) : v;
    }, !0),
        w = T.map = {},
        P = T.register = function (t, e, i, s) {
      for (var r, n, a, o, h = e.split(","), _ = h.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --_ > -1;) for (n = h[_], r = s ? d("easing." + n, null, !0) : l.easing[n] || {}, a = u.length; --a > -1;) o = u[a], w[n + "." + o] = w[o + n] = r[o] = t.getRatio ? t : t[o] || new t();
    };

    for (r = T.prototype, r._calcEnd = !1, r.getRatio = function (t) {
      if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
      var e = this._type,
          i = this._power,
          s = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t);
      return 1 === i ? s *= s : 2 === i ? s *= s * s : 3 === i ? s *= s * s * s : 4 === i && (s *= s * s * s * s), 1 === e ? 1 - s : 2 === e ? s : .5 > t ? s / 2 : 1 - s / 2;
    }, i = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], s = i.length; --s > -1;) r = i[s] + ",Power" + s, P(new T(null, null, 1, s), r, "easeOut", !0), P(new T(null, null, 2, s), r, "easeIn" + (0 === s ? ",easeNone" : "")), P(new T(null, null, 3, s), r, "easeInOut");

    w.linear = l.easing.Linear.easeIn, w.swing = l.easing.Quad.easeInOut;
    var y = d("events.EventDispatcher", function (t) {
      this._listeners = {}, this._eventTarget = t || this;
    });
    r = y.prototype, r.addEventListener = function (t, e, i, s, r) {
      r = r || 0;
      var o,
          l,
          h = this._listeners[t],
          _ = 0;

      for (null == h && (this._listeners[t] = h = []), l = h.length; --l > -1;) o = h[l], o.c === e && o.s === i ? h.splice(l, 1) : 0 === _ && r > o.pr && (_ = l + 1);

      h.splice(_, 0, {
        c: e,
        s: i,
        up: s,
        pr: r
      }), this !== n || a || n.wake();
    }, r.removeEventListener = function (t, e) {
      var i,
          s = this._listeners[t];
      if (s) for (i = s.length; --i > -1;) if (s[i].c === e) return s.splice(i, 1), void 0;
    }, r.dispatchEvent = function (t) {
      var e,
          i,
          s,
          r = this._listeners[t];
      if (r) for (e = r.length, i = this._eventTarget; --e > -1;) s = r[e], s.up ? s.c.call(s.s || i, {
        type: t,
        target: i
      }) : s.c.call(s.s || i);
    };

    var b = t.requestAnimationFrame,
        k = t.cancelAnimationFrame,
        A = Date.now || function () {
      return new Date().getTime();
    },
        S = A();

    for (i = ["ms", "moz", "webkit", "o"], s = i.length; --s > -1 && !b;) b = t[i[s] + "RequestAnimationFrame"], k = t[i[s] + "CancelAnimationFrame"] || t[i[s] + "CancelRequestAnimationFrame"];

    d("Ticker", function (t, e) {
      var i,
          s,
          r,
          o,
          l,
          h = this,
          _ = A(),
          m = e !== !1 && b,
          f = function (t) {
        S = A(), h.time = (S - _) / 1e3;
        var e,
            n = h.time - l;
        (!i || n > 0 || t === !0) && (h.frame++, l += n + (n >= o ? .004 : o - n), e = !0), t !== !0 && (r = s(f)), e && h.dispatchEvent("tick");
      };

      y.call(h), h.time = h.frame = 0, h.tick = function () {
        f(!0);
      }, h.sleep = function () {
        null != r && (m && k ? k(r) : clearTimeout(r), s = u, r = null, h === n && (a = !1));
      }, h.wake = function () {
        null !== r && h.sleep(), s = 0 === i ? u : m && b ? b : function (t) {
          return setTimeout(t, 0 | 1e3 * (l - h.time) + 1);
        }, h === n && (a = !0), f(2);
      }, h.fps = function (t) {
        return arguments.length ? (i = t, o = 1 / (i || 60), l = this.time + o, h.wake(), void 0) : i;
      }, h.useRAF = function (t) {
        return arguments.length ? (h.sleep(), m = t, h.fps(i), void 0) : m;
      }, h.fps(t), setTimeout(function () {
        m && (!r || 5 > h.frame) && h.useRAF(!1);
      }, 1500);
    }), r = l.Ticker.prototype = new l.events.EventDispatcher(), r.constructor = l.Ticker;
    var x = d("core.Animation", function (t, e) {
      if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = e.immediateRender === !0, this.data = e.data, this._reversed = e.reversed === !0, Q) {
        a || n.wake();
        var i = this.vars.useFrames ? G : Q;
        i.add(this, i._time), this.vars.paused && this.paused(!0);
      }
    });
    n = x.ticker = new l.Ticker(), r = x.prototype, r._dirty = r._gc = r._initted = r._paused = !1, r._totalTime = r._time = 0, r._rawPrevTime = -1, r._next = r._last = r._onUpdate = r._timeline = r.timeline = null, r._paused = !1;

    var C = function () {
      a && A() - S > 2e3 && n.wake(), setTimeout(C, 2e3);
    };

    C(), r.play = function (t, e) {
      return arguments.length && this.seek(t, e), this.reversed(!1).paused(!1);
    }, r.pause = function (t, e) {
      return arguments.length && this.seek(t, e), this.paused(!0);
    }, r.resume = function (t, e) {
      return arguments.length && this.seek(t, e), this.paused(!1);
    }, r.seek = function (t, e) {
      return this.totalTime(Number(t), e !== !1);
    }, r.restart = function (t, e) {
      return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0);
    }, r.reverse = function (t, e) {
      return arguments.length && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1);
    }, r.render = function () {}, r.invalidate = function () {
      return this;
    }, r.isActive = function () {
      var t,
          e = this._timeline,
          i = this._startTime;
      return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime()) >= i && i + this.totalDuration() / this._timeScale > t;
    }, r._enabled = function (t, e) {
      return a || n.wake(), this._gc = !t, this._active = this.isActive(), e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1;
    }, r._kill = function () {
      return this._enabled(!1, !1);
    }, r.kill = function (t, e) {
      return this._kill(t, e), this;
    }, r._uncache = function (t) {
      for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;

      return this;
    }, r._swapSelfInParams = function (t) {
      for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);

      return i;
    }, r.eventCallback = function (t, e, i, s) {
      if ("on" === (t || "").substr(0, 2)) {
        var r = this.vars;
        if (1 === arguments.length) return r[t];
        null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = m(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = s), "onUpdate" === t && (this._onUpdate = e);
      }

      return this;
    }, r.delay = function (t) {
      return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay;
    }, r.duration = function (t) {
      return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration);
    }, r.totalDuration = function (t) {
      return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration;
    }, r.time = function (t, e) {
      return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time;
    }, r.totalTime = function (t, e, i) {
      if (a || n.wake(), !arguments.length) return this._totalTime;

      if (this._timeline) {
        if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
          this._dirty && this.totalDuration();
          var s = this._totalDuration,
              r = this._timeline;
          if (t > s && !i && (t = s), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? s - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline) for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline;
        }

        this._gc && this._enabled(!0, !1), (this._totalTime !== t || 0 === this._duration) && this.render(t, e, !1);
      }

      return this;
    }, r.progress = r.totalProgress = function (t, e) {
      return arguments.length ? this.totalTime(this.duration() * t, e) : this._time / this.duration();
    }, r.startTime = function (t) {
      return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime;
    }, r.timeScale = function (t) {
      if (!arguments.length) return this._timeScale;

      if (t = t || h, this._timeline && this._timeline.smoothChildTiming) {
        var e = this._pauseTime,
            i = e || 0 === e ? e : this._timeline.totalTime();
        this._startTime = i - (i - this._startTime) * this._timeScale / t;
      }

      return this._timeScale = t, this._uncache(!1);
    }, r.reversed = function (t) {
      return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed;
    }, r.paused = function (t) {
      if (!arguments.length) return this._paused;

      if (t != this._paused && this._timeline) {
        a || t || n.wake();
        var e = this._timeline,
            i = e.rawTime(),
            s = i - this._pauseTime;
        !t && e.smoothChildTiming && (this._startTime += s, this._uncache(!1)), this._pauseTime = t ? i : null, this._paused = t, this._active = this.isActive(), !t && 0 !== s && this._initted && this.duration() && this.render(e.smoothChildTiming ? this._totalTime : (i - this._startTime) / this._timeScale, !0, !0);
      }

      return this._gc && !t && this._enabled(!0, !1), this;
    };
    var R = d("core.SimpleTimeline", function (t) {
      x.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0;
    });
    r = R.prototype = new x(), r.constructor = R, r.kill()._gc = !1, r._first = r._last = null, r._sortChildren = !1, r.add = r.insert = function (t, e) {
      var i, s;
      if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = t._startTime + (this.rawTime() - t._startTime) / t._timeScale), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), i = this._last, this._sortChildren) for (s = t._startTime; i && i._startTime > s;) i = i._prev;
      return i ? (t._next = i._next, i._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = i, this._timeline && this._uncache(!0), this;
    }, r._remove = function (t, e) {
      return t.timeline === this && (e || t._enabled(!1, !0), t.timeline = null, t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), this._timeline && this._uncache(!0)), this;
    }, r.render = function (t, e, i) {
      var s,
          r = this._first;

      for (this._totalTime = this._time = this._rawPrevTime = t; r;) s = r._next, (r._active || t >= r._startTime && !r._paused) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = s;
    }, r.rawTime = function () {
      return a || n.wake(), this._totalTime;
    };

    var D = d("TweenLite", function (e, i, s) {
      if (x.call(this, i, s), this.render = D.prototype.render, null == e) throw "Cannot tween a null target.";
      this.target = e = "string" != typeof e ? e : D.selector(e) || e;
      var r,
          n,
          a,
          o = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
          l = this.vars.overwrite;
      if (this._overwrite = l = null == l ? j[D.defaultOverwrite] : "number" == typeof l ? l >> 0 : j[l], (o || e instanceof Array || e.push && m(e)) && "number" != typeof e[0]) for (this._targets = a = _.call(e, 0), this._propLookup = [], this._siblings = [], r = 0; a.length > r; r++) n = a[r], n ? "string" != typeof n ? n.length && n !== t && n[0] && (n[0] === t || n[0].nodeType && n[0].style && !n.nodeType) ? (a.splice(r--, 1), this._targets = a = a.concat(_.call(n, 0))) : (this._siblings[r] = B(n, this, !1), 1 === l && this._siblings[r].length > 1 && q(n, this, null, 1, this._siblings[r])) : (n = a[r--] = D.selector(n), "string" == typeof n && a.splice(r + 1, 1)) : a.splice(r--, 1);else this._propLookup = {}, this._siblings = B(e, this, !1), 1 === l && this._siblings.length > 1 && q(e, this, null, 1, this._siblings);
      (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender !== !1) && this.render(-this._delay, !1, !0);
    }, !0),
        E = function (e) {
      return e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType);
    },
        I = function (t, e) {
      var i,
          s = {};

      for (i in t) F[i] || i in e && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!N[i] || N[i] && N[i]._autoCSS) || (s[i] = t[i], delete t[i]);

      t.css = s;
    };

    r = D.prototype = new x(), r.constructor = D, r.kill()._gc = !1, r.ratio = 0, r._firstPT = r._targets = r._overwrittenProps = r._startAt = null, r._notifyPluginsOfEnabled = !1, D.version = "1.11.5", D.defaultEase = r._ease = new T(null, null, 1, 1), D.defaultOverwrite = "auto", D.ticker = n, D.autoSleep = !0, D.selector = t.$ || t.jQuery || function (e) {
      return t.$ ? (D.selector = t.$, t.$(e)) : t.document ? t.document.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e;
    };
    var O = D._internals = {
      isArray: m,
      isSelector: E
    },
        N = D._plugins = {},
        L = D._tweenLookup = {},
        U = 0,
        F = O.reservedProps = {
      ease: 1,
      delay: 1,
      overwrite: 1,
      onComplete: 1,
      onCompleteParams: 1,
      onCompleteScope: 1,
      useFrames: 1,
      runBackwards: 1,
      startAt: 1,
      onUpdate: 1,
      onUpdateParams: 1,
      onUpdateScope: 1,
      onStart: 1,
      onStartParams: 1,
      onStartScope: 1,
      onReverseComplete: 1,
      onReverseCompleteParams: 1,
      onReverseCompleteScope: 1,
      onRepeat: 1,
      onRepeatParams: 1,
      onRepeatScope: 1,
      easeParams: 1,
      yoyo: 1,
      immediateRender: 1,
      repeat: 1,
      repeatDelay: 1,
      data: 1,
      paused: 1,
      reversed: 1,
      autoCSS: 1
    },
        j = {
      none: 0,
      all: 1,
      auto: 2,
      concurrent: 3,
      allOnStart: 4,
      preexisting: 5,
      "true": 1,
      "false": 0
    },
        G = x._rootFramesTimeline = new R(),
        Q = x._rootTimeline = new R();
    Q._startTime = n.time, G._startTime = n.frame, Q._active = G._active = !0, x._updateRoot = function () {
      if (Q.render((n.time - Q._startTime) * Q._timeScale, !1, !1), G.render((n.frame - G._startTime) * G._timeScale, !1, !1), !(n.frame % 120)) {
        var t, e, i;

        for (i in L) {
          for (e = L[i].tweens, t = e.length; --t > -1;) e[t]._gc && e.splice(t, 1);

          0 === e.length && delete L[i];
        }

        if (i = Q._first, (!i || i._paused) && D.autoSleep && !G._first && 1 === n._listeners.tick.length) {
          for (; i && i._paused;) i = i._next;

          i || n.sleep();
        }
      }
    }, n.addEventListener("tick", x._updateRoot);

    var B = function (t, e, i) {
      var s,
          r,
          n = t._gsTweenID;
      if (L[n || (t._gsTweenID = n = "t" + U++)] || (L[n] = {
        target: t,
        tweens: []
      }), e && (s = L[n].tweens, s[r = s.length] = e, i)) for (; --r > -1;) s[r] === e && s.splice(r, 1);
      return L[n].tweens;
    },
        q = function (t, e, i, s, r) {
      var n, a, o, l;

      if (1 === s || s >= 4) {
        for (l = r.length, n = 0; l > n; n++) if ((o = r[n]) !== e) o._gc || o._enabled(!1, !1) && (a = !0);else if (5 === s) break;

        return a;
      }

      var _,
          u = e._startTime + h,
          m = [],
          f = 0,
          p = 0 === e._duration;

      for (n = r.length; --n > -1;) (o = r[n]) === e || o._gc || o._paused || (o._timeline !== e._timeline ? (_ = _ || $(e, 0, p), 0 === $(o, _, p) && (m[f++] = o)) : u >= o._startTime && o._startTime + o.totalDuration() / o._timeScale > u && ((p || !o._initted) && 2e-10 >= u - o._startTime || (m[f++] = o)));

      for (n = f; --n > -1;) o = m[n], 2 === s && o._kill(i, t) && (a = !0), (2 !== s || !o._firstPT && o._initted) && o._enabled(!1, !1) && (a = !0);

      return a;
    },
        $ = function (t, e, i) {
      for (var s = t._timeline, r = s._timeScale, n = t._startTime; s._timeline;) {
        if (n += s._startTime, r *= s._timeScale, s._paused) return -100;
        s = s._timeline;
      }

      return n /= r, n > e ? n - e : i && n === e || !t._initted && 2 * h > n - e ? h : (n += t.totalDuration() / t._timeScale / r) > e + h ? 0 : n - e - h;
    };

    r._init = function () {
      var t,
          e,
          i,
          s,
          r = this.vars,
          n = this._overwrittenProps,
          a = this._duration,
          o = r.immediateRender,
          l = r.ease;

      if (r.startAt) {
        if (this._startAt && this._startAt.render(-1, !0), r.startAt.overwrite = 0, r.startAt.immediateRender = !0, this._startAt = D.to(this.target, 0, r.startAt), o) if (this._time > 0) this._startAt = null;else if (0 !== a) return;
      } else if (r.runBackwards && 0 !== a) if (this._startAt) this._startAt.render(-1, !0), this._startAt = null;else {
        i = {};

        for (s in r) F[s] && "autoCSS" !== s || (i[s] = r[s]);

        if (i.overwrite = 0, i.data = "isFromStart", this._startAt = D.to(this.target, 0, i), r.immediateRender) {
          if (0 === this._time) return;
        } else this._startAt.render(-1, !0);
      }

      if (this._ease = l ? l instanceof T ? r.easeParams instanceof Array ? l.config.apply(l, r.easeParams) : l : "function" == typeof l ? new T(l, r.easeParams) : w[l] || D.defaultEase : D.defaultEase, this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (t = this._targets.length; --t > -1;) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], n ? n[t] : null) && (e = !0);else e = this._initProps(this.target, this._propLookup, this._siblings, n);
      if (e && D._onPluginEvent("_onInitAllProps", this), n && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), r.runBackwards) for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
      this._onUpdate = r.onUpdate, this._initted = !0;
    }, r._initProps = function (e, i, s, r) {
      var n, a, o, l, h, _;

      if (null == e) return !1;
      this.vars.css || e.style && e !== t && e.nodeType && N.css && this.vars.autoCSS !== !1 && I(this.vars, e);

      for (n in this.vars) {
        if (_ = this.vars[n], F[n]) _ && (_ instanceof Array || _.push && m(_)) && -1 !== _.join("").indexOf("{self}") && (this.vars[n] = _ = this._swapSelfInParams(_, this));else if (N[n] && (l = new N[n]())._onInitTween(e, this.vars[n], this)) {
          for (this._firstPT = h = {
            _next: this._firstPT,
            t: l,
            p: "setRatio",
            s: 0,
            c: 1,
            f: !0,
            n: n,
            pg: !0,
            pr: l._priority
          }, a = l._overwriteProps.length; --a > -1;) i[l._overwriteProps[a]] = this._firstPT;

          (l._priority || l._onInitAllProps) && (o = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0);
        } else this._firstPT = i[n] = h = {
          _next: this._firstPT,
          t: e,
          p: n,
          f: "function" == typeof e[n],
          n: n,
          pg: !1,
          pr: 0
        }, h.s = h.f ? e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(e[n]), h.c = "string" == typeof _ && "=" === _.charAt(1) ? parseInt(_.charAt(0) + "1", 10) * Number(_.substr(2)) : Number(_) - h.s || 0;
        h && h._next && (h._next._prev = h);
      }

      return r && this._kill(r, e) ? this._initProps(e, i, s, r) : this._overwrite > 1 && this._firstPT && s.length > 1 && q(e, this, i, this._overwrite, s) ? (this._kill(i, e), this._initProps(e, i, s, r)) : o;
    }, r.render = function (t, e, i) {
      var s,
          r,
          n,
          a,
          o = this._time,
          l = this._duration;
      if (t >= l) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (s = !0, r = "onComplete"), 0 === l && (a = this._rawPrevTime, (0 === t || 0 > a || a === h) && a !== t && (i = !0, a > h && (r = "onReverseComplete")), this._rawPrevTime = a = !e || t || 0 === a ? t : h);else if (1e-7 > t) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== o || 0 === l && this._rawPrevTime > h) && (r = "onReverseComplete", s = this._reversed), 0 > t ? (this._active = !1, 0 === l && (this._rawPrevTime >= 0 && (i = !0), this._rawPrevTime = a = !e || t || 0 === this._rawPrevTime ? t : h)) : this._initted || (i = !0);else if (this._totalTime = this._time = t, this._easeType) {
        var _ = t / l,
            u = this._easeType,
            m = this._easePower;

        (1 === u || 3 === u && _ >= .5) && (_ = 1 - _), 3 === u && (_ *= 2), 1 === m ? _ *= _ : 2 === m ? _ *= _ * _ : 3 === m ? _ *= _ * _ * _ : 4 === m && (_ *= _ * _ * _ * _), this.ratio = 1 === u ? 1 - _ : 2 === u ? _ : .5 > t / l ? _ / 2 : 1 - _ / 2;
      } else this.ratio = this._ease.getRatio(t / l);

      if (this._time !== o || i) {
        if (!this._initted) {
          if (this._init(), !this._initted || this._gc) return;
          this._time && !s ? this.ratio = this._ease.getRatio(this._time / l) : s && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1));
        }

        for (this._active || !this._paused && this._time !== o && t >= 0 && (this._active = !0), 0 === o && (this._startAt && (t >= 0 ? this._startAt.render(t, e, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === l) && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || g))), n = this._firstPT; n;) n.f ? n.t[n.p](n.c * this.ratio + n.s) : n.t[n.p] = n.c * this.ratio + n.s, n = n._next;

        this._onUpdate && (0 > t && this._startAt && this._startTime && this._startAt.render(t, e, i), e || (this._time !== o || s) && this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || g)), r && (this._gc || (0 > t && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, e, i), s && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this.vars[r].apply(this.vars[r + "Scope"] || this, this.vars[r + "Params"] || g), 0 === l && this._rawPrevTime === h && a !== h && (this._rawPrevTime = 0)));
      }
    }, r._kill = function (t, e) {
      if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._enabled(!1, !1);
      e = "string" != typeof e ? e || this._targets || this.target : D.selector(e) || e;
      var i, s, r, n, a, o, l, h;
      if ((m(e) || E(e)) && "number" != typeof e[0]) for (i = e.length; --i > -1;) this._kill(t, e[i]) && (o = !0);else {
        if (this._targets) {
          for (i = this._targets.length; --i > -1;) if (e === this._targets[i]) {
            a = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], s = this._overwrittenProps[i] = t ? this._overwrittenProps[i] || {} : "all";
            break;
          }
        } else {
          if (e !== this.target) return !1;
          a = this._propLookup, s = this._overwrittenProps = t ? this._overwrittenProps || {} : "all";
        }

        if (a) {
          l = t || a, h = t !== s && "all" !== s && t !== a && ("object" != typeof t || !t._tempKill);

          for (r in l) (n = a[r]) && (n.pg && n.t._kill(l) && (o = !0), n.pg && 0 !== n.t._overwriteProps.length || (n._prev ? n._prev._next = n._next : n === this._firstPT && (this._firstPT = n._next), n._next && (n._next._prev = n._prev), n._next = n._prev = null), delete a[r]), h && (s[r] = 1);

          !this._firstPT && this._initted && this._enabled(!1, !1);
        }
      }
      return o;
    }, r.invalidate = function () {
      return this._notifyPluginsOfEnabled && D._onPluginEvent("_onDisable", this), this._firstPT = null, this._overwrittenProps = null, this._onUpdate = null, this._startAt = null, this._initted = this._active = this._notifyPluginsOfEnabled = !1, this._propLookup = this._targets ? {} : [], this;
    }, r._enabled = function (t, e) {
      if (a || n.wake(), t && this._gc) {
        var i,
            s = this._targets;
        if (s) for (i = s.length; --i > -1;) this._siblings[i] = B(s[i], this, !0);else this._siblings = B(this.target, this, !0);
      }

      return x.prototype._enabled.call(this, t, e), this._notifyPluginsOfEnabled && this._firstPT ? D._onPluginEvent(t ? "_onEnable" : "_onDisable", this) : !1;
    }, D.to = function (t, e, i) {
      return new D(t, e, i);
    }, D.from = function (t, e, i) {
      return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new D(t, e, i);
    }, D.fromTo = function (t, e, i, s) {
      return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, new D(t, e, s);
    }, D.delayedCall = function (t, e, i, s, r) {
      return new D(e, 0, {
        delay: t,
        onComplete: e,
        onCompleteParams: i,
        onCompleteScope: s,
        onReverseComplete: e,
        onReverseCompleteParams: i,
        onReverseCompleteScope: s,
        immediateRender: !1,
        useFrames: r,
        overwrite: 0
      });
    }, D.set = function (t, e) {
      return new D(t, 0, e);
    }, D.getTweensOf = function (t, e) {
      if (null == t) return [];
      t = "string" != typeof t ? t : D.selector(t) || t;
      var i, s, r, n;

      if ((m(t) || E(t)) && "number" != typeof t[0]) {
        for (i = t.length, s = []; --i > -1;) s = s.concat(D.getTweensOf(t[i], e));

        for (i = s.length; --i > -1;) for (n = s[i], r = i; --r > -1;) n === s[r] && s.splice(i, 1);
      } else for (s = B(t).concat(), i = s.length; --i > -1;) (s[i]._gc || e && !s[i].isActive()) && s.splice(i, 1);

      return s;
    }, D.killTweensOf = D.killDelayedCallsTo = function (t, e, i) {
      "object" == typeof e && (i = e, e = !1);

      for (var s = D.getTweensOf(t, e), r = s.length; --r > -1;) s[r]._kill(i, t);
    };
    var M = d("plugins.TweenPlugin", function (t, e) {
      this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = M.prototype;
    }, !0);

    if (r = M.prototype, M.version = "1.10.1", M.API = 2, r._firstPT = null, r._addTween = function (t, e, i, s, r, n) {
      var a, o;
      return null != s && (a = "number" == typeof s || "=" !== s.charAt(1) ? Number(s) - i : parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2))) ? (this._firstPT = o = {
        _next: this._firstPT,
        t: t,
        p: e,
        s: i,
        c: a,
        f: "function" == typeof t[e],
        n: r || e,
        r: n
      }, o._next && (o._next._prev = o), o) : void 0;
    }, r.setRatio = function (t) {
      for (var e, i = this._firstPT, s = 1e-6; i;) e = i.c * t + i.s, i.r ? e = 0 | e + (e > 0 ? .5 : -.5) : s > e && e > -s && (e = 0), i.f ? i.t[i.p](e) : i.t[i.p] = e, i = i._next;
    }, r._kill = function (t) {
      var e,
          i = this._overwriteProps,
          s = this._firstPT;
      if (null != t[this._propName]) this._overwriteProps = [];else for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);

      for (; s;) null != t[s.n] && (s._next && (s._next._prev = s._prev), s._prev ? (s._prev._next = s._next, s._prev = null) : this._firstPT === s && (this._firstPT = s._next)), s = s._next;

      return !1;
    }, r._roundProps = function (t, e) {
      for (var i = this._firstPT; i;) (t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && (i.r = e), i = i._next;
    }, D._onPluginEvent = function (t, e) {
      var i,
          s,
          r,
          n,
          a,
          o = e._firstPT;

      if ("_onInitAllProps" === t) {
        for (; o;) {
          for (a = o._next, s = r; s && s.pr > o.pr;) s = s._next;

          (o._prev = s ? s._prev : n) ? o._prev._next = o : r = o, (o._next = s) ? s._prev = o : n = o, o = a;
        }

        o = e._firstPT = r;
      }

      for (; o;) o.pg && "function" == typeof o.t[t] && o.t[t]() && (i = !0), o = o._next;

      return i;
    }, M.activate = function (t) {
      for (var e = t.length; --e > -1;) t[e].API === M.API && (N[new t[e]()._propName] = t[e]);

      return !0;
    }, c.plugin = function (t) {
      if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition.";
      var e,
          i = t.propName,
          s = t.priority || 0,
          r = t.overwriteProps,
          n = {
        init: "_onInitTween",
        set: "setRatio",
        kill: "_kill",
        round: "_roundProps",
        initAll: "_onInitAllProps"
      },
          a = d("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function () {
        M.call(this, i, s), this._overwriteProps = r || [];
      }, t.global === !0),
          o = a.prototype = new M(i);
      o.constructor = a, a.API = t.API;

      for (e in n) "function" == typeof t[e] && (o[n[e]] = t[e]);

      return a.version = t.version, M.activate([a]), a;
    }, i = t._gsQueue) {
      for (s = 0; i.length > s; s++) i[s]();

      for (r in f) f[r].func || t.console.log("GSAP encountered missing dependency: com.greensock." + r);
    }

    a = !1;
  }
})(window);
/*!
 * VERSION: 1.11.5
 * DATE: 2014-02-20
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * @license Copyright (c) 2008-2014, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */


(window._gsQueue || (window._gsQueue = [])).push(function () {
  "use strict";

  window._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) {
    var s = function (t) {
      e.call(this, t), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
      var i,
          s,
          r = this.vars;

      for (s in r) i = r[s], a(i) && -1 !== i.join("").indexOf("{self}") && (r[s] = this._swapSelfInParams(i));

      a(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger);
    },
        r = 1e-10,
        n = i._internals.isSelector,
        a = i._internals.isArray,
        o = [],
        h = function (t) {
      var e,
          i = {};

      for (e in t) i[e] = t[e];

      return i;
    },
        l = function (t, e, i, s) {
      t._timeline.pause(t._startTime), e && e.apply(s || t._timeline, i || o);
    },
        _ = o.slice,
        u = s.prototype = new e();

    return s.version = "1.11.5", u.constructor = s, u.kill()._gc = !1, u.to = function (t, e, s, r) {
      return e ? this.add(new i(t, e, s), r) : this.set(t, s, r);
    }, u.from = function (t, e, s, r) {
      return this.add(i.from(t, e, s), r);
    }, u.fromTo = function (t, e, s, r, n) {
      return e ? this.add(i.fromTo(t, e, s, r), n) : this.set(t, r, n);
    }, u.staggerTo = function (t, e, r, a, o, l, u, p) {
      var f,
          c = new s({
        onComplete: l,
        onCompleteParams: u,
        onCompleteScope: p,
        smoothChildTiming: this.smoothChildTiming
      });

      for ("string" == typeof t && (t = i.selector(t) || t), n(t) && (t = _.call(t, 0)), a = a || 0, f = 0; t.length > f; f++) r.startAt && (r.startAt = h(r.startAt)), c.to(t[f], e, h(r), f * a);

      return this.add(c, o);
    }, u.staggerFrom = function (t, e, i, s, r, n, a, o) {
      return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, s, r, n, a, o);
    }, u.staggerFromTo = function (t, e, i, s, r, n, a, o, h) {
      return s.startAt = i, s.immediateRender = 0 != s.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, s, r, n, a, o, h);
    }, u.call = function (t, e, s, r) {
      return this.add(i.delayedCall(0, t, e, s), r);
    }, u.set = function (t, e, s) {
      return s = this._parseTimeOrLabel(s, 0, !0), null == e.immediateRender && (e.immediateRender = s === this._time && !this._paused), this.add(new i(t, 0, e), s);
    }, s.exportRoot = function (t, e) {
      t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming = !0);
      var r,
          n,
          a = new s(t),
          o = a._timeline;

      for (null == e && (e = !0), o._remove(a, !0), a._startTime = 0, a._rawPrevTime = a._time = a._totalTime = o._time, r = o._first; r;) n = r._next, e && r instanceof i && r.target === r.vars.onComplete || a.add(r, r._startTime - r._delay), r = n;

      return o.add(a, 0), a;
    }, u.add = function (r, n, o, h) {
      var l, _, u, p, f, c;

      if ("number" != typeof n && (n = this._parseTimeOrLabel(n, 0, !0, r)), !(r instanceof t)) {
        if (r instanceof Array || r && r.push && a(r)) {
          for (o = o || "normal", h = h || 0, l = n, _ = r.length, u = 0; _ > u; u++) a(p = r[u]) && (p = new s({
            tweens: p
          })), this.add(p, l), "string" != typeof p && "function" != typeof p && ("sequence" === o ? l = p._startTime + p.totalDuration() / p._timeScale : "start" === o && (p._startTime -= p.delay())), l += h;

          return this._uncache(!0);
        }

        if ("string" == typeof r) return this.addLabel(r, n);
        if ("function" != typeof r) throw "Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
        r = i.delayedCall(0, r);
      }

      if (e.prototype.add.call(this, r, n), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (f = this, c = f.rawTime() > r._startTime; f._timeline;) c && f._timeline.smoothChildTiming ? f.totalTime(f._totalTime, !0) : f._gc && f._enabled(!0, !1), f = f._timeline;
      return this;
    }, u.remove = function (e) {
      if (e instanceof t) return this._remove(e, !1);

      if (e instanceof Array || e && e.push && a(e)) {
        for (var i = e.length; --i > -1;) this.remove(e[i]);

        return this;
      }

      return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e);
    }, u._remove = function (t, i) {
      e.prototype._remove.call(this, t, i);

      var s = this._last;
      return s ? this._time > s._startTime + s._totalDuration / s._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this;
    }, u.append = function (t, e) {
      return this.add(t, this._parseTimeOrLabel(null, e, !0, t));
    }, u.insert = u.insertMultiple = function (t, e, i, s) {
      return this.add(t, e || 0, i, s);
    }, u.appendMultiple = function (t, e, i, s) {
      return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, s);
    }, u.addLabel = function (t, e) {
      return this._labels[t] = this._parseTimeOrLabel(e), this;
    }, u.addPause = function (t, e, i, s) {
      return this.call(l, ["{self}", e, i, s], this, t);
    }, u.removeLabel = function (t) {
      return delete this._labels[t], this;
    }, u.getLabelTime = function (t) {
      return null != this._labels[t] ? this._labels[t] : -1;
    }, u._parseTimeOrLabel = function (e, i, s, r) {
      var n;
      if (r instanceof t && r.timeline === this) this.remove(r);else if (r && (r instanceof Array || r.push && a(r))) for (n = r.length; --n > -1;) r[n] instanceof t && r[n].timeline === this && this.remove(r[n]);
      if ("string" == typeof i) return this._parseTimeOrLabel(i, s && "number" == typeof e && null == this._labels[i] ? e - this.duration() : 0, s);
      if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = this.duration());else {
        if (n = e.indexOf("="), -1 === n) return null == this._labels[e] ? s ? this._labels[e] = this.duration() + i : i : this._labels[e] + i;
        i = parseInt(e.charAt(n - 1) + "1", 10) * Number(e.substr(n + 1)), e = n > 1 ? this._parseTimeOrLabel(e.substr(0, n - 1), 0, s) : this.duration();
      }
      return Number(e) + i;
    }, u.seek = function (t, e) {
      return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), e !== !1);
    }, u.stop = function () {
      return this.paused(!0);
    }, u.gotoAndPlay = function (t, e) {
      return this.play(t, e);
    }, u.gotoAndStop = function (t, e) {
      return this.pause(t, e);
    }, u.render = function (t, e, i) {
      this._gc && this._enabled(!0, !1);

      var s,
          n,
          a,
          h,
          l,
          _ = this._dirty ? this.totalDuration() : this._totalDuration,
          u = this._time,
          p = this._startTime,
          f = this._timeScale,
          c = this._paused;

      if (t >= _ ? (this._totalTime = this._time = _, this._reversed || this._hasPausedChild() || (n = !0, h = "onComplete", 0 === this._duration && (0 === t || 0 > this._rawPrevTime || this._rawPrevTime === r) && this._rawPrevTime !== t && this._first && (l = !0, this._rawPrevTime > r && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || 0 === this._rawPrevTime ? t : r, t = _ + 1e-4) : 1e-7 > t ? (this._totalTime = this._time = 0, (0 !== u || 0 === this._duration && (this._rawPrevTime > r || 0 > t && this._rawPrevTime >= 0)) && (h = "onReverseComplete", n = this._reversed), 0 > t ? (this._active = !1, 0 === this._duration && this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = t) : (this._rawPrevTime = this._duration || !e || t || 0 === this._rawPrevTime ? t : r, t = 0, this._initted || (l = !0))) : this._totalTime = this._time = this._rawPrevTime = t, this._time !== u && this._first || i || l) {
        if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== u && t > 0 && (this._active = !0), 0 === u && this.vars.onStart && 0 !== this._time && (e || this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || o)), this._time >= u) for (s = this._first; s && (a = s._next, !this._paused || c);) (s._active || s._startTime <= this._time && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a;else for (s = this._last; s && (a = s._prev, !this._paused || c);) (s._active || u >= s._startTime && !s._paused && !s._gc) && (s._reversed ? s.render((s._dirty ? s.totalDuration() : s._totalDuration) - (t - s._startTime) * s._timeScale, e, i) : s.render((t - s._startTime) * s._timeScale, e, i)), s = a;
        this._onUpdate && (e || this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || o)), h && (this._gc || (p === this._startTime || f !== this._timeScale) && (0 === this._time || _ >= this.totalDuration()) && (n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[h] && this.vars[h].apply(this.vars[h + "Scope"] || this, this.vars[h + "Params"] || o)));
      }
    }, u._hasPausedChild = function () {
      for (var t = this._first; t;) {
        if (t._paused || t instanceof s && t._hasPausedChild()) return !0;
        t = t._next;
      }

      return !1;
    }, u.getChildren = function (t, e, s, r) {
      r = r || -9999999999;

      for (var n = [], a = this._first, o = 0; a;) r > a._startTime || (a instanceof i ? e !== !1 && (n[o++] = a) : (s !== !1 && (n[o++] = a), t !== !1 && (n = n.concat(a.getChildren(!0, e, s)), o = n.length))), a = a._next;

      return n;
    }, u.getTweensOf = function (t, e) {
      for (var s = i.getTweensOf(t), r = s.length, n = [], a = 0; --r > -1;) (s[r].timeline === this || e && this._contains(s[r])) && (n[a++] = s[r]);

      return n;
    }, u._contains = function (t) {
      for (var e = t.timeline; e;) {
        if (e === this) return !0;
        e = e.timeline;
      }

      return !1;
    }, u.shiftChildren = function (t, e, i) {
      i = i || 0;

      for (var s, r = this._first, n = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;

      if (e) for (s in n) n[s] >= i && (n[s] += t);
      return this._uncache(!0);
    }, u._kill = function (t, e) {
      if (!t && !e) return this._enabled(!1, !1);

      for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), s = i.length, r = !1; --s > -1;) i[s]._kill(t, e) && (r = !0);

      return r;
    }, u.clear = function (t) {
      var e = this.getChildren(!1, !0, !0),
          i = e.length;

      for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);

      return t !== !1 && (this._labels = {}), this._uncache(!0);
    }, u.invalidate = function () {
      for (var t = this._first; t;) t.invalidate(), t = t._next;

      return this;
    }, u._enabled = function (t, i) {
      if (t === this._gc) for (var s = this._first; s;) s._enabled(t, !0), s = s._next;
      return e.prototype._enabled.call(this, t, i);
    }, u.duration = function (t) {
      return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration);
    }, u.totalDuration = function (t) {
      if (!arguments.length) {
        if (this._dirty) {
          for (var e, i, s = 0, r = this._last, n = 999999999999; r;) e = r._prev, r._dirty && r.totalDuration(), r._startTime > n && this._sortChildren && !r._paused ? this.add(r, r._startTime - r._delay) : n = r._startTime, 0 > r._startTime && !r._paused && (s -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale), this.shiftChildren(-r._startTime, !1, -9999999999), n = 0), i = r._startTime + r._totalDuration / r._timeScale, i > s && (s = i), r = e;

          this._duration = this._totalDuration = s, this._dirty = !1;
        }

        return this._totalDuration;
      }

      return 0 !== this.totalDuration() && 0 !== t && this.timeScale(this._totalDuration / t), this;
    }, u.usesFrames = function () {
      for (var e = this._timeline; e._timeline;) e = e._timeline;

      return e === t._rootFramesTimeline;
    }, u.rawTime = function () {
      return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
    }, s;
  }, !0);
}), window._gsDefine && window._gsQueue.pop()();
/*!
 * VERSION: beta 1.9.3
 * DATE: 2013-04-02
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * @license Copyright (c) 2008-2014, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/

(window._gsQueue || (window._gsQueue = [])).push(function () {
  "use strict";

  window._gsDefine("easing.Back", ["easing.Ease"], function (t) {
    var e,
        i,
        s,
        r = window.GreenSockGlobals || window,
        n = r.com.greensock,
        a = 2 * Math.PI,
        o = Math.PI / 2,
        h = n._class,
        l = function (e, i) {
      var s = h("easing." + e, function () {}, !0),
          r = s.prototype = new t();
      return r.constructor = s, r.getRatio = i, s;
    },
        _ = t.register || function () {},
        u = function (t, e, i, s) {
      var r = h("easing." + t, {
        easeOut: new e(),
        easeIn: new i(),
        easeInOut: new s()
      }, !0);
      return _(r, t), r;
    },
        c = function (t, e, i) {
      this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t);
    },
        p = function (e, i) {
      var s = h("easing." + e, function (t) {
        this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1;
      }, !0),
          r = s.prototype = new t();
      return r.constructor = s, r.getRatio = i, r.config = function (t) {
        return new s(t);
      }, s;
    },
        f = u("Back", p("BackOut", function (t) {
      return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1;
    }), p("BackIn", function (t) {
      return t * t * ((this._p1 + 1) * t - this._p1);
    }), p("BackInOut", function (t) {
      return 1 > (t *= 2) ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2);
    })),
        m = h("easing.SlowMo", function (t, e, i) {
      e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0;
    }, !0),
        d = m.prototype = new t();

    return d.constructor = m, d.getRatio = function (t) {
      var e = t + (.5 - t) * this._p;
      return this._p1 > t ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e;
    }, m.ease = new m(.7, .7), d.config = m.config = function (t, e, i) {
      return new m(t, e, i);
    }, e = h("easing.SteppedEase", function (t) {
      t = t || 1, this._p1 = 1 / t, this._p2 = t + 1;
    }, !0), d = e.prototype = new t(), d.constructor = e, d.getRatio = function (t) {
      return 0 > t ? t = 0 : t >= 1 && (t = .999999999), (this._p2 * t >> 0) * this._p1;
    }, d.config = e.config = function (t) {
      return new e(t);
    }, i = h("easing.RoughEase", function (e) {
      e = e || {};

      for (var i, s, r, n, a, o, h = e.taper || "none", l = [], _ = 0, u = 0 | (e.points || 20), p = u, f = e.randomize !== !1, m = e.clamp === !0, d = e.template instanceof t ? e.template : null, g = "number" == typeof e.strength ? .4 * e.strength : .4; --p > -1;) i = f ? Math.random() : 1 / u * p, s = d ? d.getRatio(i) : i, "none" === h ? r = g : "out" === h ? (n = 1 - i, r = n * n * g) : "in" === h ? r = i * i * g : .5 > i ? (n = 2 * i, r = .5 * n * n * g) : (n = 2 * (1 - i), r = .5 * n * n * g), f ? s += Math.random() * r - .5 * r : p % 2 ? s += .5 * r : s -= .5 * r, m && (s > 1 ? s = 1 : 0 > s && (s = 0)), l[_++] = {
        x: i,
        y: s
      };

      for (l.sort(function (t, e) {
        return t.x - e.x;
      }), o = new c(1, 1, null), p = u; --p > -1;) a = l[p], o = new c(a.x, a.y, o);

      this._prev = new c(0, 0, 0 !== o.t ? o : o.next);
    }, !0), d = i.prototype = new t(), d.constructor = i, d.getRatio = function (t) {
      var e = this._prev;

      if (t > e.t) {
        for (; e.next && t >= e.t;) e = e.next;

        e = e.prev;
      } else for (; e.prev && e.t >= t;) e = e.prev;

      return this._prev = e, e.v + (t - e.t) / e.gap * e.c;
    }, d.config = function (t) {
      return new i(t);
    }, i.ease = new i(), u("Bounce", l("BounceOut", function (t) {
      return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }), l("BounceIn", function (t) {
      return 1 / 2.75 > (t = 1 - t) ? 1 - 7.5625 * t * t : 2 / 2.75 > t ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375);
    }), l("BounceInOut", function (t) {
      var e = .5 > t;
      return t = e ? 1 - 2 * t : 2 * t - 1, t = 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5;
    })), u("Circ", l("CircOut", function (t) {
      return Math.sqrt(1 - (t -= 1) * t);
    }), l("CircIn", function (t) {
      return -(Math.sqrt(1 - t * t) - 1);
    }), l("CircInOut", function (t) {
      return 1 > (t *= 2) ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    })), s = function (e, i, s) {
      var r = h("easing." + e, function (t, e) {
        this._p1 = t || 1, this._p2 = e || s, this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0);
      }, !0),
          n = r.prototype = new t();
      return n.constructor = r, n.getRatio = i, n.config = function (t, e) {
        return new r(t, e);
      }, r;
    }, u("Elastic", s("ElasticOut", function (t) {
      return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * a / this._p2) + 1;
    }, .3), s("ElasticIn", function (t) {
      return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2));
    }, .3), s("ElasticInOut", function (t) {
      return 1 > (t *= 2) ? -.5 * this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) : .5 * this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * a / this._p2) + 1;
    }, .45)), u("Expo", l("ExpoOut", function (t) {
      return 1 - Math.pow(2, -10 * t);
    }), l("ExpoIn", function (t) {
      return Math.pow(2, 10 * (t - 1)) - .001;
    }), l("ExpoInOut", function (t) {
      return 1 > (t *= 2) ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)));
    })), u("Sine", l("SineOut", function (t) {
      return Math.sin(t * o);
    }), l("SineIn", function (t) {
      return -Math.cos(t * o) + 1;
    }), l("SineInOut", function (t) {
      return -.5 * (Math.cos(Math.PI * t) - 1);
    })), h("easing.EaseLookup", {
      find: function (e) {
        return t.map[e];
      }
    }, !0), _(r.SlowMo, "SlowMo", "ease,"), _(i, "RoughEase", "ease,"), _(e, "SteppedEase", "ease,"), f;
  }, !0);
}), window._gsDefine && window._gsQueue.pop()();
/*!
 * VERSION: 1.11.5
 * DATE: 2014-02-20
 * UPDATES AND DOCS AT: http://www.greensock.com
 *
 * @license Copyright (c) 2008-2014, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */

(window._gsQueue || (window._gsQueue = [])).push(function () {
  "use strict";

  window._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (t, e) {
    var i,
        r,
        s,
        n,
        a = function () {
      t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = a.prototype.setRatio;
    },
        o = {},
        l = a.prototype = new t("css");

    l.constructor = a, a.version = "1.11.5", a.API = 2, a.defaultTransformPerspective = 0, l = "px", a.suffixMap = {
      top: l,
      right: l,
      bottom: l,
      left: l,
      width: l,
      height: l,
      fontSize: l,
      padding: l,
      margin: l,
      perspective: l,
      lineHeight: ""
    };

    var h,
        u,
        _,
        p,
        f,
        c,
        d = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
        m = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
        g = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
        v = /[^\d\-\.]/g,
        y = /(?:\d|\-|\+|=|#|\.)*/g,
        T = /opacity *= *([^)]*)/,
        x = /opacity:([^;]*)/,
        w = /alpha\(opacity *=.+?\)/i,
        b = /^(rgb|hsl)/,
        P = /([A-Z])/g,
        S = /-([a-z])/gi,
        R = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
        k = function (t, e) {
      return e.toUpperCase();
    },
        C = /(?:Left|Right|Width)/i,
        A = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
        O = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
        D = /,(?=[^\)]*(?:\(|$))/gi,
        M = Math.PI / 180,
        L = 180 / Math.PI,
        N = {},
        X = document,
        I = X.createElement("div"),
        E = X.createElement("img"),
        F = a._internals = {
      _specialProps: o
    },
        Y = navigator.userAgent,
        z = function () {
      var t,
          e = Y.indexOf("Android"),
          i = X.createElement("div");
      return _ = -1 !== Y.indexOf("Safari") && -1 === Y.indexOf("Chrome") && (-1 === e || Number(Y.substr(e + 8, 1)) > 3), f = _ && 6 > Number(Y.substr(Y.indexOf("Version/") + 8, 1)), p = -1 !== Y.indexOf("Firefox"), /MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(Y) && (c = parseFloat(RegExp.$1)), i.innerHTML = "<a style='top:1px;opacity:.55;'>a</a>", t = i.getElementsByTagName("a")[0], t ? /^0.55/.test(t.style.opacity) : !1;
    }(),
        U = function (t) {
      return T.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
    },
        B = function (t) {
      window.console && console.log(t);
    },
        j = "",
        W = "",
        V = function (t, e) {
      e = e || I;
      var i,
          r,
          s = e.style;
      if (void 0 !== s[t]) return t;

      for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], r = 5; --r > -1 && void 0 === s[i[r] + t];);

      return r >= 0 ? (W = 3 === r ? "ms" : i[r], j = "-" + W.toLowerCase() + "-", W + t) : null;
    },
        q = X.defaultView ? X.defaultView.getComputedStyle : function () {},
        H = a.getStyle = function (t, e, i, r, s) {
      var n;
      return z || "opacity" !== e ? (!r && t.style[e] ? n = t.style[e] : (i = i || q(t, null)) ? (t = i.getPropertyValue(e.replace(P, "-$1").toLowerCase()), n = t || i.length ? t : i[e]) : t.currentStyle && (n = t.currentStyle[e]), null == s || n && "none" !== n && "auto" !== n && "auto auto" !== n ? n : s) : U(t);
    },
        Q = function (t, e, i, r, s) {
      if ("px" === r || !r) return i;
      if ("auto" === r || !i) return 0;
      var n,
          a = C.test(e),
          o = t,
          l = I.style,
          h = 0 > i;
      return h && (i = -i), "%" === r && -1 !== e.indexOf("border") ? n = i / 100 * (a ? t.clientWidth : t.clientHeight) : (l.cssText = "border:0 solid red;position:" + H(t, "position") + ";line-height:0;", "%" !== r && o.appendChild ? l[a ? "borderLeftWidth" : "borderTopWidth"] = i + r : (o = t.parentNode || X.body, l[a ? "width" : "height"] = i + r), o.appendChild(I), n = parseFloat(I[a ? "offsetWidth" : "offsetHeight"]), o.removeChild(I), 0 !== n || s || (n = Q(t, e, i, r, !0))), h ? -n : n;
    },
        Z = function (t, e, i) {
      if ("absolute" !== H(t, "position", i)) return 0;
      var r = "left" === e ? "Left" : "Top",
          s = H(t, "margin" + r, i);
      return t["offset" + r] - (Q(t, e, parseFloat(s), s.replace(y, "")) || 0);
    },
        $ = function (t, e) {
      var i,
          r,
          s = {};
      if (e = e || q(t, null)) {
        if (i = e.length) for (; --i > -1;) s[e[i].replace(S, k)] = e.getPropertyValue(e[i]);else for (i in e) s[i] = e[i];
      } else if (e = t.currentStyle || t.style) for (i in e) "string" == typeof i && void 0 === s[i] && (s[i.replace(S, k)] = e[i]);
      return z || (s.opacity = U(t)), r = be(t, e, !1), s.rotation = r.rotation, s.skewX = r.skewX, s.scaleX = r.scaleX, s.scaleY = r.scaleY, s.x = r.x, s.y = r.y, we && (s.z = r.z, s.rotationX = r.rotationX, s.rotationY = r.rotationY, s.scaleZ = r.scaleZ), s.filters && delete s.filters, s;
    },
        G = function (t, e, i, r, s) {
      var n,
          a,
          o,
          l = {},
          h = t.style;

      for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (e[a] !== (n = i[a]) || s && s[a]) && -1 === a.indexOf("Origin") && ("number" == typeof n || "string" == typeof n) && (l[a] = "auto" !== n || "left" !== a && "top" !== a ? "" !== n && "auto" !== n && "none" !== n || "string" != typeof e[a] || "" === e[a].replace(v, "") ? n : 0 : Z(t, a), void 0 !== h[a] && (o = new _e(h, a, h[a], o)));

      if (r) for (a in r) "className" !== a && (l[a] = r[a]);
      return {
        difs: l,
        firstMPT: o
      };
    },
        K = {
      width: ["Left", "Right"],
      height: ["Top", "Bottom"]
    },
        J = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
        te = function (t, e, i) {
      var r = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
          s = K[e],
          n = s.length;

      for (i = i || q(t, null); --n > -1;) r -= parseFloat(H(t, "padding" + s[n], i, !0)) || 0, r -= parseFloat(H(t, "border" + s[n] + "Width", i, !0)) || 0;

      return r;
    },
        ee = function (t, e) {
      (null == t || "" === t || "auto" === t || "auto auto" === t) && (t = "0 0");
      var i = t.split(" "),
          r = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : i[0],
          s = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : i[1];
      return null == s ? s = "0" : "center" === s && (s = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), e && (e.oxp = -1 !== r.indexOf("%"), e.oyp = -1 !== s.indexOf("%"), e.oxr = "=" === r.charAt(1), e.oyr = "=" === s.charAt(1), e.ox = parseFloat(r.replace(v, "")), e.oy = parseFloat(s.replace(v, ""))), r + " " + s + (i.length > 2 ? " " + i[2] : "");
    },
        ie = function (t, e) {
      return "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e);
    },
        re = function (t, e) {
      return null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * Number(t.substr(2)) + e : parseFloat(t);
    },
        se = function (t, e, i, r) {
      var s,
          n,
          a,
          o,
          l = 1e-6;
      return null == t ? o = e : "number" == typeof t ? o = t : (s = 360, n = t.split("_"), a = Number(n[0].replace(v, "")) * (-1 === t.indexOf("rad") ? 1 : L) - ("=" === t.charAt(1) ? 0 : e), n.length && (r && (r[i] = e + a), -1 !== t.indexOf("short") && (a %= s, a !== a % (s / 2) && (a = 0 > a ? a + s : a - s)), -1 !== t.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * s) % s - (0 | a / s) * s : -1 !== t.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * s) % s - (0 | a / s) * s)), o = e + a), l > o && o > -l && (o = 0), o;
    },
        ne = {
      aqua: [0, 255, 255],
      lime: [0, 255, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, 255],
      navy: [0, 0, 128],
      white: [255, 255, 255],
      fuchsia: [255, 0, 255],
      olive: [128, 128, 0],
      yellow: [255, 255, 0],
      orange: [255, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [255, 0, 0],
      pink: [255, 192, 203],
      cyan: [0, 255, 255],
      transparent: [255, 255, 255, 0]
    },
        ae = function (t, e, i) {
      return t = 0 > t ? t + 1 : t > 1 ? t - 1 : t, 0 | 255 * (1 > 6 * t ? e + 6 * (i - e) * t : .5 > t ? i : 2 > 3 * t ? e + 6 * (i - e) * (2 / 3 - t) : e) + .5;
    },
        oe = function (t) {
      var e, i, r, s, n, a;
      return t && "" !== t ? "number" == typeof t ? [t >> 16, 255 & t >> 8, 255 & t] : ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), ne[t] ? ne[t] : "#" === t.charAt(0) ? (4 === t.length && (e = t.charAt(1), i = t.charAt(2), r = t.charAt(3), t = "#" + e + e + i + i + r + r), t = parseInt(t.substr(1), 16), [t >> 16, 255 & t >> 8, 255 & t]) : "hsl" === t.substr(0, 3) ? (t = t.match(d), s = Number(t[0]) % 360 / 360, n = Number(t[1]) / 100, a = Number(t[2]) / 100, i = .5 >= a ? a * (n + 1) : a + n - a * n, e = 2 * a - i, t.length > 3 && (t[3] = Number(t[3])), t[0] = ae(s + 1 / 3, e, i), t[1] = ae(s, e, i), t[2] = ae(s - 1 / 3, e, i), t) : (t = t.match(d) || ne.transparent, t[0] = Number(t[0]), t[1] = Number(t[1]), t[2] = Number(t[2]), t.length > 3 && (t[3] = Number(t[3])), t)) : ne.black;
    },
        le = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b";

    for (l in ne) le += "|" + l + "\\b";

    le = RegExp(le + ")", "gi");

    var he = function (t, e, i, r) {
      if (null == t) return function (t) {
        return t;
      };

      var s,
          n = e ? (t.match(le) || [""])[0] : "",
          a = t.split(n).join("").match(g) || [],
          o = t.substr(0, t.indexOf(a[0])),
          l = ")" === t.charAt(t.length - 1) ? ")" : "",
          h = -1 !== t.indexOf(" ") ? " " : ",",
          u = a.length,
          _ = u > 0 ? a[0].replace(d, "") : "";

      return u ? s = e ? function (t) {
        var e, p, f, c;
        if ("number" == typeof t) t += _;else if (r && D.test(t)) {
          for (c = t.replace(D, "|").split("|"), f = 0; c.length > f; f++) c[f] = s(c[f]);

          return c.join(",");
        }
        if (e = (t.match(le) || [n])[0], p = t.split(e).join("").match(g) || [], f = p.length, u > f--) for (; u > ++f;) p[f] = i ? p[0 | (f - 1) / 2] : a[f];
        return o + p.join(h) + h + e + l + (-1 !== t.indexOf("inset") ? " inset" : "");
      } : function (t) {
        var e, n, p;
        if ("number" == typeof t) t += _;else if (r && D.test(t)) {
          for (n = t.replace(D, "|").split("|"), p = 0; n.length > p; p++) n[p] = s(n[p]);

          return n.join(",");
        }
        if (e = t.match(g) || [], p = e.length, u > p--) for (; u > ++p;) e[p] = i ? e[0 | (p - 1) / 2] : a[p];
        return o + e.join(h) + l;
      } : function (t) {
        return t;
      };
    },
        ue = function (t) {
      return t = t.split(","), function (e, i, r, s, n, a, o) {
        var l,
            h = (i + "").split(" ");

        for (o = {}, l = 0; 4 > l; l++) o[t[l]] = h[l] = h[l] || h[(l - 1) / 2 >> 0];

        return s.parse(e, o, n, a);
      };
    },
        _e = (F._setPluginRatio = function (t) {
      this.plugin.setRatio(t);

      for (var e, i, r, s, n = this.data, a = n.proxy, o = n.firstMPT, l = 1e-6; o;) e = a[o.v], o.r ? e = e > 0 ? 0 | e + .5 : 0 | e - .5 : l > e && e > -l && (e = 0), o.t[o.p] = e, o = o._next;

      if (n.autoRotate && (n.autoRotate.rotation = a.rotation), 1 === t) for (o = n.firstMPT; o;) {
        if (i = o.t, i.type) {
          if (1 === i.type) {
            for (s = i.xs0 + i.s + i.xs1, r = 1; i.l > r; r++) s += i["xn" + r] + i["xs" + (r + 1)];

            i.e = s;
          }
        } else i.e = i.s + i.xs0;

        o = o._next;
      }
    }, function (t, e, i, r, s) {
      this.t = t, this.p = e, this.v = i, this.r = s, r && (r._prev = this, this._next = r);
    }),
        pe = (F._parseToProxy = function (t, e, i, r, s, n) {
      var a,
          o,
          l,
          h,
          u,
          _ = r,
          p = {},
          f = {},
          c = i._transform,
          d = N;

      for (i._transform = null, N = e, r = u = i.parse(t, e, r, s), N = d, n && (i._transform = c, _ && (_._prev = null, _._prev && (_._prev._next = null))); r && r !== _;) {
        if (1 >= r.type && (o = r.p, f[o] = r.s + r.c, p[o] = r.s, n || (h = new _e(r, "s", o, h, r.r), r.c = 0), 1 === r.type)) for (a = r.l; --a > 0;) l = "xn" + a, o = r.p + "_" + l, f[o] = r.data[l], p[o] = r[l], n || (h = new _e(r, l, o, h, r.rxp[l]));
        r = r._next;
      }

      return {
        proxy: p,
        end: f,
        firstMPT: h,
        pt: u
      };
    }, F.CSSPropTween = function (t, e, r, s, a, o, l, h, u, _, p) {
      this.t = t, this.p = e, this.s = r, this.c = s, this.n = l || e, t instanceof pe || n.push(this.n), this.r = h, this.type = o || 0, u && (this.pr = u, i = !0), this.b = void 0 === _ ? r : _, this.e = void 0 === p ? r + s : p, a && (this._next = a, a._prev = this);
    }),
        fe = a.parseComplex = function (t, e, i, r, s, n, a, o, l, u) {
      i = i || n || "", a = new pe(t, e, 0, 0, a, u ? 2 : 1, null, !1, o, i, r), r += "";

      var _,
          p,
          f,
          c,
          g,
          v,
          y,
          T,
          x,
          w,
          P,
          S,
          R = i.split(", ").join(",").split(" "),
          k = r.split(", ").join(",").split(" "),
          C = R.length,
          A = h !== !1;

      for ((-1 !== r.indexOf(",") || -1 !== i.indexOf(",")) && (R = R.join(" ").replace(D, ", ").split(" "), k = k.join(" ").replace(D, ", ").split(" "), C = R.length), C !== k.length && (R = (n || "").split(" "), C = R.length), a.plugin = l, a.setRatio = u, _ = 0; C > _; _++) if (c = R[_], g = k[_], T = parseFloat(c), T || 0 === T) a.appendXtra("", T, ie(g, T), g.replace(m, ""), A && -1 !== g.indexOf("px"), !0);else if (s && ("#" === c.charAt(0) || ne[c] || b.test(c))) S = "," === g.charAt(g.length - 1) ? ")," : ")", c = oe(c), g = oe(g), x = c.length + g.length > 6, x && !z && 0 === g[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(k[_]).join("transparent")) : (z || (x = !1), a.appendXtra(x ? "rgba(" : "rgb(", c[0], g[0] - c[0], ",", !0, !0).appendXtra("", c[1], g[1] - c[1], ",", !0).appendXtra("", c[2], g[2] - c[2], x ? "," : S, !0), x && (c = 4 > c.length ? 1 : c[3], a.appendXtra("", c, (4 > g.length ? 1 : g[3]) - c, S, !1)));else if (v = c.match(d)) {
        if (y = g.match(m), !y || y.length !== v.length) return a;

        for (f = 0, p = 0; v.length > p; p++) P = v[p], w = c.indexOf(P, f), a.appendXtra(c.substr(f, w - f), Number(P), ie(y[p], P), "", A && "px" === c.substr(w + P.length, 2), 0 === p), f = w + P.length;

        a["xs" + a.l] += c.substr(f);
      } else a["xs" + a.l] += a.l ? " " + c : c;

      if (-1 !== r.indexOf("=") && a.data) {
        for (S = a.xs0 + a.data.s, _ = 1; a.l > _; _++) S += a["xs" + _] + a.data["xn" + _];

        a.e = S + a["xs" + _];
      }

      return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a;
    },
        ce = 9;

    for (l = pe.prototype, l.l = l.pr = 0; --ce > 0;) l["xn" + ce] = 0, l["xs" + ce] = "";

    l.xs0 = "", l._next = l._prev = l.xfirst = l.data = l.plugin = l.setRatio = l.rxp = null, l.appendXtra = function (t, e, i, r, s, n) {
      var a = this,
          o = a.l;
      return a["xs" + o] += n && o ? " " + t : t || "", i || 0 === o || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = r || "", o > 0 ? (a.data["xn" + o] = e + i, a.rxp["xn" + o] = s, a["xn" + o] = e, a.plugin || (a.xfirst = new pe(a, "xn" + o, e, i, a.xfirst || a, 0, a.n, s, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
        s: e + i
      }, a.rxp = {}, a.s = e, a.c = i, a.r = s, a)) : (a["xs" + o] += e + (r || ""), a);
    };

    var de = function (t, e) {
      e = e || {}, this.p = e.prefix ? V(t) || t : t, o[t] = o[this.p] = this, this.format = e.formatter || he(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0;
    },
        me = F._registerComplexSpecialProp = function (t, e, i) {
      "object" != typeof e && (e = {
        parser: i
      });
      var r,
          s,
          n = t.split(","),
          a = e.defaultValue;

      for (i = i || [a], r = 0; n.length > r; r++) e.prefix = 0 === r && e.prefix, e.defaultValue = i[r] || a, s = new de(n[r], e);
    },
        ge = function (t) {
      if (!o[t]) {
        var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
        me(t, {
          parser: function (t, i, r, s, n, a, l) {
            var h = (window.GreenSockGlobals || window).com.greensock.plugins[e];
            return h ? (h._cssRegister(), o[r].parse(t, i, r, s, n, a, l)) : (B("Error: " + e + " js file not loaded."), n);
          }
        });
      }
    };

    l = de.prototype, l.parseComplex = function (t, e, i, r, s, n) {
      var a,
          o,
          l,
          h,
          u,
          _,
          p = this.keyword;

      if (this.multi && (D.test(i) || D.test(e) ? (o = e.replace(D, "|").split("|"), l = i.replace(D, "|").split("|")) : p && (o = [e], l = [i])), l) {
        for (h = l.length > o.length ? l.length : o.length, a = 0; h > a; a++) e = o[a] = o[a] || this.dflt, i = l[a] = l[a] || this.dflt, p && (u = e.indexOf(p), _ = i.indexOf(p), u !== _ && (i = -1 === _ ? l : o, i[a] += " " + p));

        e = o.join(", "), i = l.join(", ");
      }

      return fe(t, this.p, e, i, this.clrs, this.dflt, r, this.pr, s, n);
    }, l.parse = function (t, e, i, r, n, a) {
      return this.parseComplex(t.style, this.format(H(t, this.p, s, !1, this.dflt)), this.format(e), n, a);
    }, a.registerSpecialProp = function (t, e, i) {
      me(t, {
        parser: function (t, r, s, n, a, o) {
          var l = new pe(t, s, 0, 0, a, 2, s, !1, i);
          return l.plugin = o, l.setRatio = e(t, r, n._tween, s), l;
        },
        priority: i
      });
    };

    var ve = "scaleX,scaleY,scaleZ,x,y,z,skewX,rotation,rotationX,rotationY,perspective".split(","),
        ye = V("transform"),
        Te = j + "transform",
        xe = V("transformOrigin"),
        we = null !== V("perspective"),
        be = function (t, e, i, r) {
      if (t._gsTransform && i && !r) return t._gsTransform;

      var s,
          n,
          o,
          l,
          h,
          u,
          _,
          p,
          f,
          c,
          d,
          m,
          g,
          v = i ? t._gsTransform || {
        skewY: 0
      } : {
        skewY: 0
      },
          y = 0 > v.scaleX,
          T = 2e-5,
          x = 1e5,
          w = 179.99,
          b = w * M,
          P = we ? parseFloat(H(t, xe, e, !1, "0 0 0").split(" ")[2]) || v.zOrigin || 0 : 0;

      for (ye ? s = H(t, Te, e, !0) : t.currentStyle && (s = t.currentStyle.filter.match(A), s = s && 4 === s.length ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), v.x || 0, v.y || 0].join(",") : ""), n = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], o = n.length; --o > -1;) l = Number(n[o]), n[o] = (h = l - (l |= 0)) ? (0 | h * x + (0 > h ? -.5 : .5)) / x + l : l;

      if (16 === n.length) {
        var S = n[8],
            R = n[9],
            k = n[10],
            C = n[12],
            O = n[13],
            D = n[14];

        if (v.zOrigin && (D = -v.zOrigin, C = S * D - n[12], O = R * D - n[13], D = k * D + v.zOrigin - n[14]), !i || r || null == v.rotationX) {
          var N,
              X,
              I,
              E,
              F,
              Y,
              z,
              U = n[0],
              B = n[1],
              j = n[2],
              W = n[3],
              V = n[4],
              q = n[5],
              Q = n[6],
              Z = n[7],
              $ = n[11],
              G = Math.atan2(Q, k),
              K = -b > G || G > b;
          v.rotationX = G * L, G && (E = Math.cos(-G), F = Math.sin(-G), N = V * E + S * F, X = q * E + R * F, I = Q * E + k * F, S = V * -F + S * E, R = q * -F + R * E, k = Q * -F + k * E, $ = Z * -F + $ * E, V = N, q = X, Q = I), G = Math.atan2(S, U), v.rotationY = G * L, G && (Y = -b > G || G > b, E = Math.cos(-G), F = Math.sin(-G), N = U * E - S * F, X = B * E - R * F, I = j * E - k * F, R = B * F + R * E, k = j * F + k * E, $ = W * F + $ * E, U = N, B = X, j = I), G = Math.atan2(B, q), v.rotation = G * L, G && (z = -b > G || G > b, E = Math.cos(-G), F = Math.sin(-G), U = U * E + V * F, X = B * E + q * F, q = B * -F + q * E, Q = j * -F + Q * E, B = X), z && K ? v.rotation = v.rotationX = 0 : z && Y ? v.rotation = v.rotationY = 0 : Y && K && (v.rotationY = v.rotationX = 0), v.scaleX = (0 | Math.sqrt(U * U + B * B) * x + .5) / x, v.scaleY = (0 | Math.sqrt(q * q + R * R) * x + .5) / x, v.scaleZ = (0 | Math.sqrt(Q * Q + k * k) * x + .5) / x, v.skewX = 0, v.perspective = $ ? 1 / (0 > $ ? -$ : $) : 0, v.x = C, v.y = O, v.z = D;
        }
      } else if (!(we && !r && n.length && v.x === n[4] && v.y === n[5] && (v.rotationX || v.rotationY) || void 0 !== v.x && "none" === H(t, "display", e))) {
        var J = n.length >= 6,
            te = J ? n[0] : 1,
            ee = n[1] || 0,
            ie = n[2] || 0,
            re = J ? n[3] : 1;
        v.x = n[4] || 0, v.y = n[5] || 0, u = Math.sqrt(te * te + ee * ee), _ = Math.sqrt(re * re + ie * ie), p = te || ee ? Math.atan2(ee, te) * L : v.rotation || 0, f = ie || re ? Math.atan2(ie, re) * L + p : v.skewX || 0, c = u - Math.abs(v.scaleX || 0), d = _ - Math.abs(v.scaleY || 0), Math.abs(f) > 90 && 270 > Math.abs(f) && (y ? (u *= -1, f += 0 >= p ? 180 : -180, p += 0 >= p ? 180 : -180) : (_ *= -1, f += 0 >= f ? 180 : -180)), m = (p - v.rotation) % 180, g = (f - v.skewX) % 180, (void 0 === v.skewX || c > T || -T > c || d > T || -T > d || m > -w && w > m && false | m * x || g > -w && w > g && false | g * x) && (v.scaleX = u, v.scaleY = _, v.rotation = p, v.skewX = f), we && (v.rotationX = v.rotationY = v.z = 0, v.perspective = parseFloat(a.defaultTransformPerspective) || 0, v.scaleZ = 1);
      }

      v.zOrigin = P;

      for (o in v) T > v[o] && v[o] > -T && (v[o] = 0);

      return i && (t._gsTransform = v), v;
    },
        Pe = function (t) {
      var e,
          i,
          r = this.data,
          s = -r.rotation * M,
          n = s + r.skewX * M,
          a = 1e5,
          o = (0 | Math.cos(s) * r.scaleX * a) / a,
          l = (0 | Math.sin(s) * r.scaleX * a) / a,
          h = (0 | Math.sin(n) * -r.scaleY * a) / a,
          u = (0 | Math.cos(n) * r.scaleY * a) / a,
          _ = this.t.style,
          p = this.t.currentStyle;

      if (p) {
        i = l, l = -h, h = -i, e = p.filter, _.filter = "";
        var f,
            d,
            m = this.t.offsetWidth,
            g = this.t.offsetHeight,
            v = "absolute" !== p.position,
            x = "progid:DXImageTransform.Microsoft.Matrix(M11=" + o + ", M12=" + l + ", M21=" + h + ", M22=" + u,
            w = r.x,
            b = r.y;

        if (null != r.ox && (f = (r.oxp ? .01 * m * r.ox : r.ox) - m / 2, d = (r.oyp ? .01 * g * r.oy : r.oy) - g / 2, w += f - (f * o + d * l), b += d - (f * h + d * u)), v ? (f = m / 2, d = g / 2, x += ", Dx=" + (f - (f * o + d * l) + w) + ", Dy=" + (d - (f * h + d * u) + b) + ")") : x += ", sizingMethod='auto expand')", _.filter = -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? e.replace(O, x) : x + " " + e, (0 === t || 1 === t) && 1 === o && 0 === l && 0 === h && 1 === u && (v && -1 === x.indexOf("Dx=0, Dy=0") || T.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf("gradient(" && e.indexOf("Alpha")) && _.removeAttribute("filter")), !v) {
          var P,
              S,
              R,
              k = 8 > c ? 1 : -1;

          for (f = r.ieOffsetX || 0, d = r.ieOffsetY || 0, r.ieOffsetX = Math.round((m - ((0 > o ? -o : o) * m + (0 > l ? -l : l) * g)) / 2 + w), r.ieOffsetY = Math.round((g - ((0 > u ? -u : u) * g + (0 > h ? -h : h) * m)) / 2 + b), ce = 0; 4 > ce; ce++) S = J[ce], P = p[S], i = -1 !== P.indexOf("px") ? parseFloat(P) : Q(this.t, S, parseFloat(P), P.replace(y, "")) || 0, R = i !== r[S] ? 2 > ce ? -r.ieOffsetX : -r.ieOffsetY : 2 > ce ? f - r.ieOffsetX : d - r.ieOffsetY, _[S] = (r[S] = Math.round(i - R * (0 === ce || 2 === ce ? 1 : k))) + "px";
        }
      }
    },
        Se = function () {
      var t,
          e,
          i,
          r,
          s,
          n,
          a,
          o,
          l,
          h,
          u,
          _,
          f,
          c,
          d,
          m,
          g,
          v,
          y,
          T,
          x,
          w,
          b,
          P = this.data,
          S = this.t.style,
          R = P.rotation * M,
          k = P.scaleX,
          C = P.scaleY,
          A = P.scaleZ,
          O = P.perspective;

      if (p) {
        var D = 1e-4;
        D > k && k > -D && (k = A = 2e-5), D > C && C > -D && (C = A = 2e-5), !O || P.z || P.rotationX || P.rotationY || (O = 0);
      }

      if (R || P.skewX) v = Math.cos(R), y = Math.sin(R), t = v, s = y, P.skewX && (R -= P.skewX * M, v = Math.cos(R), y = Math.sin(R)), e = -y, n = v;else {
        if (!(P.rotationY || P.rotationX || 1 !== A || O)) return S[ye] = "translate3d(" + P.x + "px," + P.y + "px," + P.z + "px)" + (1 !== k || 1 !== C ? " scale(" + k + "," + C + ")" : ""), void 0;
        t = n = 1, e = s = 0;
      }
      u = 1, i = r = a = o = l = h = _ = f = c = 0, d = O ? -1 / O : 0, m = P.zOrigin, g = 1e5, R = P.rotationY * M, R && (v = Math.cos(R), y = Math.sin(R), l = u * -y, f = d * -y, i = t * y, a = s * y, u *= v, d *= v, t *= v, s *= v), R = P.rotationX * M, R && (v = Math.cos(R), y = Math.sin(R), T = e * v + i * y, x = n * v + a * y, w = h * v + u * y, b = c * v + d * y, i = e * -y + i * v, a = n * -y + a * v, u = h * -y + u * v, d = c * -y + d * v, e = T, n = x, h = w, c = b), 1 !== A && (i *= A, a *= A, u *= A, d *= A), 1 !== C && (e *= C, n *= C, h *= C, c *= C), 1 !== k && (t *= k, s *= k, l *= k, f *= k), m && (_ -= m, r = i * _, o = a * _, _ = u * _ + m), r = (T = (r += P.x) - (r |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + r : r, o = (T = (o += P.y) - (o |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + o : o, _ = (T = (_ += P.z) - (_ |= 0)) ? (0 | T * g + (0 > T ? -.5 : .5)) / g + _ : _, S[ye] = "matrix3d(" + [(0 | t * g) / g, (0 | s * g) / g, (0 | l * g) / g, (0 | f * g) / g, (0 | e * g) / g, (0 | n * g) / g, (0 | h * g) / g, (0 | c * g) / g, (0 | i * g) / g, (0 | a * g) / g, (0 | u * g) / g, (0 | d * g) / g, r, o, _, O ? 1 + -_ / O : 1].join(",") + ")";
    },
        Re = function (t) {
      var e,
          i,
          r,
          s,
          n,
          a = this.data,
          o = this.t,
          l = o.style;
      return a.rotationX || a.rotationY || a.z || a.force3D ? (this.setRatio = Se, Se.call(this, t), void 0) : (a.rotation || a.skewX ? (e = a.rotation * M, i = e - a.skewX * M, r = 1e5, s = a.scaleX * r, n = a.scaleY * r, l[ye] = "matrix(" + (0 | Math.cos(e) * s) / r + "," + (0 | Math.sin(e) * s) / r + "," + (0 | Math.sin(i) * -n) / r + "," + (0 | Math.cos(i) * n) / r + "," + a.x + "," + a.y + ")") : l[ye] = "matrix(" + a.scaleX + ",0,0," + a.scaleY + "," + a.x + "," + a.y + ")", void 0);
    };

    me("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D", {
      parser: function (t, e, i, r, n, a, o) {
        if (r._transform) return n;

        var l,
            h,
            u,
            _,
            p,
            f,
            c,
            d = r._transform = be(t, s, !0, o.parseTransform),
            m = t.style,
            g = 1e-6,
            v = ve.length,
            y = o,
            T = {};

        if ("string" == typeof y.transform && ye) u = m.cssText, m[ye] = y.transform, m.display = "block", l = be(t, null, !1), m.cssText = u;else if ("object" == typeof y) {
          if (l = {
            scaleX: re(null != y.scaleX ? y.scaleX : y.scale, d.scaleX),
            scaleY: re(null != y.scaleY ? y.scaleY : y.scale, d.scaleY),
            scaleZ: re(y.scaleZ, d.scaleZ),
            x: re(y.x, d.x),
            y: re(y.y, d.y),
            z: re(y.z, d.z),
            perspective: re(y.transformPerspective, d.perspective)
          }, c = y.directionalRotation, null != c) if ("object" == typeof c) for (u in c) y[u] = c[u];else y.rotation = c;
          l.rotation = se("rotation" in y ? y.rotation : "shortRotation" in y ? y.shortRotation + "_short" : "rotationZ" in y ? y.rotationZ : d.rotation, d.rotation, "rotation", T), we && (l.rotationX = se("rotationX" in y ? y.rotationX : "shortRotationX" in y ? y.shortRotationX + "_short" : d.rotationX || 0, d.rotationX, "rotationX", T), l.rotationY = se("rotationY" in y ? y.rotationY : "shortRotationY" in y ? y.shortRotationY + "_short" : d.rotationY || 0, d.rotationY, "rotationY", T)), l.skewX = null == y.skewX ? d.skewX : se(y.skewX, d.skewX), l.skewY = null == y.skewY ? d.skewY : se(y.skewY, d.skewY), (h = l.skewY - d.skewY) && (l.skewX += h, l.rotation += h);
        }

        for (we && null != y.force3D && (d.force3D = y.force3D, f = !0), p = d.force3D || d.z || d.rotationX || d.rotationY || l.z || l.rotationX || l.rotationY || l.perspective, p || null == y.scale || (l.scaleZ = 1); --v > -1;) i = ve[v], _ = l[i] - d[i], (_ > g || -g > _ || null != N[i]) && (f = !0, n = new pe(d, i, d[i], _, n), i in T && (n.e = T[i]), n.xs0 = 0, n.plugin = a, r._overwriteProps.push(n.n));

        return _ = y.transformOrigin, (_ || we && p && d.zOrigin) && (ye ? (f = !0, i = xe, _ = (_ || H(t, i, s, !1, "50% 50%")) + "", n = new pe(m, i, 0, 0, n, -1, "transformOrigin"), n.b = m[i], n.plugin = a, we ? (u = d.zOrigin, _ = _.split(" "), d.zOrigin = (_.length > 2 && (0 === u || "0px" !== _[2]) ? parseFloat(_[2]) : u) || 0, n.xs0 = n.e = m[i] = _[0] + " " + (_[1] || "50%") + " 0px", n = new pe(d, "zOrigin", 0, 0, n, -1, n.n), n.b = u, n.xs0 = n.e = d.zOrigin) : n.xs0 = n.e = m[i] = _) : ee(_ + "", d)), f && (r._transformType = p || 3 === this._transformType ? 3 : 2), n;
      },
      prefix: !0
    }), me("boxShadow", {
      defaultValue: "0px 0px 0px 0px #999",
      prefix: !0,
      color: !0,
      multi: !0,
      keyword: "inset"
    }), me("borderRadius", {
      defaultValue: "0px",
      parser: function (t, e, i, n, a) {
        e = this.format(e);

        var o,
            l,
            h,
            u,
            _,
            p,
            f,
            c,
            d,
            m,
            g,
            v,
            y,
            T,
            x,
            w,
            b = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
            P = t.style;

        for (d = parseFloat(t.offsetWidth), m = parseFloat(t.offsetHeight), o = e.split(" "), l = 0; b.length > l; l++) this.p.indexOf("border") && (b[l] = V(b[l])), _ = u = H(t, b[l], s, !1, "0px"), -1 !== _.indexOf(" ") && (u = _.split(" "), _ = u[0], u = u[1]), p = h = o[l], f = parseFloat(_), v = _.substr((f + "").length), y = "=" === p.charAt(1), y ? (c = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), c *= parseFloat(p), g = p.substr((c + "").length - (0 > c ? 1 : 0)) || "") : (c = parseFloat(p), g = p.substr((c + "").length)), "" === g && (g = r[i] || v), g !== v && (T = Q(t, "borderLeft", f, v), x = Q(t, "borderTop", f, v), "%" === g ? (_ = 100 * (T / d) + "%", u = 100 * (x / m) + "%") : "em" === g ? (w = Q(t, "borderLeft", 1, "em"), _ = T / w + "em", u = x / w + "em") : (_ = T + "px", u = x + "px"), y && (p = parseFloat(_) + c + g, h = parseFloat(u) + c + g)), a = fe(P, b[l], _ + " " + u, p + " " + h, !1, "0px", a);

        return a;
      },
      prefix: !0,
      formatter: he("0px 0px 0px 0px", !1, !0)
    }), me("backgroundPosition", {
      defaultValue: "0 0",
      parser: function (t, e, i, r, n, a) {
        var o,
            l,
            h,
            u,
            _,
            p,
            f = "background-position",
            d = s || q(t, null),
            m = this.format((d ? c ? d.getPropertyValue(f + "-x") + " " + d.getPropertyValue(f + "-y") : d.getPropertyValue(f) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
            g = this.format(e);

        if (-1 !== m.indexOf("%") != (-1 !== g.indexOf("%")) && (p = H(t, "backgroundImage").replace(R, ""), p && "none" !== p)) {
          for (o = m.split(" "), l = g.split(" "), E.setAttribute("src", p), h = 2; --h > -1;) m = o[h], u = -1 !== m.indexOf("%"), u !== (-1 !== l[h].indexOf("%")) && (_ = 0 === h ? t.offsetWidth - E.width : t.offsetHeight - E.height, o[h] = u ? parseFloat(m) / 100 * _ + "px" : 100 * (parseFloat(m) / _) + "%");

          m = o.join(" ");
        }

        return this.parseComplex(t.style, m, g, n, a);
      },
      formatter: ee
    }), me("backgroundSize", {
      defaultValue: "0 0",
      formatter: ee
    }), me("perspective", {
      defaultValue: "0px",
      prefix: !0
    }), me("perspectiveOrigin", {
      defaultValue: "50% 50%",
      prefix: !0
    }), me("transformStyle", {
      prefix: !0
    }), me("backfaceVisibility", {
      prefix: !0
    }), me("userSelect", {
      prefix: !0
    }), me("margin", {
      parser: ue("marginTop,marginRight,marginBottom,marginLeft")
    }), me("padding", {
      parser: ue("paddingTop,paddingRight,paddingBottom,paddingLeft")
    }), me("clip", {
      defaultValue: "rect(0px,0px,0px,0px)",
      parser: function (t, e, i, r, n, a) {
        var o, l, h;
        return 9 > c ? (l = t.currentStyle, h = 8 > c ? " " : ",", o = "rect(" + l.clipTop + h + l.clipRight + h + l.clipBottom + h + l.clipLeft + ")", e = this.format(e).split(",").join(h)) : (o = this.format(H(t, this.p, s, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, o, e, n, a);
      }
    }), me("textShadow", {
      defaultValue: "0px 0px 0px #999",
      color: !0,
      multi: !0
    }), me("autoRound,strictUnits", {
      parser: function (t, e, i, r, s) {
        return s;
      }
    }), me("border", {
      defaultValue: "0px solid #000",
      parser: function (t, e, i, r, n, a) {
        return this.parseComplex(t.style, this.format(H(t, "borderTopWidth", s, !1, "0px") + " " + H(t, "borderTopStyle", s, !1, "solid") + " " + H(t, "borderTopColor", s, !1, "#000")), this.format(e), n, a);
      },
      color: !0,
      formatter: function (t) {
        var e = t.split(" ");
        return e[0] + " " + (e[1] || "solid") + " " + (t.match(le) || ["#000"])[0];
      }
    }), me("borderWidth", {
      parser: ue("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
    }), me("float,cssFloat,styleFloat", {
      parser: function (t, e, i, r, s) {
        var n = t.style,
            a = "cssFloat" in n ? "cssFloat" : "styleFloat";
        return new pe(n, a, 0, 0, s, -1, i, !1, 0, n[a], e);
      }
    });

    var ke = function (t) {
      var e,
          i = this.t,
          r = i.filter || H(this.data, "filter"),
          s = 0 | this.s + this.c * t;
      100 === s && (-1 === r.indexOf("atrix(") && -1 === r.indexOf("radient(") && -1 === r.indexOf("oader(") ? (i.removeAttribute("filter"), e = !H(this.data, "filter")) : (i.filter = r.replace(w, ""), e = !0)), e || (this.xn1 && (i.filter = r = r || "alpha(opacity=" + s + ")"), -1 === r.indexOf("opacity") ? 0 === s && this.xn1 || (i.filter = r + " alpha(opacity=" + s + ")") : i.filter = r.replace(T, "opacity=" + s));
    };

    me("opacity,alpha,autoAlpha", {
      defaultValue: "1",
      parser: function (t, e, i, r, n, a) {
        var o = parseFloat(H(t, "opacity", s, !1, "1")),
            l = t.style,
            h = "autoAlpha" === i;
        return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + o), h && 1 === o && "hidden" === H(t, "visibility", s) && 0 !== e && (o = 0), z ? n = new pe(l, "opacity", o, e - o, n) : (n = new pe(l, "opacity", 100 * o, 100 * (e - o), n), n.xn1 = h ? 1 : 0, l.zoom = 1, n.type = 2, n.b = "alpha(opacity=" + n.s + ")", n.e = "alpha(opacity=" + (n.s + n.c) + ")", n.data = t, n.plugin = a, n.setRatio = ke), h && (n = new pe(l, "visibility", 0, 0, n, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), n.xs0 = "inherit", r._overwriteProps.push(n.n), r._overwriteProps.push(i)), n;
      }
    });

    var Ce = function (t, e) {
      e && (t.removeProperty ? t.removeProperty(e.replace(P, "-$1").toLowerCase()) : t.removeAttribute(e));
    },
        Ae = function (t) {
      if (this.t._gsClassPT = this, 1 === t || 0 === t) {
        this.t.className = 0 === t ? this.b : this.e;

        for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Ce(i, e.p), e = e._next;

        1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null);
      } else this.t.className !== this.e && (this.t.className = this.e);
    };

    me("className", {
      parser: function (t, e, r, n, a, o, l) {
        var h,
            u,
            _,
            p,
            f,
            c = t.className,
            d = t.style.cssText;

        if (a = n._classNamePT = new pe(t, r, 0, 0, a, 2), a.setRatio = Ae, a.pr = -11, i = !0, a.b = c, u = $(t, s), _ = t._gsClassPT) {
          for (p = {}, f = _.data; f;) p[f.p] = 1, f = f._next;

          _.setRatio(1);
        }

        return t._gsClassPT = a, a.e = "=" !== e.charAt(1) ? e : c.replace(RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), n._tween._duration && (t.className = a.e, h = G(t, u, $(t), l, p), t.className = c, a.data = h.firstMPT, t.style.cssText = d, a = a.xfirst = n.parse(t, h.difs, a, o)), a;
      }
    });

    var Oe = function (t) {
      if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
        var e,
            i,
            r,
            s,
            n = this.t.style,
            a = o.transform.parse;
        if ("all" === this.e) n.cssText = "", s = !0;else for (e = this.e.split(","), r = e.length; --r > -1;) i = e[r], o[i] && (o[i].parse === a ? s = !0 : i = "transformOrigin" === i ? xe : o[i].p), Ce(n, i);
        s && (Ce(n, ye), this.t._gsTransform && delete this.t._gsTransform);
      }
    };

    for (me("clearProps", {
      parser: function (t, e, r, s, n) {
        return n = new pe(t, r, 0, 0, n, 2), n.setRatio = Oe, n.e = e, n.pr = -10, n.data = s._tween, i = !0, n;
      }
    }), l = "bezier,throwProps,physicsProps,physics2D".split(","), ce = l.length; ce--;) ge(l[ce]);

    l = a.prototype, l._firstPT = null, l._onInitTween = function (t, e, o) {
      if (!t.nodeType) return !1;
      this._target = t, this._tween = o, this._vars = e, h = e.autoRound, i = !1, r = e.suffixMap || a.suffixMap, s = q(t, ""), n = this._overwriteProps;
      var l,
          p,
          c,
          d,
          m,
          g,
          v,
          y,
          T,
          w = t.style;

      if (u && "" === w.zIndex && (l = H(t, "zIndex", s), ("auto" === l || "" === l) && (w.zIndex = 0)), "string" == typeof e && (d = w.cssText, l = $(t, s), w.cssText = d + ";" + e, l = G(t, l, $(t)).difs, !z && x.test(e) && (l.opacity = parseFloat(RegExp.$1)), e = l, w.cssText = d), this._firstPT = p = this.parse(t, e, null), this._transformType) {
        for (T = 3 === this._transformType, ye ? _ && (u = !0, "" === w.zIndex && (v = H(t, "zIndex", s), ("auto" === v || "" === v) && (w.zIndex = 0)), f && (w.WebkitBackfaceVisibility = this._vars.WebkitBackfaceVisibility || (T ? "visible" : "hidden"))) : w.zoom = 1, c = p; c && c._next;) c = c._next;

        y = new pe(t, "transform", 0, 0, null, 2), this._linkCSSP(y, null, c), y.setRatio = T && we ? Se : ye ? Re : Pe, y.data = this._transform || be(t, s, !0), n.pop();
      }

      if (i) {
        for (; p;) {
          for (g = p._next, c = d; c && c.pr > p.pr;) c = c._next;

          (p._prev = c ? c._prev : m) ? p._prev._next = p : d = p, (p._next = c) ? c._prev = p : m = p, p = g;
        }

        this._firstPT = d;
      }

      return !0;
    }, l.parse = function (t, e, i, n) {
      var a,
          l,
          u,
          _,
          p,
          f,
          c,
          d,
          m,
          g,
          v = t.style;

      for (a in e) f = e[a], l = o[a], l ? i = l.parse(t, f, a, this, i, n, e) : (p = H(t, a, s) + "", m = "string" == typeof f, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || m && b.test(f) ? (m || (f = oe(f), f = (f.length > 3 ? "rgba(" : "rgb(") + f.join(",") + ")"), i = fe(v, a, p, f, !0, "transparent", i, 0, n)) : !m || -1 === f.indexOf(" ") && -1 === f.indexOf(",") ? (u = parseFloat(p), c = u || 0 === u ? p.substr((u + "").length) : "", ("" === p || "auto" === p) && ("width" === a || "height" === a ? (u = te(t, a, s), c = "px") : "left" === a || "top" === a ? (u = Z(t, a, s), c = "px") : (u = "opacity" !== a ? 0 : 1, c = "")), g = m && "=" === f.charAt(1), g ? (_ = parseInt(f.charAt(0) + "1", 10), f = f.substr(2), _ *= parseFloat(f), d = f.replace(y, "")) : (_ = parseFloat(f), d = m ? f.substr((_ + "").length) || "" : ""), "" === d && (d = a in r ? r[a] : c), f = _ || 0 === _ ? (g ? _ + u : _) + d : e[a], c !== d && "" !== d && (_ || 0 === _) && (u || 0 === u) && (u = Q(t, a, u, c), "%" === d ? (u /= Q(t, a, 100, "%") / 100, e.strictUnits !== !0 && (p = u + "%")) : "em" === d ? u /= Q(t, a, 1, "em") : (_ = Q(t, a, _, d), d = "px"), g && (_ || 0 === _) && (f = _ + u + d)), g && (_ += u), !u && 0 !== u || !_ && 0 !== _ ? void 0 !== v[a] && (f || "NaN" != f + "" && null != f) ? (i = new pe(v, a, _ || u || 0, 0, i, -1, a, !1, 0, p, f), i.xs0 = "none" !== f || "display" !== a && -1 === a.indexOf("Style") ? f : p) : B("invalid " + a + " tween value: " + e[a]) : (i = new pe(v, a, u, _ - u, i, 0, a, h !== !1 && ("px" === d || "zIndex" === a), 0, p, f), i.xs0 = d)) : i = fe(v, a, p, f, !0, null, i, 0, n)), n && i && !i.plugin && (i.plugin = n);

      return i;
    }, l.setRatio = function (t) {
      var e,
          i,
          r,
          s = this._firstPT,
          n = 1e-6;
      if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time) {
        if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6) for (; s;) {
          if (e = s.c * t + s.s, s.r ? e = e > 0 ? 0 | e + .5 : 0 | e - .5 : n > e && e > -n && (e = 0), s.type) {
            if (1 === s.type) {
              if (r = s.l, 2 === r) s.t[s.p] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2;else if (3 === r) s.t[s.p] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2 + s.xn2 + s.xs3;else if (4 === r) s.t[s.p] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2 + s.xn2 + s.xs3 + s.xn3 + s.xs4;else if (5 === r) s.t[s.p] = s.xs0 + e + s.xs1 + s.xn1 + s.xs2 + s.xn2 + s.xs3 + s.xn3 + s.xs4 + s.xn4 + s.xs5;else {
                for (i = s.xs0 + e + s.xs1, r = 1; s.l > r; r++) i += s["xn" + r] + s["xs" + (r + 1)];

                s.t[s.p] = i;
              }
            } else -1 === s.type ? s.t[s.p] = s.xs0 : s.setRatio && s.setRatio(t);
          } else s.t[s.p] = e + s.xs0;
          s = s._next;
        } else for (; s;) 2 !== s.type ? s.t[s.p] = s.b : s.setRatio(t), s = s._next;
      } else for (; s;) 2 !== s.type ? s.t[s.p] = s.e : s.setRatio(t), s = s._next;
    }, l._enableTransforms = function (t) {
      this._transformType = t || 3 === this._transformType ? 3 : 2, this._transform = this._transform || be(this._target, s, !0);
    }, l._linkCSSP = function (t, e, i, r) {
      return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, r = !0), i ? i._next = t : r || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t;
    }, l._kill = function (e) {
      var i,
          r,
          s,
          n = e;

      if (e.autoAlpha || e.alpha) {
        n = {};

        for (r in e) n[r] = e[r];

        n.opacity = 1, n.autoAlpha && (n.visibility = 1);
      }

      return e.className && (i = this._classNamePT) && (s = i.xfirst, s && s._prev ? this._linkCSSP(s._prev, i._next, s._prev._prev) : s === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, s._prev), this._classNamePT = null), t.prototype._kill.call(this, n);
    };

    var De = function (t, e, i) {
      var r, s, n, a;
      if (t.slice) for (s = t.length; --s > -1;) De(t[s], e, i);else for (r = t.childNodes, s = r.length; --s > -1;) n = r[s], a = n.type, n.style && (e.push($(n)), i && i.push(n)), 1 !== a && 9 !== a && 11 !== a || !n.childNodes.length || De(n, e, i);
    };

    return a.cascadeTo = function (t, i, r) {
      var s,
          n,
          a,
          o = e.to(t, i, r),
          l = [o],
          h = [],
          u = [],
          _ = [],
          p = e._internals.reservedProps;

      for (t = o._targets || o.target, De(t, h, _), o.render(i, !0), De(t, u), o.render(0, !0), o._enabled(!0), s = _.length; --s > -1;) if (n = G(_[s], h[s], u[s]), n.firstMPT) {
        n = n.difs;

        for (a in r) p[a] && (n[a] = r[a]);

        l.push(e.to(_[s], i, n));
      }

      return l;
    }, t.activate([a]), a;
  }, !0);
}), window._gsDefine && window._gsQueue.pop()(); // WAIT FOR IMAGES

/*
 * waitForImages 1.4
 * -----------------
 * Provides a callback when all images have loaded in your given selector.
 * http://www.alexanderdickson.com/
 *
 *
 * Copyright (c) 2011 Alex Dickson
 * Licensed under the MIT licenses.
 * See website for more info.
 *
 */

(function (e, t) {
  e.waitForImages = {
    hasImageProperties: ["backgroundImage", "listStyleImage", "borderImage", "borderCornerImage"]
  };

  e.expr[":"].uncached = function (t) {
    var n = document.createElement("img");
    n.src = t.src;
    return e(t).is('img[src!=""]') && !n.complete;
  };

  e.fn.waitForImages = function (t, n, r) {
    if (e.isPlainObject(arguments[0])) {
      n = t.each;
      r = t.waitForAll;
      t = t.finished;
    }

    t = t || e.noop;
    n = n || e.noop;
    r = !!r;

    if (!e.isFunction(t) || !e.isFunction(n)) {
      throw new TypeError("An invalid callback was supplied.");
    }

    return this.each(function () {
      var i = e(this),
          s = [];

      if (r) {
        var o = e.waitForImages.hasImageProperties || [],
            u = /url\((['"]?)(.*?)\1\)/g;
        i.find("*").each(function () {
          var t = e(this);

          if (t.is("img:uncached")) {
            s.push({
              src: t.attr("src"),
              element: t[0]
            });
          }

          e.each(o, function (e, n) {
            var r = t.css(n);

            if (!r) {
              return true;
            }

            var i;

            while (i = u.exec(r)) {
              s.push({
                src: i[2],
                element: t[0]
              });
            }
          });
        });
      } else {
        i.find("img:uncached").each(function () {
          s.push({
            src: this.src,
            element: this
          });
        });
      }

      var f = s.length,
          l = 0;

      if (f == 0) {
        t.call(i[0]);
      }

      e.each(s, function (r, s) {
        var o = new Image();
        e(o).bind("load error", function (e) {
          l++;
          n.call(s.element, l, f, e.type == "load");

          if (l == f) {
            t.call(i[0]);
            return false;
          }
        });
        o.src = s.src;
      });
    });
  };
})(jQuery);
/**************************************************************************
 * jquery.themepunch.revolution.js - jQuery Plugin for Revolution Slider
 * @version: 4.3.6 (16.04.2013)
 * @requires jQuery v1.7 or later (tested on 1.9)
 * @author ThemePunch
**************************************************************************/


function revslider_showDoubleJqueryError(e) {
  var t = "Revolution Slider Error: You have some jquery.js library include that comes after the revolution files js include.";
  t += "<br> This includes make eliminates the revolution slider libraries, and make it not work.";
  t += "<br><br> To fix it you can:<br>&nbsp;&nbsp;&nbsp; 1. In the Slider Settings -> Troubleshooting set option:  <strong><b>Put JS Includes To Body</b></strong> option to true.";
  t += "<br>&nbsp;&nbsp;&nbsp; 2. Find the double jquery.js include and remove it.";
  t = "<span style='font-size:16px;color:#BC0C06;'>" + t + "</span>";
  jQuery(e).show().html(t);
}

(function (e, t) {
  function n(e) {
    var t = [],
        n;
    var r = window.location.href.slice(window.location.href.indexOf(e) + 1).split("_");

    for (var i = 0; i < r.length; i++) {
      r[i] = r[i].replace("%3D", "=");
      n = r[i].split("=");
      t.push(n[0]);
      t[n[0]] = n[1];
    }

    return t;
  }

  function r(n, i) {
    try {
      if (i.hideThumbsUnderResoluition != 0 && i.navigationType == "thumb") {
        if (i.hideThumbsUnderResoluition > e(window).width()) e(".tp-bullets").css({
          display: "none"
        });else e(".tp-bullets").css({
          display: "block"
        });
      }
    } catch (s) {}

    n.find(".defaultimg").each(function (t) {
      g(e(this), i);
    });
    var o = n.parent();

    if (e(window).width() < i.hideSliderAtLimit) {
      n.trigger("stoptimer");
      if (o.css("display") != "none") o.data("olddisplay", o.css("display"));
      o.css({
        display: "none"
      });
    } else {
      if (n.is(":hidden")) {
        if (o.data("olddisplay") != t && o.data("olddisplay") != "undefined" && o.data("olddisplay") != "none") o.css({
          display: o.data("olddisplay")
        });else o.css({
          display: "block"
        });
        n.trigger("restarttimer");
        setTimeout(function () {
          r(n, i);
        }, 150);
      }
    }

    var u = 0;
    if (i.forceFullWidth == "on") u = 0 - i.container.parent().offset().left;

    try {
      n.parent().find(".tp-bannershadow").css({
        width: i.width,
        left: u
      });
    } catch (s) {}

    var a = n.find(">ul >li:eq(" + i.act + ") .slotholder");
    var f = n.find(">ul >li:eq(" + i.next + ") .slotholder");
    S(n, i);
    f.find(".defaultimg").css({
      opacity: 0
    });
    a.find(".defaultimg").css({
      opacity: 1
    });
    f.find(".defaultimg").each(function () {
      var r = e(this);

      if (r.data("kenburn") != t) {
        r.data("kenburn").restart();
        D(n, i, true);
      }
    });
    var l = n.find(">ul >li:eq(" + i.next + ")");
    J(l, i, true);
    m(n, i);
  }

  function s() {
    var e = ["android", "webos", "iphone", "ipad", "blackberry", "Android", "webos",, "iPod", "iPhone", "iPad", "Blackberry", "BlackBerry"];
    var t = false;

    for (i in e) {
      if (navigator.userAgent.split(e[i]).length > 1) {
        t = true;
      }
    }

    return t;
  }

  function o(t, n) {
    var r = e('<div style="display:none;"/>').appendTo(e("body"));
    r.html("<!--[if " + (n || "") + " IE " + (t || "") + "]><a>&nbsp;</a><![endif]-->");
    var i = r.find("a").length;
    r.remove();
    return i;
  }

  function u(e, t) {
    C(t, e);
  }

  function a(n, r) {
    var i = n.parent();

    if (r.navigationType == "thumb" || r.navsecond == "both") {
      i.append('<div class="tp-bullets tp-thumbs ' + r.navigationStyle + '"><div class="tp-mask"><div class="tp-thumbcontainer"></div></div></div>');
    }

    var s = i.find(".tp-bullets.tp-thumbs .tp-mask .tp-thumbcontainer");
    var o = s.parent();
    o.width(r.thumbWidth * r.thumbAmount);
    o.height(r.thumbHeight);
    o.parent().width(r.thumbWidth * r.thumbAmount);
    o.parent().height(r.thumbHeight);
    n.find(">ul:first >li").each(function (e) {
      var i = n.find(">ul:first >li:eq(" + e + ")");
      var o = i.find(".defaultimg").css("backgroundColor");
      if (i.data("thumb") != t) var u = i.data("thumb");else var u = i.find("img:first").attr("src");
      s.append('<div class="bullet thumb" style="background-color:' + o + ";position:relative;width:" + r.thumbWidth + "px;height:" + r.thumbHeight + "px;background-image:url(" + u + ') !important;background-size:cover;background-position:center center;"></div>');
      var a = s.find(".bullet:first");
    });
    var a = 10;
    s.find(".bullet").each(function (t) {
      var i = e(this);
      if (t == r.slideamount - 1) i.addClass("last");
      if (t == 0) i.addClass("first");
      i.width(r.thumbWidth);
      i.height(r.thumbHeight);
      if (a < i.outerWidth(true)) a = i.outerWidth(true);
      i.click(function () {
        if (r.transition == 0 && i.index() != r.act) {
          r.next = i.index();
          u(r, n);
        }
      });
    });
    var c = a * n.find(">ul:first >li").length;
    var h = s.parent().width();
    r.thumbWidth = a;

    if (h < c) {
      e(document).mousemove(function (t) {
        e("body").data("mousex", t.pageX);
      });
      s.parent().mouseenter(function () {
        var t = e(this);
        t.addClass("over");
        var r = t.offset();
        var i = e("body").data("mousex") - r.left;
        var s = t.width();
        var o = t.find(".bullet:first").outerWidth(true);
        var u = o * n.find(">ul:first >li").length;
        var a = u - s + 15;
        var f = a / s;
        i = i - 30;
        var c = 0 - i * f;
        if (c > 0) c = 0;
        if (c < 0 - u + s) c = 0 - u + s;
        l(t, c, 200);
      });
      s.parent().mousemove(function () {
        var t = e(this);
        var r = t.offset();
        var i = e("body").data("mousex") - r.left;
        var s = t.width();
        var o = t.find(".bullet:first").outerWidth(true);
        var u = o * n.find(">ul:first >li").length - 1;
        var a = u - s + 15;
        var f = a / s;
        i = i - 3;
        if (i < 6) i = 0;
        if (i + 3 > s - 6) i = s;
        var c = 0 - i * f;
        if (c > 0) c = 0;
        if (c < 0 - u + s) c = 0 - u + s;
        l(t, c, 0);
      });
      s.parent().mouseleave(function () {
        var t = e(this);
        t.removeClass("over");
        f(n);
      });
    }
  }

  function f(e) {
    var t = e.parent().find(".tp-bullets.tp-thumbs .tp-mask .tp-thumbcontainer");
    var n = t.parent();
    var r = n.offset();
    var i = n.find(".bullet:first").outerWidth(true);
    var s = n.find(".bullet.selected").index() * i;
    var o = n.width();
    var i = n.find(".bullet:first").outerWidth(true);
    var u = i * e.find(">ul:first >li").length;
    var a = u - o;
    var f = a / o;
    var c = 0 - s;
    if (c > 0) c = 0;
    if (c < 0 - u + o) c = 0 - u + o;

    if (!n.hasClass("over")) {
      l(n, c, 200);
    }
  }

  function l(e, t, n) {
    TweenLite.to(e.find(".tp-thumbcontainer"), .2, {
      left: t,
      ease: Power3.easeOut,
      overwrite: "auto"
    });
  }

  function c(t, n) {
    if (n.navigationType == "bullet" || n.navigationType == "both") {
      t.parent().append('<div class="tp-bullets simplebullets ' + n.navigationStyle + '"></div>');
    }

    var r = t.parent().find(".tp-bullets");
    t.find(">ul:first >li").each(function (e) {
      var n = t.find(">ul:first >li:eq(" + e + ") img:first").attr("src");
      r.append('<div class="bullet"></div>');
      var i = r.find(".bullet:first");
    });
    r.find(".bullet").each(function (r) {
      var i = e(this);
      if (r == n.slideamount - 1) i.addClass("last");
      if (r == 0) i.addClass("first");
      i.click(function () {
        var e = false;

        if (n.navigationArrows == "withbullet" || n.navigationArrows == "nexttobullets") {
          if (i.index() - 1 == n.act) e = true;
        } else {
          if (i.index() == n.act) e = true;
        }

        if (n.transition == 0 && !e) {
          if (n.navigationArrows == "withbullet" || n.navigationArrows == "nexttobullets") {
            n.next = i.index() - 1;
          } else {
            n.next = i.index();
          }

          u(n, t);
        }
      });
    });
    r.append('<div class="tpclear"></div>');
    m(t, n);
  }

  function h(e, n) {
    var r = e.find(".tp-bullets");
    var i = "";
    var s = n.navigationStyle;
    if (n.navigationArrows == "none") i = "visibility:hidden;display:none";
    n.soloArrowStyle = "default";
    if (n.navigationArrows != "none" && n.navigationArrows != "nexttobullets") s = n.soloArrowStyle;
    e.parent().append('<div style="' + i + '" class="tp-leftarrow tparrows ' + s + '"></div>');
    e.parent().append('<div style="' + i + '" class="tp-rightarrow tparrows ' + s + '"></div>');
    e.parent().find(".tp-rightarrow").click(function () {
      if (n.transition == 0) {
        if (e.data("showus") != t && e.data("showus") != -1) n.next = e.data("showus") - 1;else n.next = n.next + 1;
        e.data("showus", -1);
        if (n.next >= n.slideamount) n.next = 0;
        if (n.next < 0) n.next = 0;
        if (n.act != n.next) u(n, e);
      }
    });
    e.parent().find(".tp-leftarrow").click(function () {
      if (n.transition == 0) {
        n.next = n.next - 1;
        n.leftarrowpressed = 1;
        if (n.next < 0) n.next = n.slideamount - 1;
        u(n, e);
      }
    });
    m(e, n);
  }

  function p(n, r) {
    e(document).keydown(function (e) {
      if (r.transition == 0 && e.keyCode == 39) {
        if (n.data("showus") != t && n.data("showus") != -1) r.next = n.data("showus") - 1;else r.next = r.next + 1;
        n.data("showus", -1);
        if (r.next >= r.slideamount) r.next = 0;
        if (r.next < 0) r.next = 0;
        if (r.act != r.next) u(r, n);
      }

      if (r.transition == 0 && e.keyCode == 37) {
        r.next = r.next - 1;
        r.leftarrowpressed = 1;
        if (r.next < 0) r.next = r.slideamount - 1;
        u(r, n);
      }
    });
    m(n, r);
  }

  function d(t, n) {
    if (n.touchenabled == "on") {
      var r = Hammer(t, {
        drag_block_vertical: n.drag_block_vertical,
        drag_lock_to_axis: true,
        swipe_velocity: n.swipe_velocity,
        swipe_max_touches: n.swipe_max_touches,
        swipe_min_touches: n.swipe_min_touches,
        prevent_default: false
      });
      r.on("swipeleft", function () {
        if (n.transition == 0) {
          n.next = n.next + 1;
          if (n.next == n.slideamount) n.next = 0;
          u(n, t);
        }
      });
      r.on("swiperight", function () {
        if (n.transition == 0) {
          n.next = n.next - 1;
          n.leftarrowpressed = 1;
          if (n.next < 0) n.next = n.slideamount - 1;
          u(n, t);
        }
      });
      r.on("swipeup", function () {
        e("html, body").animate({
          scrollTop: t.offset().top + t.height() + "px"
        });
      });
      r.on("swipedown", function () {
        e("html, body").animate({
          scrollTop: t.offset().top - e(window).height() + "px"
        });
      });
    }
  }

  function v(e, t) {
    var n = e.parent().find(".tp-bullets");
    var r = e.parent().find(".tparrows");

    if (n == null) {
      e.append('<div class=".tp-bullets"></div>');
      var n = e.parent().find(".tp-bullets");
    }

    if (r == null) {
      e.append('<div class=".tparrows"></div>');
      var r = e.parent().find(".tparrows");
    }

    e.data("hidethumbs", t.hideThumbs);
    n.addClass("hidebullets");
    r.addClass("hidearrows");

    if (s()) {
      e.hammer().on("touch", function () {
        e.addClass("hovered");
        if (t.onHoverStop == "on") e.trigger("stoptimer");
        clearTimeout(e.data("hidethumbs"));
        n.removeClass("hidebullets");
        r.removeClass("hidearrows");
      });
      e.hammer().on("release", function () {
        e.removeClass("hovered");
        e.trigger("playtimer");
        if (!e.hasClass("hovered") && !n.hasClass("hovered")) e.data("hidethumbs", setTimeout(function () {
          n.addClass("hidebullets");
          r.addClass("hidearrows");
          e.trigger("playtimer");
        }, t.hideNavDelayOnMobile));
      });
    } else {
      n.hover(function () {
        t.overnav = true;
        if (t.onHoverStop == "on") e.trigger("stoptimer");
        n.addClass("hovered");
        clearTimeout(e.data("hidethumbs"));
        n.removeClass("hidebullets");
        r.removeClass("hidearrows");
      }, function () {
        t.overnav = false;
        e.trigger("playtimer");
        n.removeClass("hovered");
        if (!e.hasClass("hovered") && !n.hasClass("hovered")) e.data("hidethumbs", setTimeout(function () {
          n.addClass("hidebullets");
          r.addClass("hidearrows");
        }, t.hideThumbs));
      });
      r.hover(function () {
        t.overnav = true;
        if (t.onHoverStop == "on") e.trigger("stoptimer");
        n.addClass("hovered");
        clearTimeout(e.data("hidethumbs"));
        n.removeClass("hidebullets");
        r.removeClass("hidearrows");
      }, function () {
        t.overnav = false;
        e.trigger("playtimer");
        n.removeClass("hovered");
      });
      e.on("mouseenter", function () {
        e.addClass("hovered");
        if (t.onHoverStop == "on") e.trigger("stoptimer");
        clearTimeout(e.data("hidethumbs"));
        n.removeClass("hidebullets");
        r.removeClass("hidearrows");
      });
      e.on("mouseleave", function () {
        e.removeClass("hovered");
        e.trigger("playtimer");
        if (!e.hasClass("hovered") && !n.hasClass("hovered")) e.data("hidethumbs", setTimeout(function () {
          n.addClass("hidebullets");
          r.addClass("hidearrows");
        }, t.hideThumbs));
      });
    }
  }

  function m(t, n) {
    var r = t.parent();
    var i = r.find(".tp-bullets");

    if (n.navigationType == "thumb") {
      i.find(".thumb").each(function (t) {
        var r = e(this);
        r.css({
          width: n.thumbWidth * n.bw + "px",
          height: n.thumbHeight * n.bh + "px"
        });
      });
      var s = i.find(".tp-mask");
      s.width(n.thumbWidth * n.thumbAmount * n.bw);
      s.height(n.thumbHeight * n.bh);
      s.parent().width(n.thumbWidth * n.thumbAmount * n.bw);
      s.parent().height(n.thumbHeight * n.bh);
    }

    var o = r.find(".tp-leftarrow");
    var u = r.find(".tp-rightarrow");
    if (n.navigationType == "thumb" && n.navigationArrows == "nexttobullets") n.navigationArrows = "solo";

    if (n.navigationArrows == "nexttobullets") {
      o.prependTo(i).css({
        "float": "left"
      });
      u.insertBefore(i.find(".tpclear")).css({
        "float": "left"
      });
    }

    var a = 0;
    if (n.forceFullWidth == "on") a = 0 - n.container.parent().offset().left;

    if (n.navigationArrows != "none" && n.navigationArrows != "nexttobullets") {
      o.css({
        position: "absolute"
      });
      u.css({
        position: "absolute"
      });
      if (n.soloArrowLeftValign == "center") o.css({
        top: "50%",
        marginTop: n.soloArrowLeftVOffset - Math.round(o.innerHeight() / 2) + "px"
      });
      if (n.soloArrowLeftValign == "bottom") o.css({
        top: "auto",
        bottom: 0 + n.soloArrowLeftVOffset + "px"
      });
      if (n.soloArrowLeftValign == "top") o.css({
        bottom: "auto",
        top: 0 + n.soloArrowLeftVOffset + "px"
      });
      if (n.soloArrowLeftHalign == "center") o.css({
        left: "50%",
        marginLeft: a + n.soloArrowLeftHOffset - Math.round(o.innerWidth() / 2) + "px"
      });
      if (n.soloArrowLeftHalign == "left") o.css({
        left: 0 + n.soloArrowLeftHOffset + a + "px"
      });
      if (n.soloArrowLeftHalign == "right") o.css({
        right: 0 + n.soloArrowLeftHOffset - a + "px"
      });
      if (n.soloArrowRightValign == "center") u.css({
        top: "50%",
        marginTop: n.soloArrowRightVOffset - Math.round(u.innerHeight() / 2) + "px"
      });
      if (n.soloArrowRightValign == "bottom") u.css({
        top: "auto",
        bottom: 0 + n.soloArrowRightVOffset + "px"
      });
      if (n.soloArrowRightValign == "top") u.css({
        bottom: "auto",
        top: 0 + n.soloArrowRightVOffset + "px"
      });
      if (n.soloArrowRightHalign == "center") u.css({
        left: "50%",
        marginLeft: a + n.soloArrowRightHOffset - Math.round(u.innerWidth() / 2) + "px"
      });
      if (n.soloArrowRightHalign == "left") u.css({
        left: 0 + n.soloArrowRightHOffset + a + "px"
      });
      if (n.soloArrowRightHalign == "right") u.css({
        right: 0 + n.soloArrowRightHOffset - a + "px"
      });
      if (o.position() != null) o.css({
        top: Math.round(parseInt(o.position().top, 0)) + "px"
      });
      if (u.position() != null) u.css({
        top: Math.round(parseInt(u.position().top, 0)) + "px"
      });
    }

    if (n.navigationArrows == "none") {
      o.css({
        visibility: "hidden"
      });
      u.css({
        visibility: "hidden"
      });
    }

    if (n.navigationVAlign == "center") i.css({
      top: "50%",
      marginTop: n.navigationVOffset - Math.round(i.innerHeight() / 2) + "px"
    });
    if (n.navigationVAlign == "bottom") i.css({
      bottom: 0 + n.navigationVOffset + "px"
    });
    if (n.navigationVAlign == "top") i.css({
      top: 0 + n.navigationVOffset + "px"
    });
    if (n.navigationHAlign == "center") i.css({
      left: "50%",
      marginLeft: a + n.navigationHOffset - Math.round(i.innerWidth() / 2) + "px"
    });
    if (n.navigationHAlign == "left") i.css({
      left: 0 + n.navigationHOffset + a + "px"
    });
    if (n.navigationHAlign == "right") i.css({
      right: 0 + n.navigationHOffset - a + "px"
    });
  }

  function g(n, r) {
    r.container.closest(".forcefullwidth_wrapper_tp_banner").find(".tp-fullwidth-forcer").css({
      height: r.container.height()
    });
    r.container.closest(".rev_slider_wrapper").css({
      height: r.container.height()
    });
    r.width = parseInt(r.container.width(), 0);
    r.height = parseInt(r.container.height(), 0);
    r.bw = r.width / r.startwidth;
    r.bh = r.height / r.startheight;
    if (r.bh > r.bw) r.bh = r.bw;
    if (r.bh < r.bw) r.bw = r.bh;
    if (r.bw < r.bh) r.bh = r.bw;

    if (r.bh > 1) {
      r.bw = 1;
      r.bh = 1;
    }

    if (r.bw > 1) {
      r.bw = 1;
      r.bh = 1;
    }

    r.height = Math.round(r.startheight * (r.width / r.startwidth));
    if (r.height > r.startheight && r.autoHeight != "on") r.height = r.startheight;

    if (r.fullScreen == "on") {
      r.height = r.bw * r.startheight;
      var i = r.container.parent().width();
      var s = e(window).height();

      if (r.fullScreenOffsetContainer != t) {
        try {
          var o = r.fullScreenOffsetContainer.split(",");
          e.each(o, function (t, n) {
            s = s - e(n).outerHeight(true);
            if (s < r.minFullScreenHeight) s = r.minFullScreenHeight;
          });
        } catch (u) {}
      }

      r.container.parent().height(s);
      r.container.css({
        height: "100%"
      });
      r.height = s;
    } else {
      r.container.height(r.height);
    }

    r.slotw = Math.ceil(r.width / r.slots);
    if (r.fullSreen == "on") r.sloth = Math.ceil(e(window).height() / r.slots);else r.sloth = Math.ceil(r.height / r.slots);
    if (r.autoHeight == "on") r.sloth = Math.ceil(n.height() / r.slots);
  }

  function y(n, r) {
    n.find(".tp-caption").each(function () {
      e(this).addClass(e(this).data("transition"));
      e(this).addClass("start");
    });
    n.find(">ul:first").css({
      overflow: "hidden",
      width: "100%",
      height: "100%",
      maxHeight: n.parent().css("maxHeight")
    });

    if (r.autoHeight == "on") {
      n.find(">ul:first").css({
        overflow: "hidden",
        width: "100%",
        height: "100%",
        maxHeight: "none"
      });
      n.css({
        maxHeight: "none"
      });
      n.parent().css({
        maxHeight: "none"
      });
    }

    n.find(">ul:first >li").each(function (n) {
      var r = e(this);
      r.css({
        width: "100%",
        height: "100%",
        overflow: "hidden"
      });

      if (r.data("link") != t) {
        var i = r.data("link");
        var s = "_self";
        var o = 60;
        if (r.data("slideindex") == "back") o = 0;
        var u = r.data("linktoslide");
        if (r.data("target") != t) s = r.data("target");

        if (i == "slide") {
          r.append('<div class="tp-caption sft slidelink" style="width:100%;height:100%;z-index:' + o + ';" data-x="0" data-y="0" data-linktoslide="' + u + '" data-start="0"><a style="width:100%;height:100%;display:block"><span style="width:100%;height:100%;display:block"></span></a></div>');
        } else {
          u = "no";
          r.append('<div class="tp-caption sft slidelink" style="width:100%;height:100%;z-index:' + o + ';" data-x="0" data-y="0" data-linktoslide="' + u + '" data-start="0"><a style="width:100%;height:100%;display:block" target="' + s + '" href="' + i + '"><span style="width:100%;height:100%;display:block"></span></a></div>');
        }
      }
    });
    n.parent().css({
      overflow: "visible"
    });
    n.find(">ul:first >li >img").each(function (n) {
      var i = e(this);
      i.addClass("defaultimg");

      if (i.data("lazyload") != t && i.data("lazydone") != 1) {} else {
        g(i, r);
      }

      i.wrap('<div class="slotholder" style="width:100%;height:100%;"' + 'data-duration="' + i.data("duration") + '"' + 'data-zoomstart="' + i.data("zoomstart") + '"' + 'data-zoomend="' + i.data("zoomend") + '"' + 'data-rotationstart="' + i.data("rotationstart") + '"' + 'data-rotationend="' + i.data("rotationend") + '"' + 'data-ease="' + i.data("ease") + '"' + 'data-duration="' + i.data("duration") + '"' + 'data-bgpositionend="' + i.data("bgpositionend") + '"' + 'data-bgposition="' + i.data("bgposition") + '"' + 'data-duration="' + i.data("duration") + '"' + 'data-kenburns="' + i.data("kenburns") + '"' + 'data-easeme="' + i.data("ease") + '"' + 'data-bgfit="' + i.data("bgfit") + '"' + 'data-bgfitend="' + i.data("bgfitend") + '"' + 'data-owidth="' + i.data("owidth") + '"' + 'data-oheight="' + i.data("oheight") + '"' + "></div>");
      if (r.dottedOverlay != "none" && r.dottedOverlay != t) i.closest(".slotholder").append('<div class="tp-dottedoverlay ' + r.dottedOverlay + '"></div>');
      var s = i.attr("src");
      var u = i.data("lazyload");
      var a = i.data("bgfit");
      var f = i.data("bgrepeat");
      var l = i.data("bgposition");
      if (a == t) a = "cover";
      if (f == t) f = "no-repeat";
      if (l == t) l = "center center";
      var c = i.closest(".slotholder");
      i.replaceWith('<div class="tp-bgimg defaultimg" data-lazyload="' + i.data("lazyload") + '" data-bgfit="' + a + '"data-bgposition="' + l + '" data-bgrepeat="' + f + '" data-lazydone="' + i.data("lazydone") + '" src="' + s + '" data-src="' + s + '" style="background-color:' + i.css("backgroundColor") + ";background-repeat:" + f + ";background-image:url(" + s + ");background-size:" + a + ";background-position:" + l + ';width:100%;height:100%;"></div>');

      if (o(8)) {
        c.find(".tp-bgimg").css({
          backgroundImage: "none",
          "background-image": "none"
        });
        c.find(".tp-bgimg").append('<img class="ieeightfallbackimage defaultimg" src="' + s + '" style="width:100%">');
      }

      i.css({
        opacity: 0
      });
      i.data("li-id", n);
    });
  }

  function b(e, n, r, i) {
    var s = e;
    var u = s.find(".defaultimg");
    var a = s.data("zoomstart");
    var f = s.data("rotationstart");
    if (u.data("currotate") != t) f = u.data("currotate");
    if (u.data("curscale") != t) a = u.data("curscale");
    g(u, n);
    var l = u.data("src");
    var c = u.css("background-color");
    var h = n.width;
    var p = n.height;
    if (n.autoHeight == "on") p = n.container.height();
    var d = u.data("fxof");
    if (d == t) d = 0;
    fullyoff = 0;
    var v = 0;
    var m = u.data("bgfit");
    var y = u.data("bgrepeat");
    var b = u.data("bgposition");
    if (m == t) m = "cover";
    if (y == t) y = "no-repeat";
    if (b == t) b = "center center";

    if (o(8)) {
      s.data("kenburns", "off");
    }

    if (s.data("kenburns") == "on") {
      m = a;
      if (m.toString().length < 4) m = H(m, s, n);
    }

    if (o(8)) {
      var w = l;
      l = "";
    }

    if (i == "horizontal") {
      if (!r) var v = 0 - n.slotw;

      for (var S = 0; S < n.slots; S++) {
        s.append('<div class="slot" style="position:absolute;' + "top:" + (0 + fullyoff) + "px;" + "left:" + (d + S * n.slotw) + "px;" + "overflow:hidden;width:" + n.slotw + "px;" + "height:" + p + 'px">' + '<div class="slotslide" style="position:absolute;' + "top:0px;left:" + v + "px;" + "width:" + n.slotw + "px;" + "height:" + p + 'px;overflow:hidden;">' + '<div style="background-color:' + c + ";" + "position:absolute;top:0px;" + "left:" + (0 - S * n.slotw) + "px;" + "width:" + h + "px;height:" + p + "px;" + "background-image:url(" + l + ");" + "background-repeat:" + y + ";" + "background-size:" + m + ";background-position:" + b + ';">' + "</div></div></div>");
        if (a != t && f != t) TweenLite.set(s.find(".slot").last(), {
          rotationZ: f
        });

        if (o(8)) {
          s.find(".slot ").last().find(".slotslide").append('<img class="ieeightfallbackimage" src="' + w + '" style="width:100%;height:auto">');
          E(s, n);
        }
      }
    } else {
      if (!r) var v = 0 - n.sloth;

      for (var S = 0; S < n.slots + 2; S++) {
        s.append('<div class="slot" style="position:absolute;' + "top:" + (fullyoff + S * n.sloth) + "px;" + "left:" + d + "px;" + "overflow:hidden;" + "width:" + h + "px;" + "height:" + n.sloth + 'px">' + '<div class="slotslide" style="position:absolute;' + "top:" + v + "px;" + "left:0px;width:" + h + "px;" + "height:" + n.sloth + "px;" + 'overflow:hidden;">' + '<div style="background-color:' + c + ";" + "position:absolute;" + "top:" + (0 - S * n.sloth) + "px;" + "left:0px;" + "width:" + h + "px;height:" + p + "px;" + "background-image:url(" + l + ");" + "background-repeat:" + y + ";" + "background-size:" + m + ";background-position:" + b + ';">' + "</div></div></div>");
        if (a != t && f != t) TweenLite.set(s.find(".slot").last(), {
          rotationZ: f
        });

        if (o(8)) {
          s.find(".slot ").last().find(".slotslide").append('<img class="ieeightfallbackimage" src="' + w + '" style="width:100%;height:auto;">');
          E(s, n);
        }
      }
    }
  }

  function w(e, n, r) {
    var i = e;
    var s = i.find(".defaultimg");
    var u = i.data("zoomstart");
    var a = i.data("rotationstart");
    if (s.data("currotate") != t) a = s.data("currotate");
    if (s.data("curscale") != t) u = s.data("curscale") * 100;
    g(s, n);
    var f = s.data("src");
    var l = s.css("backgroundColor");
    var c = n.width;
    var h = n.height;
    if (n.autoHeight == "on") h = n.container.height();
    var p = s.data("fxof");
    if (p == t) p = 0;
    fullyoff = 0;
    var d = 0;

    if (o(8)) {
      var v = f;
      f = "";
    }

    var m = 0;
    if (n.sloth > n.slotw) m = n.sloth;else m = n.slotw;

    if (!r) {
      var d = 0 - m;
    }

    n.slotw = m;
    n.sloth = m;
    var y = 0;
    var b = 0;
    var w = s.data("bgfit");
    var S = s.data("bgrepeat");
    var x = s.data("bgposition");
    if (w == t) w = "cover";
    if (S == t) S = "no-repeat";
    if (x == t) x = "center center";

    if (i.data("kenburns") == "on") {
      w = u;
      if (w.toString().length < 4) w = H(w, i, n);
    }

    for (var T = 0; T < n.slots; T++) {
      b = 0;

      for (var N = 0; N < n.slots; N++) {
        i.append('<div class="slot" ' + 'style="position:absolute;' + "top:" + (fullyoff + b) + "px;" + "left:" + (p + y) + "px;" + "width:" + m + "px;" + "height:" + m + "px;" + 'overflow:hidden;">' + '<div class="slotslide" data-x="' + y + '" data-y="' + b + '" ' + 'style="position:absolute;' + "top:" + 0 + "px;" + "left:" + 0 + "px;" + "width:" + m + "px;" + "height:" + m + "px;" + 'overflow:hidden;">' + '<div style="position:absolute;' + "top:" + (0 - b) + "px;" + "left:" + (0 - y) + "px;" + "width:" + c + "px;" + "height:" + h + "px;" + "background-color:" + l + ";" + "background-image:url(" + f + ");" + "background-repeat:" + S + ";" + "background-size:" + w + ";background-position:" + x + ';">' + "</div></div></div>");
        b = b + m;

        if (o(8)) {
          i.find(".slot ").last().find(".slotslide").append('<img src="' + v + '">');
          E(i, n);
        }

        if (u != t && a != t) TweenLite.set(i.find(".slot").last(), {
          rotationZ: a
        });
      }

      y = y + m;
    }
  }

  function E(e, t) {
    if (o(8)) {
      var n = e.find(".ieeightfallbackimage");
      var r = n.width(),
          i = n.height();
      if (t.startwidth / t.startheight < e.data("owidth") / e.data("oheight")) n.css({
        width: "auto",
        height: "100%"
      });else n.css({
        width: "100%",
        height: "auto"
      });
      setTimeout(function () {
        var r = n.width(),
            i = n.height();
        if (e.data("bgposition") == "center center") n.css({
          position: "absolute",
          top: t.height / 2 - i / 2 + "px",
          left: t.width / 2 - r / 2 + "px"
        });
        if (e.data("bgposition") == "center top" || e.data("bgposition") == "top center") n.css({
          position: "absolute",
          top: "0px",
          left: t.width / 2 - r / 2 + "px"
        });
        if (e.data("bgposition") == "center bottom" || e.data("bgposition") == "bottom center") n.css({
          position: "absolute",
          bottom: "0px",
          left: t.width / 2 - r / 2 + "px"
        });
        if (e.data("bgposition") == "right top" || e.data("bgposition") == "top right") n.css({
          position: "absolute",
          top: "0px",
          right: "0px"
        });
        if (e.data("bgposition") == "right bottom" || e.data("bgposition") == "bottom right") n.css({
          position: "absolute",
          bottom: "0px",
          right: "0px"
        });
        if (e.data("bgposition") == "right center" || e.data("bgposition") == "center right") n.css({
          position: "absolute",
          top: t.height / 2 - i / 2 + "px",
          right: "0px"
        });
        if (e.data("bgposition") == "left bottom" || e.data("bgposition") == "bottom left") n.css({
          position: "absolute",
          bottom: "0px",
          left: "0px"
        });
        if (e.data("bgposition") == "left center" || e.data("bgposition") == "center left") n.css({
          position: "absolute",
          top: t.height / 2 - i / 2 + "px",
          left: "0px"
        });
      }, 20);
    }
  }

  function S(n, r, i) {
    if (i == t) i == 80;
    setTimeout(function () {
      n.find(".slotholder .slot").each(function () {
        clearTimeout(e(this).data("tout"));
        e(this).remove();
      });
      r.transition = 0;
    }, i);
  }

  function x(n, r) {
    n.find("img, .defaultimg").each(function (n) {
      var i = e(this);

      if (i.data("lazyload") != i.attr("src") && r < 3 && i.data("lazyload") != t && i.data("lazyload") != "undefined") {
        if (i.data("lazyload") != t && i.data("lazyload") != "undefined") {
          i.attr("src", i.data("lazyload"));
          var s = new Image();

          s.onload = function (e) {
            i.data("lazydone", 1);
            if (i.hasClass("defaultimg")) T(i, s);
          };

          s.error = function () {
            i.data("lazydone", 1);
          };

          s.src = i.attr("src");

          if (s.complete) {
            if (i.hasClass("defaultimg")) T(i, s);
            i.data("lazydone", 1);
          }
        }
      } else {
        if ((i.data("lazyload") === t || i.data("lazyload") === "undefined") && i.data("lazydone") != 1) {
          var s = new Image();

          s.onload = function () {
            if (i.hasClass("defaultimg")) T(i, s);
            i.data("lazydone", 1);
          };

          s.error = function () {
            i.data("lazydone", 1);
          };

          if (i.attr("src") != t && i.attr("src") != "undefined") {
            s.src = i.attr("src");
          } else s.src = i.data("src");

          if (s.complete) {
            if (i.hasClass("defaultimg")) {
              T(i, s);
            }

            i.data("lazydone", 1);
          }
        }
      }
    });
  }

  function T(e, t) {
    var n = e.closest("li");
    var r = t.width;
    var i = t.height;
    n.data("owidth", r);
    n.data("oheight", i);
    n.find(".slotholder").data("owidth", r);
    n.find(".slotholder").data("oheight", i);
    n.data("loadeddone", 1);
  }

  function C(e, n) {
    try {
      var r = e.find(">ul:first-child >li:eq(" + n.act + ")");
    } catch (i) {
      var r = e.find(">ul:first-child >li:eq(1)");
    }

    n.lastslide = n.act;
    var s = e.find(">ul:first-child >li:eq(" + n.next + ")");
    var u = s.find(".defaultimg");
    n.bannertimeronpause = true;
    e.trigger("stoptimer");
    n.cd = 0;

    if (u.data("lazyload") != t && u.data("lazyload") != "undefined" && u.data("lazydone") != 1) {
      if (!o(8)) u.css({
        backgroundImage: 'url("' + s.find(".defaultimg").data("lazyload") + '")'
      });else {
        u.attr("src", s.find(".defaultimg").data("lazyload"));
      }
      u.data("src", s.find(".defaultimg").data("lazyload"));
      u.data("lazydone", 1);
      u.data("orgw", 0);
      s.data("loadeddone", 1);
      TweenLite.set(e.find(".tp-loader"), {
        display: "block",
        opacity: 0
      });
      TweenLite.to(e.find(".tp-loader"), .3, {
        autoAlpha: 1
      });
      N(s, function () {
        k(n, u, e);
      }, n);
    } else {
      if (s.data("loadeddone") === t) {
        s.data("loadeddone", 1);
        N(s, function () {
          k(n, u, e);
        }, n);
      } else k(n, u, e);
    }
  }

  function k(e, t, n) {
    e.bannertimeronpause = false;
    e.cd = 0;
    n.trigger("nulltimer");
    TweenLite.to(n.find(".tp-loader"), .3, {
      autoAlpha: 0
    });
    g(t, e);
    m(n, e);
    g(t, e);
    L(n, e);
  }

  function L(n, r) {
    function x() {
      e.each(v, function (e, t) {
        if (t[0] == p || t[8] == p) {
          l = t[1];
          d = t[2];
          y = E;
        }

        E = E + 1;
      });
    }

    n.trigger("revolution.slide.onbeforeswap");
    r.transition = 1;
    r.videoplaying = false;

    try {
      var i = n.find(">ul:first-child >li:eq(" + r.act + ")");
    } catch (s) {
      var i = n.find(">ul:first-child >li:eq(1)");
    }

    r.lastslide = r.act;
    var u = n.find(">ul:first-child >li:eq(" + r.next + ")");
    var a = i.find(".slotholder");
    var f = u.find(".slotholder");
    i.css({
      visibility: "visible"
    });
    u.css({
      visibility: "visible"
    });

    if (f.data("kenburns") == "on") {
      _(n, r);

      TweenLite.set(n.find(".kenburnimg img"), {
        autoAlpha: 0
      });
    }

    if (r.ie) {
      if (p == "boxfade") p = "boxslide";
      if (p == "slotfade-vertical") p = "slotzoom-vertical";
      if (p == "slotfade-horizontal") p = "slotzoom-horizontal";
    }

    if (u.data("delay") != t) {
      r.cd = 0;
      r.delay = u.data("delay");
    } else {
      r.delay = r.origcd;
    }

    n.trigger("restarttimer");
    i.css({
      left: "0px",
      top: "0px"
    });
    u.css({
      left: "0px",
      top: "0px"
    });

    if (u.data("differentissplayed") == "prepared") {
      u.data("differentissplayed", "done");
      u.data("transition", u.data("savedtransition"));
      u.data("slotamount", u.data("savedslotamount"));
      u.data("masterspeed", u.data("savedmasterspeed"));
    }

    if (u.data("fstransition") != t && u.data("differentissplayed") != "done") {
      u.data("savedtransition", u.data("transition"));
      u.data("savedslotamount", u.data("slotamount"));
      u.data("savedmasterspeed", u.data("masterspeed"));
      u.data("transition", u.data("fstransition"));
      u.data("slotamount", u.data("fsslotamount"));
      u.data("masterspeed", u.data("fsmasterspeed"));
      u.data("differentissplayed", "prepared");
    }

    var l = 0;
    var c = u.data("transition").split(",");
    var h = u.data("nexttransid");

    if (h == t) {
      h = 0;
      u.data("nexttransid", h);
    } else {
      h = h + 1;
      if (h == c.length) h = 0;
      u.data("nexttransid", h);
    }

    var p = c[h];
    var d = 0;

    if (r.parallax == "scroll" && r.parallaxFirstGo == t) {
      r.parallaxFirstGo = true;
      M(n, r);
      setTimeout(function () {
        M(n, r);
      }, 210);
      setTimeout(function () {
        M(n, r);
      }, 420);
    }

    if (p == "slidehorizontal") {
      p = "slideleft";
      if (r.leftarrowpressed == 1) p = "slideright";
    }

    if (p == "slidevertical") {
      p = "slideup";
      if (r.leftarrowpressed == 1) p = "slidedown";
    }

    var v = [["boxslide", 0, 1, 10, 0, "box", false, null, 0], ["boxfade", 1, 0, 10, 0, "box", false, null, 1], ["slotslide-horizontal", 2, 0, 0, 200, "horizontal", true, false, 2], ["slotslide-vertical", 3, 0, 0, 200, "vertical", true, false, 3], ["curtain-1", 4, 3, 0, 0, "horizontal", true, true, 4], ["curtain-2", 5, 3, 0, 0, "horizontal", true, true, 5], ["curtain-3", 6, 3, 25, 0, "horizontal", true, true, 6], ["slotzoom-horizontal", 7, 0, 0, 400, "horizontal", true, true, 7], ["slotzoom-vertical", 8, 0, 0, 0, "vertical", true, true, 8], ["slotfade-horizontal", 9, 0, 0, 500, "horizontal", true, null, 9], ["slotfade-vertical", 10, 0, 0, 500, "vertical", true, null, 10], ["fade", 11, 0, 1, 300, "horizontal", true, null, 11], ["slideleft", 12, 0, 1, 0, "horizontal", true, true, 12], ["slideup", 13, 0, 1, 0, "horizontal", true, true, 13], ["slidedown", 14, 0, 1, 0, "horizontal", true, true, 14], ["slideright", 15, 0, 1, 0, "horizontal", true, true, 15], ["papercut", 16, 0, 0, 600, "", null, null, 16], ["3dcurtain-horizontal", 17, 0, 20, 100, "vertical", false, true, 17], ["3dcurtain-vertical", 18, 0, 10, 100, "horizontal", false, true, 18], ["cubic", 19, 0, 20, 600, "horizontal", false, true, 19], ["cube", 19, 0, 20, 600, "horizontal", false, true, 20], ["flyin", 20, 0, 4, 600, "vertical", false, true, 21], ["turnoff", 21, 0, 1, 1600, "horizontal", false, true, 22], ["incube", 22, 0, 20, 600, "horizontal", false, true, 23], ["cubic-horizontal", 23, 0, 20, 500, "vertical", false, true, 24], ["cube-horizontal", 23, 0, 20, 500, "vertical", false, true, 25], ["incube-horizontal", 24, 0, 20, 500, "vertical", false, true, 26], ["turnoff-vertical", 25, 0, 1, 1600, "horizontal", false, true, 27], ["fadefromright", 12, 1, 1, 0, "horizontal", true, true, 28], ["fadefromleft", 15, 1, 1, 0, "horizontal", true, true, 29], ["fadefromtop", 14, 1, 1, 0, "horizontal", true, true, 30], ["fadefrombottom", 13, 1, 1, 0, "horizontal", true, true, 31], ["fadetoleftfadefromright", 12, 2, 1, 0, "horizontal", true, true, 32], ["fadetorightfadetoleft", 15, 2, 1, 0, "horizontal", true, true, 33], ["fadetobottomfadefromtop", 14, 2, 1, 0, "horizontal", true, true, 34], ["fadetotopfadefrombottom", 13, 2, 1, 0, "horizontal", true, true, 35], ["parallaxtoright", 12, 3, 1, 0, "horizontal", true, true, 36], ["parallaxtoleft", 15, 3, 1, 0, "horizontal", true, true, 37], ["parallaxtotop", 14, 3, 1, 0, "horizontal", true, true, 38], ["parallaxtobottom", 13, 3, 1, 0, "horizontal", true, true, 39], ["scaledownfromright", 12, 4, 1, 0, "horizontal", true, true, 40], ["scaledownfromleft", 15, 4, 1, 0, "horizontal", true, true, 41], ["scaledownfromtop", 14, 4, 1, 0, "horizontal", true, true, 42], ["scaledownfrombottom", 13, 4, 1, 0, "horizontal", true, true, 43], ["zoomout", 13, 5, 1, 0, "horizontal", true, true, 44], ["zoomin", 13, 6, 1, 0, "horizontal", true, true, 45], ["notransition", 26, 0, 1, 0, "horizontal", true, null, 46]];
    var m = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45];
    var g = [16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27];
    var l = 0;
    var d = 1;
    var y = 0;
    var E = 0;
    var S = new Array();

    if (p == "random") {
      p = Math.round(Math.random() * v.length - 1);
      if (p > v.length - 1) p = v.length - 1;
    }

    if (p == "random-static") {
      p = Math.round(Math.random() * m.length - 1);
      if (p > m.length - 1) p = m.length - 1;
      p = m[p];
    }

    if (p == "random-premium") {
      p = Math.round(Math.random() * g.length - 1);
      if (p > g.length - 1) p = g.length - 1;
      p = g[p];
    }

    if (r.isJoomla == true && p == 16) {
      p = Math.round(Math.random() * g.length - 2) + 1;
      if (p > g.length - 1) p = g.length - 1;
      p = g[p];
    }

    x();

    if (o(8) && l > 15 && l < 28) {
      p = Math.round(Math.random() * m.length - 1);
      if (p > m.length - 1) p = m.length - 1;
      p = m[p];
      E = 0;
      x();
    }

    var T = -1;
    if (r.leftarrowpressed == 1 || r.act > r.next) T = 1;
    r.leftarrowpressed = 0;
    if (l > 26) l = 26;
    if (l < 0) l = 0;
    var N = 300;
    if (u.data("masterspeed") != t && u.data("masterspeed") > 99 && u.data("masterspeed") < 4001) N = u.data("masterspeed");
    S = v[y];
    n.parent().find(".bullet").each(function () {
      var t = e(this);
      t.removeClass("selected");

      if (r.navigationArrows == "withbullet" || r.navigationArrows == "nexttobullets") {
        if (t.index() - 1 == r.next) t.addClass("selected");
      } else {
        if (t.index() == r.next) t.addClass("selected");
      }
    });
    n.find(">li").each(function () {
      var t = e(this);
      if (t.index != r.act && t.index != r.next) t.css({
        "z-index": 16
      });
    });
    i.css({
      "z-index": 18
    });
    u.css({
      "z-index": 20
    });
    u.css({
      opacity: 0
    });

    if (i.index() != u.index() && r.firststart != 1) {
      Y(i, r);
    }

    J(u, r);

    if (u.data("slotamount") == t || u.data("slotamount") < 1) {
      r.slots = Math.round(Math.random() * 12 + 4);
      if (p == "boxslide") r.slots = Math.round(Math.random() * 6 + 3);else if (p == "flyin") r.slots = Math.round(Math.random() * 4 + 1);
    } else {
      r.slots = u.data("slotamount");
    }

    if (u.data("rotate") == t) r.rotate = 0;else if (u.data("rotate") == 999) r.rotate = Math.round(Math.random() * 360);else r.rotate = u.data("rotate");
    if (!e.support.transition || r.ie || r.ie9) r.rotate = 0;

    if (r.firststart == 1) {
      i.css({
        opacity: 0
      });
      r.firststart = 0;
    }

    N = N + S[4];
    if ((l == 4 || l == 5 || l == 6) && r.slots < 3) r.slots = 3;
    if (S[3] != 0) r.slots = Math.min(r.slots, S[3]);
    if (l == 9) r.slots = r.width / 20;
    if (l == 10) r.slots = r.height / 20;

    if (S[5] == "box") {
      if (S[7] != null) w(a, r, S[7]);
      if (S[6] != null) w(f, r, S[6]);
    } else if (S[5] == "vertical" || S[5] == "horizontal") {
      if (S[7] != null) b(a, r, S[7], S[5]);
      if (S[6] != null) b(f, r, S[6], S[5]);
    }

    if (l < 12 || l > 16) u.css({
      opacity: 1
    });

    if (l == 0) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      var C = Math.ceil(r.height / r.sloth);
      var k = 0;
      f.find(".slotslide").each(function (t) {
        var s = e(this);
        k = k + 1;
        if (k == C) k = 0;
        TweenLite.fromTo(s, N / 600, {
          opacity: 0,
          top: 0 - r.sloth,
          left: 0 - r.slotw,
          rotation: r.rotate
        }, {
          opacity: 1,
          transformPerspective: 600,
          top: 0,
          left: 0,
          scale: 1,
          rotation: 0,
          delay: (t * 15 + k * 30) / 1500,
          ease: Power2.easeOut,
          onComplete: function () {
            if (t == r.slots * r.slots - 1) {
              q(n, r, f, a, u, i);
            }
          }
        });
      });
    }

    if (l == 1) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      var L;
      f.find(".slotslide").each(function (t) {
        var n = e(this);
        rand = Math.random() * N + 300;
        rand2 = Math.random() * 500 + 200;
        if (rand + rand2 > L) L = rand2 + rand2;
        TweenLite.fromTo(n, rand / 1e3, {
          opacity: 0,
          transformPerspective: 600,
          rotation: r.rotate
        }, {
          opacity: 1,
          ease: Power2.easeInOut,
          rotation: 0,
          delay: rand2 / 1e3
        });
      });
      setTimeout(function () {
        q(n, r, f, a, u, i);
      }, N + 300);
    }

    if (l == 2) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      a.find(".slotslide").each(function () {
        var t = e(this);
        TweenLite.to(t, N / 1e3, {
          left: r.slotw,
          rotation: 0 - r.rotate,
          onComplete: function () {
            q(n, r, f, a, u, i);
          }
        });
      });
      f.find(".slotslide").each(function () {
        var t = e(this);
        TweenLite.fromTo(t, N / 1e3, {
          left: 0 - r.slotw,
          rotation: r.rotate,
          transformPerspective: 600
        }, {
          left: 0,
          rotation: 0,
          ease: Power2.easeOut,
          onComplete: function () {
            q(n, r, f, a, u, i);
          }
        });
      });
    }

    if (l == 3) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      a.find(".slotslide").each(function () {
        var t = e(this);
        TweenLite.to(t, N / 1e3, {
          top: r.sloth,
          rotation: r.rotate,
          transformPerspective: 600,
          onComplete: function () {
            q(n, r, f, a, u, i);
          }
        });
      });
      f.find(".slotslide").each(function () {
        var t = e(this);
        TweenLite.fromTo(t, N / 1e3, {
          top: 0 - r.sloth,
          rotation: r.rotate,
          transformPerspective: 600
        }, {
          top: 0,
          rotation: 0,
          ease: Power2.easeOut,
          onComplete: function () {
            q(n, r, f, a, u, i);
          }
        });
      });
    }

    if (l == 4 || l == 5) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      setTimeout(function () {
        a.find(".defaultimg").css({
          opacity: 0
        });
      }, 100);
      var A = N / 1e3;
      var O = A;
      a.find(".slotslide").each(function (t) {
        var n = e(this);
        var i = t * A / r.slots;
        if (l == 5) i = (r.slots - t - 1) * A / r.slots / 1.5;
        TweenLite.to(n, A * 3, {
          transformPerspective: 600,
          top: 0 + r.height,
          opacity: .5,
          rotation: r.rotate,
          ease: Power2.easeInOut,
          delay: i
        });
      });
      f.find(".slotslide").each(function (t) {
        var s = e(this);
        var o = t * A / r.slots;
        if (l == 5) o = (r.slots - t - 1) * A / r.slots / 1.5;
        TweenLite.fromTo(s, A * 3, {
          top: 0 - r.height,
          opacity: .5,
          rotation: r.rotate,
          transformPerspective: 600
        }, {
          top: 0,
          opacity: 1,
          rotation: 0,
          ease: Power2.easeInOut,
          delay: o,
          onComplete: function () {
            if (t == r.slots - 1) {
              q(n, r, f, a, u, i);
            }
          }
        });
      });
    }

    if (l == 6) {
      if (r.slots < 2) r.slots = 2;
      f.find(".defaultimg").css({
        opacity: 0
      });
      setTimeout(function () {
        a.find(".defaultimg").css({
          opacity: 0
        });
      }, 100);
      a.find(".slotslide").each(function (t) {
        var n = e(this);
        if (t < r.slots / 2) var i = (t + 2) * 60;else var i = (2 + r.slots - t) * 60;
        TweenLite.to(n, (N + i) / 1e3, {
          top: 0 + r.height,
          opacity: 1,
          rotation: r.rotate,
          transformPerspective: 600,
          ease: Power2.easeInOut
        });
      });
      f.find(".slotslide").each(function (t) {
        var s = e(this);
        if (t < r.slots / 2) var o = (t + 2) * 60;else var o = (2 + r.slots - t) * 60;
        TweenLite.fromTo(s, (N + o) / 1e3, {
          top: 0 - r.height,
          opacity: 1,
          rotation: r.rotate,
          transformPerspective: 600
        }, {
          top: 0,
          opacity: 1,
          rotation: 0,
          ease: Power2.easeInOut,
          onComplete: function () {
            if (t == Math.round(r.slots / 2)) {
              q(n, r, f, a, u, i);
            }
          }
        });
      });
    }

    if (l == 7) {
      N = N * 2;
      f.find(".defaultimg").css({
        opacity: 0
      });
      setTimeout(function () {
        a.find(".defaultimg").css({
          opacity: 0
        });
      }, 100);
      a.find(".slotslide").each(function () {
        var t = e(this).find("div");
        TweenLite.to(t, N / 1e3, {
          left: 0 - r.slotw / 2 + "px",
          top: 0 - r.height / 2 + "px",
          width: r.slotw * 2 + "px",
          height: r.height * 2 + "px",
          opacity: 0,
          rotation: r.rotate,
          transformPerspective: 600,
          ease: Power2.easeOut
        });
      });
      f.find(".slotslide").each(function (t) {
        var s = e(this).find("div");
        TweenLite.fromTo(s, N / 1e3, {
          left: 0,
          top: 0,
          opacity: 0,
          transformPerspective: 600
        }, {
          left: 0 - t * r.slotw + "px",
          ease: Power2.easeOut,
          top: 0 + "px",
          width: r.width,
          height: r.height,
          opacity: 1,
          rotation: 0,
          delay: .1,
          onComplete: function () {
            q(n, r, f, a, u, i);
          }
        });
      });
    }

    if (l == 8) {
      N = N * 3;
      f.find(".defaultimg").css({
        opacity: 0
      });
      a.find(".slotslide").each(function () {
        var t = e(this).find("div");
        TweenLite.to(t, N / 1e3, {
          left: 0 - r.width / 2 + "px",
          top: 0 - r.sloth / 2 + "px",
          width: r.width * 2 + "px",
          height: r.sloth * 2 + "px",
          transformPerspective: 600,
          opacity: 0,
          rotation: r.rotate
        });
      });
      f.find(".slotslide").each(function (t) {
        var s = e(this).find("div");
        TweenLite.fromTo(s, N / 1e3, {
          left: 0,
          top: 0,
          opacity: 0,
          transformPerspective: 600
        }, {
          left: 0 + "px",
          top: 0 - t * r.sloth + "px",
          width: f.find(".defaultimg").data("neww") + "px",
          height: f.find(".defaultimg").data("newh") + "px",
          opacity: 1,
          rotation: 0,
          onComplete: function () {
            q(n, r, f, a, u, i);
          }
        });
      });
    }

    if (l == 9 || l == 10) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      var D = 0;
      f.find(".slotslide").each(function (t) {
        var n = e(this);
        D++;
        TweenLite.fromTo(n, N / 1e3, {
          opacity: 0,
          transformPerspective: 600,
          left: 0,
          top: 0
        }, {
          opacity: 1,
          ease: Power2.easeInOut,
          delay: t * 4 / 1e3
        });
      });
      setTimeout(function () {
        q(n, r, f, a, u, i);
      }, N + D * 4);
    }

    if (l == 11 || l == 26) {
      f.find(".defaultimg").css({
        opacity: 0,
        position: "relative"
      });
      var D = 0;
      if (l == 26) N = 0;
      f.find(".slotslide").each(function (t) {
        var n = e(this);
        TweenLite.fromTo(n, N / 1e3, {
          opacity: 0
        }, {
          opacity: 1,
          ease: Power2.easeInOut
        });
      });
      setTimeout(function () {
        q(n, r, f, a, u, i);
      }, N + 15);
    }

    if (l == 12 || l == 13 || l == 14 || l == 15) {
      setTimeout(function () {
        a.find(".defaultimg").css({
          opacity: 0
        });
      }, 100);
      f.find(".defaultimg").css({
        opacity: 0
      });
      var P = r.width;
      var H = r.height;
      var B = f.find(".slotslide");

      if (r.fullWidth == "on" || r.fullSreen == "on") {
        P = B.width();
        H = B.height();
      }

      var j = 0;
      var F = 0;
      if (l == 12) j = P;else if (l == 15) j = 0 - P;else if (l == 13) F = H;else if (l == 14) F = 0 - H;
      var I = 1;
      var R = 1;
      var U = 1;
      var z = Power2.easeInOut;
      var W = Power2.easeInOut;
      var X = N / 1e3;
      var V = X;
      if (d == 1) I = 0;
      if (d == 2) I = 0;

      if (d == 3) {
        z = Power2.easeInOut;
        W = Power1.easeInOut;
        i.css({
          position: "absolute",
          "z-index": 20
        });
        u.css({
          position: "absolute",
          "z-index": 15
        });
        X = N / 1200;
      }

      if (d == 4 || d == 5) R = .6;
      if (d == 6) R = 1.4;

      if (d == 5 || d == 6) {
        U = 1.4;
        I = 0;
        P = 0;
        H = 0;
        j = 0;
        F = 0;
      }

      if (d == 6) U = .6;
      TweenLite.fromTo(B, X, {
        left: j,
        top: F,
        scale: U,
        opacity: I,
        rotation: r.rotate
      }, {
        opacity: 1,
        rotation: 0,
        left: 0,
        top: 0,
        scale: 1,
        ease: W,
        onComplete: function () {
          q(n, r, f, a, u, i);
          i.css({
            position: "absolute",
            "z-index": 18
          });
          u.css({
            position: "absolute",
            "z-index": 20
          });
        }
      });
      var $ = a.find(".slotslide");

      if (d == 4 || d == 5) {
        P = 0;
        H = 0;
      }

      if (d != 1) {
        if (l == 12) TweenLite.to($, V, {
          left: 0 - P + "px",
          scale: R,
          opacity: I,
          rotation: r.rotate,
          ease: z
        });else if (l == 15) TweenLite.to($, V, {
          left: P + "px",
          scale: R,
          opacity: I,
          rotation: r.rotate,
          ease: z
        });else if (l == 13) TweenLite.to($, V, {
          top: 0 - H + "px",
          scale: R,
          opacity: I,
          rotation: r.rotate,
          ease: z
        });else if (l == 14) TweenLite.to($, V, {
          top: H + "px",
          scale: R,
          opacity: I,
          rotation: r.rotate,
          ease: z
        });
      }

      u.css({
        opacity: 1
      });
    }

    if (l == 16) {
      i.css({
        position: "absolute",
        "z-index": 20
      });
      u.css({
        position: "absolute",
        "z-index": 15
      });
      i.wrapInner('<div class="tp-half-one" style="position:relative; width:100%;height:100%"></div>');
      i.find(".tp-half-one").clone(true).appendTo(i).addClass("tp-half-two");
      i.find(".tp-half-two").removeClass("tp-half-one");
      var P = r.width;
      var H = r.height;
      if (r.autoHeight == "on") H = n.height();
      i.find(".tp-half-one .defaultimg").wrap('<div class="tp-papercut" style="width:' + P + "px;height:" + H + 'px;"></div>');
      i.find(".tp-half-two .defaultimg").wrap('<div class="tp-papercut" style="width:' + P + "px;height:" + H + 'px;"></div>');
      i.find(".tp-half-two .defaultimg").css({
        position: "absolute",
        top: "-50%"
      });
      i.find(".tp-half-two .tp-caption").wrapAll('<div style="position:absolute;top:-50%;left:0px"></div>');
      TweenLite.set(i.find(".tp-half-two"), {
        width: P,
        height: H,
        overflow: "hidden",
        zIndex: 15,
        position: "absolute",
        top: H / 2,
        left: "0px",
        transformPerspective: 600,
        transformOrigin: "center bottom"
      });
      TweenLite.set(i.find(".tp-half-one"), {
        width: P,
        height: H / 2,
        overflow: "visible",
        zIndex: 10,
        position: "absolute",
        top: "0px",
        left: "0px",
        transformPerspective: 600,
        transformOrigin: "center top"
      });
      var K = i.find(".defaultimg");
      var Q = Math.round(Math.random() * 20 - 10);
      var G = Math.round(Math.random() * 20 - 10);
      var Z = Math.round(Math.random() * 20 - 10);
      var et = Math.random() * .4 - .2;
      var tt = Math.random() * .4 - .2;
      var nt = Math.random() * 1 + 1;
      var rt = Math.random() * 1 + 1;
      TweenLite.fromTo(i.find(".tp-half-one"), N / 1e3, {
        width: P,
        height: H / 2,
        position: "absolute",
        top: "0px",
        left: "0px",
        transformPerspective: 600,
        transformOrigin: "center top"
      }, {
        scale: nt,
        rotation: Q,
        y: 0 - H - H / 4,
        ease: Power2.easeInOut
      });
      setTimeout(function () {
        TweenLite.set(i.find(".tp-half-one"), {
          overflow: "hidden"
        });
      }, 50);
      TweenLite.fromTo(i.find(".tp-half-one"), N / 2e3, {
        opacity: 1,
        transformPerspective: 600,
        transformOrigin: "center center"
      }, {
        opacity: 0,
        delay: N / 2e3
      });
      TweenLite.fromTo(i.find(".tp-half-two"), N / 1e3, {
        width: P,
        height: H,
        overflow: "hidden",
        position: "absolute",
        top: H / 2,
        left: "0px",
        transformPerspective: 600,
        transformOrigin: "center bottom"
      }, {
        scale: rt,
        rotation: G,
        y: H + H / 4,
        ease: Power2.easeInOut
      });
      TweenLite.fromTo(i.find(".tp-half-two"), N / 2e3, {
        opacity: 1,
        transformPerspective: 600,
        transformOrigin: "center center"
      }, {
        opacity: 0,
        delay: N / 2e3
      });
      if (i.html() != null) TweenLite.fromTo(u, (N - 200) / 1e3, {
        opacity: 0,
        scale: .8,
        x: r.width * et,
        y: H * tt,
        rotation: Z,
        transformPerspective: 600,
        transformOrigin: "center center"
      }, {
        rotation: 0,
        scale: 1,
        x: 0,
        y: 0,
        opacity: 1,
        ease: Power2.easeInOut
      });
      f.find(".defaultimg").css({
        opacity: 1
      });
      setTimeout(function () {
        i.css({
          position: "absolute",
          "z-index": 18
        });
        u.css({
          position: "absolute",
          "z-index": 20
        });
        f.find(".defaultimg").css({
          opacity: 1
        });
        a.find(".defaultimg").css({
          opacity: 0
        });

        if (i.find(".tp-half-one").length > 0) {
          i.find(".tp-half-one .defaultimg").unwrap();
          i.find(".tp-half-one .slotholder").unwrap();
        }

        i.find(".tp-half-two").remove();
        r.transition = 0;
        r.act = r.next;
      }, N);
      u.css({
        opacity: 1
      });
    }

    if (l == 17) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      f.find(".slotslide").each(function (t) {
        var s = e(this);
        TweenLite.fromTo(s, N / 800, {
          opacity: 0,
          rotationY: 0,
          scale: .9,
          rotationX: -110,
          transformPerspective: 600,
          transformOrigin: "center center"
        }, {
          opacity: 1,
          top: 0,
          left: 0,
          scale: 1,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          ease: Power3.easeOut,
          delay: t * .06,
          onComplete: function () {
            if (t == r.slots - 1) q(n, r, f, a, u, i);
          }
        });
      });
    }

    if (l == 18) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      f.find(".slotslide").each(function (t) {
        var s = e(this);
        TweenLite.fromTo(s, N / 500, {
          opacity: 0,
          rotationY: 310,
          scale: .9,
          rotationX: 10,
          transformPerspective: 600,
          transformOrigin: "center center"
        }, {
          opacity: 1,
          top: 0,
          left: 0,
          scale: 1,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          ease: Power3.easeOut,
          delay: t * .06,
          onComplete: function () {
            if (t == r.slots - 1) q(n, r, f, a, u, i);
          }
        });
      });
    }

    if (l == 19 || l == 22) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      setTimeout(function () {
        a.find(".defaultimg").css({
          opacity: 0
        });
      }, 100);
      var it = u.css("z-index");
      var st = i.css("z-index");
      var ot = 90;
      var I = 1;
      if (T == 1) ot = -90;

      if (l == 19) {
        var ut = "center center -" + r.height / 2;
        I = 0;
      } else {
        var ut = "center center " + r.height / 2;
      }

      TweenLite.fromTo(f, N / 2e3, {
        transformPerspective: 600,
        z: 0,
        x: 0,
        rotationY: 0
      }, {
        rotationY: 1,
        ease: Power1.easeInOut,
        z: -40
      });
      TweenLite.fromTo(f, N / 2e3, {
        transformPerspective: 600,
        z: -40,
        rotationY: 1
      }, {
        rotationY: 0,
        z: 0,
        ease: Power1.easeInOut,
        x: 0,
        delay: 3 * (N / 4e3)
      });
      TweenLite.fromTo(a, N / 2e3, {
        transformPerspective: 600,
        z: 0,
        x: 0,
        rotationY: 0
      }, {
        rotationY: 1,
        x: 0,
        ease: Power1.easeInOut,
        z: -40
      });
      TweenLite.fromTo(a, N / 2e3, {
        transformPerspective: 600,
        z: -40,
        x: 0,
        rotationY: 1
      }, {
        rotationY: 0,
        z: 0,
        x: 0,
        ease: Power1.easeInOut,
        delay: 3 * (N / 4e3)
      });
      f.find(".slotslide").each(function (t) {
        var s = e(this);
        TweenLite.fromTo(s, N / 1e3, {
          left: 0,
          rotationY: r.rotate,
          opacity: I,
          top: 0,
          scale: .8,
          transformPerspective: 600,
          transformOrigin: ut,
          rotationX: ot
        }, {
          left: 0,
          rotationY: 0,
          opacity: 1,
          top: 0,
          z: 0,
          scale: 1,
          rotationX: 0,
          delay: t * 50 / 1e3,
          ease: Power2.easeInOut,
          onComplete: function () {
            if (t == r.slots - 1) q(n, r, f, a, u, i);
          }
        });
        TweenLite.to(s, .1, {
          opacity: 1,
          delay: t * 50 / 1e3 + N / 3e3
        });
      });
      a.find(".slotslide").each(function (t) {
        var s = e(this);
        var o = -90;
        if (T == 1) o = 90;
        TweenLite.fromTo(s, N / 1e3, {
          opacity: 1,
          rotationY: 0,
          top: 0,
          z: 0,
          scale: 1,
          transformPerspective: 600,
          transformOrigin: ut,
          rotationX: 0
        }, {
          opacity: 1,
          rotationY: r.rotate,
          top: 0,
          scale: .8,
          rotationX: o,
          delay: t * 50 / 1e3,
          ease: Power2.easeInOut,
          onComplete: function () {
            if (t == r.slots - 1) q(n, r, f, a, u, i);
          }
        });
        TweenLite.to(s, .1, {
          opacity: 0,
          delay: t * 50 / 1e3 + (N / 1e3 - N / 1e4)
        });
      });
    }

    if (l == 20) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      setTimeout(function () {
        a.find(".defaultimg").css({
          opacity: 0
        });
      }, 100);
      var it = u.css("z-index");
      var st = i.css("z-index");

      if (T == 1) {
        var at = -r.width;
        var ot = 70;
        var ut = "left center -" + r.height / 2;
      } else {
        var at = r.width;
        var ot = -70;
        var ut = "right center -" + r.height / 2;
      }

      f.find(".slotslide").each(function (t) {
        var s = e(this);
        TweenLite.fromTo(s, N / 1500, {
          left: at,
          rotationX: 40,
          z: -600,
          opacity: I,
          top: 0,
          transformPerspective: 600,
          transformOrigin: ut,
          rotationY: ot
        }, {
          left: 0,
          delay: t * 50 / 1e3,
          ease: Power2.easeInOut
        });
        TweenLite.fromTo(s, N / 1e3, {
          rotationX: 40,
          z: -600,
          opacity: I,
          top: 0,
          scale: 1,
          transformPerspective: 600,
          transformOrigin: ut,
          rotationY: ot
        }, {
          rotationX: 0,
          opacity: 1,
          top: 0,
          z: 0,
          scale: 1,
          rotationY: 0,
          delay: t * 50 / 1e3,
          ease: Power2.easeInOut,
          onComplete: function () {
            if (t == r.slots - 1) q(n, r, f, a, u, i);
          }
        });
        TweenLite.to(s, .1, {
          opacity: 1,
          delay: t * 50 / 1e3 + N / 2e3
        });
      });
      a.find(".slotslide").each(function (t) {
        var s = e(this);

        if (T != 1) {
          var o = -r.width;
          var l = 70;
          var c = "left center -" + r.height / 2;
        } else {
          var o = r.width;
          var l = -70;
          var c = "right center -" + r.height / 2;
        }

        TweenLite.fromTo(s, N / 1e3, {
          opacity: 1,
          rotationX: 0,
          top: 0,
          z: 0,
          scale: 1,
          left: 0,
          transformPerspective: 600,
          transformOrigin: c,
          rotationY: 0
        }, {
          opacity: 1,
          rotationX: 40,
          top: 0,
          z: -600,
          left: o,
          scale: .8,
          rotationY: l,
          delay: t * 50 / 1e3,
          ease: Power2.easeInOut,
          onComplete: function () {
            if (t == r.slots - 1) q(n, r, f, a, u, i);
          }
        });
        TweenLite.to(s, .1, {
          opacity: 0,
          delay: t * 50 / 1e3 + (N / 1e3 - N / 1e4)
        });
      });
    }

    if (l == 21 || l == 25) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      setTimeout(function () {
        a.find(".defaultimg").css({
          opacity: 0
        });
      }, 100);
      var it = u.css("z-index");
      var st = i.css("z-index");

      if (T == 1) {
        var at = -r.width;
        var ot = 110;

        if (l == 25) {
          var ut = "center top 0";
          rot2 = -ot;
          ot = r.rotate;
        } else {
          var ut = "left center 0";
          rot2 = r.rotate;
        }
      } else {
        var at = r.width;
        var ot = -110;

        if (l == 25) {
          var ut = "center bottom 0";
          rot2 = -ot;
          ot = r.rotate;
        } else {
          var ut = "right center 0";
          rot2 = r.rotate;
        }
      }

      f.find(".slotslide").each(function (t) {
        var s = e(this);
        TweenLite.fromTo(s, N / 1500, {
          left: 0,
          rotationX: rot2,
          z: 0,
          opacity: 0,
          top: 0,
          scale: 1,
          transformPerspective: 600,
          transformOrigin: ut,
          rotationY: ot
        }, {
          left: 0,
          rotationX: 0,
          top: 0,
          z: 0,
          scale: 1,
          rotationY: 0,
          delay: t * 100 / 1e3 + N / 1e4,
          ease: Power2.easeInOut,
          onComplete: function () {
            if (t == r.slots - 1) q(n, r, f, a, u, i);
          }
        });
        TweenLite.to(s, .3, {
          opacity: 1,
          delay: t * 100 / 1e3 + N * .2 / 2e3 + N / 1e4
        });
      });

      if (T != 1) {
        var at = -r.width;
        var ot = 90;

        if (l == 25) {
          var ut = "center top 0";
          rot2 = -ot;
          ot = r.rotate;
        } else {
          var ut = "left center 0";
          rot2 = r.rotate;
        }
      } else {
        var at = r.width;
        var ot = -90;

        if (l == 25) {
          var ut = "center bottom 0";
          rot2 = -ot;
          ot = r.rotate;
        } else {
          var ut = "right center 0";
          rot2 = r.rotate;
        }
      }

      a.find(".slotslide").each(function (t) {
        var n = e(this);
        TweenLite.fromTo(n, N / 3e3, {
          left: 0,
          rotationX: 0,
          z: 0,
          opacity: 1,
          top: 0,
          scale: 1,
          transformPerspective: 600,
          transformOrigin: ut,
          rotationY: 0
        }, {
          left: 0,
          rotationX: rot2,
          top: 0,
          z: 0,
          scale: 1,
          rotationY: ot,
          delay: t * 100 / 1e3,
          ease: Power1.easeInOut
        });
        TweenLite.to(n, .2, {
          opacity: 0,
          delay: t * 50 / 1e3 + (N / 3e3 - N / 1e4)
        });
      });
    }

    if (l == 23 || l == 24) {
      f.find(".defaultimg").css({
        opacity: 0
      });
      setTimeout(function () {
        a.find(".defaultimg").css({
          opacity: 0
        });
      }, 100);
      var it = u.css("z-index");
      var st = i.css("z-index");
      var ot = -90;
      if (T == 1) ot = 90;
      var I = 1;

      if (l == 23) {
        var ut = "center center -" + r.width / 2;
        I = 0;
      } else {
        var ut = "center center " + r.width / 2;
      }

      var ft = 0;
      TweenLite.fromTo(f, N / 2e3, {
        transformPerspective: 600,
        z: 0,
        x: 0,
        rotationY: 0
      }, {
        rotationY: 1,
        ease: Power1.easeInOut,
        z: -90
      });
      TweenLite.fromTo(f, N / 2e3, {
        transformPerspective: 600,
        z: -90,
        rotationY: 1
      }, {
        rotationY: 0,
        z: 0,
        ease: Power1.easeInOut,
        x: 0,
        delay: 3 * (N / 4e3)
      });
      TweenLite.fromTo(a, N / 2e3, {
        transformPerspective: 600,
        z: 0,
        x: 0,
        rotationY: 0
      }, {
        rotationY: 1,
        x: 0,
        ease: Power1.easeInOut,
        z: -90
      });
      TweenLite.fromTo(a, N / 2e3, {
        transformPerspective: 600,
        z: -90,
        x: 0,
        rotationY: 1
      }, {
        rotationY: 0,
        z: 0,
        x: 0,
        ease: Power1.easeInOut,
        delay: 3 * (N / 4e3)
      });
      f.find(".slotslide").each(function (t) {
        var s = e(this);
        TweenLite.fromTo(s, N / 1e3, {
          left: ft,
          rotationX: r.rotate,
          opacity: I,
          top: 0,
          scale: 1,
          transformPerspective: 600,
          transformOrigin: ut,
          rotationY: ot
        }, {
          left: 0,
          rotationX: 0,
          opacity: 1,
          top: 0,
          z: 0,
          scale: 1,
          rotationY: 0,
          delay: t * 50 / 1e3,
          ease: Power2.easeInOut,
          onComplete: function () {
            if (t == r.slots - 1) q(n, r, f, a, u, i);
          }
        });
        TweenLite.to(s, .1, {
          opacity: 1,
          delay: t * 50 / 1e3 + N / 3e3
        });
      });
      ot = 90;
      if (T == 1) ot = -90;
      a.find(".slotslide").each(function (t) {
        var s = e(this);
        TweenLite.fromTo(s, N / 1e3, {
          left: 0,
          opacity: 1,
          rotationX: 0,
          top: 0,
          z: 0,
          scale: 1,
          transformPerspective: 600,
          transformOrigin: ut,
          rotationY: 0
        }, {
          left: ft,
          opacity: 1,
          rotationX: r.rotate,
          top: 0,
          scale: 1,
          rotationY: ot,
          delay: t * 50 / 1e3,
          ease: Power2.easeInOut,
          onComplete: function () {
            if (t == r.slots - 1) q(n, r, f, a, u, i);
          }
        });
        TweenLite.to(s, .1, {
          opacity: 0,
          delay: t * 50 / 1e3 + (N / 1e3 - N / 1e4)
        });
      });
    }

    var lt = {};
    lt.slideIndex = r.next + 1;
    n.trigger("revolution.slide.onchange", lt);
    setTimeout(function () {
      n.trigger("revolution.slide.onafterswap");
    }, N);
    n.trigger("revolution.slide.onvideostop");
  }

  function A(e, t) {}

  function O(t, n) {
    t.find(">ul:first-child >li").each(function () {
      var t = e(this);

      for (var r = 0; r < 10; r++) t.find(".rs-parallaxlevel-" + r).wrapAll('<div style="position:absolute;top:0px;left:0px;width:100%;height:100%;" class="tp-parallax-container" data-parallaxlevel="' + n.parallaxLevels[r] + '"></div>');
    });

    if (n.parallax == "mouse" || n.parallax == "scroll+mouse" || n.parallax == "mouse+scroll") {
      t.on("mousemove.hoverdir, mouseleave.hoverdir", function (n) {
        switch (n.type) {
          case "mousemove":
            var r = t.offset().top,
                i = t.offset().left,
                s = r + t.height() / 2,
                o = i + t.width() / 2,
                u = o - n.pageX,
                a = s - n.pageY;
            e(".tp-parallax-container").each(function () {
              var t = e(this),
                  n = parseInt(t.data("parallaxlevel"), 0) / 100,
                  r = u * n,
                  i = a * n;
              TweenLite.to(t, .2, {
                x: r,
                y: i,
                ease: Power3.easeOut
              });
            });
            break;

          case "mouseleave":
            e(".tp-parallax-container").each(function () {
              var t = e(this);
              TweenLite.to(t, .4, {
                x: 0,
                y: 0,
                ease: Power3.easeOut
              });
            });
            break;
        }
      });
      if (s()) window.ondeviceorientation = function (n) {
        var r = Math.round(n.beta || 0),
            i = Math.round(n.gamma || 0),
            s = 360 / t.width() * i,
            o = 180 / t.height() * r;
        e(".tp-parallax-container").each(function () {
          var t = e(this),
              n = parseInt(t.data("parallaxlevel"), 0) / 100,
              r = s * n,
              i = o * n;
          TweenLite.to(t, .2, {
            x: r,
            y: i,
            ease: Power3.easeOut
          });
        });
      };
    }

    if (n.parallax == "scroll" || n.parallax == "scroll+mouse" || n.parallax == "mouse+scroll") {
      e(window).on("scroll", function (e) {
        M(t, n);
      });
    }
  }

  function M(t, n) {
    var r = t.offset().top,
        i = e(window).scrollTop(),
        s = r + t.height() / 2,
        o = r + t.height() / 2 - i,
        u = e(window).height() / 2,
        a = u - o;
    if (s < u) a = a - (u - s);
    e(".tp-parallax-container").each(function () {
      var t = e(this),
          n = parseInt(t.data("parallaxlevel"), 0) / 100,
          r = a * n;
      TweenLite.to(t, .2, {
        y: r,
        ease: Power3.easeOut
      });
    });

    if (n.parallaxBgFreeze != "on") {
      var f = n.parallaxLevels[0] / 100,
          l = a * f;
      TweenLite.to(t, .2, {
        y: l,
        ease: Power3.easeOut
      });
    }
  }

  function _(n, r) {
    try {
      var i = n.find(">ul:first-child >li:eq(" + r.act + ")");
    } catch (s) {
      var i = n.find(">ul:first-child >li:eq(1)");
    }

    r.lastslide = r.act;
    var o = n.find(">ul:first-child >li:eq(" + r.next + ")");
    var u = i.find(".slotholder");
    var a = o.find(".slotholder");
    a.find(".defaultimg").each(function () {
      var n = e(this);

      if (n.data("kenburn") != t) {
        n.data("kenburn").restart();
      }

      TweenLite.killTweensOf(n, false);
      TweenLite.set(n, {
        scale: 1,
        rotationZ: 0
      });
      n.data("bgposition", a.data("bgposition"));
      n.data("currotate", a.data("rotationstart"));
      n.data("curscale", a.data("bgfit"));
    });
  }

  function D(n, r, i) {
    try {
      var s = n.find(">ul:first-child >li:eq(" + r.act + ")");
    } catch (u) {
      var s = n.find(">ul:first-child >li:eq(1)");
    }

    r.lastslide = r.act;
    var a = n.find(">ul:first-child >li:eq(" + r.next + ")");
    var f = s.find(".slotholder");
    var l = a.find(".slotholder");
    var c = l.data("bgposition"),
        h = l.data("bgpositionend"),
        p = l.data("zoomstart") / 100,
        d = l.data("zoomend") / 100,
        v = l.data("rotationstart"),
        m = l.data("rotationend"),
        g = l.data("bgfit"),
        y = l.data("bgfitend"),
        b = l.data("easeme"),
        w = l.data("duration") / 1e3,
        E = 100;
    if (g == t) g = 100;
    if (y == t) y = 100;
    g = H(g, l, r);
    y = H(y, l, r);
    E = H(100, l, r);
    if (p == t) p = 1;
    if (d == t) d = 1;
    if (v == t) v = 0;
    if (m == t) m = 0;
    if (p < 1) p = 1;
    if (d < 1) d = 1;
    var S = new Object();
    S.w = parseInt(E.split(" ")[0], 0), S.h = parseInt(E.split(" ")[1], 0);
    l.find(".defaultimg").each(function () {
      var t = e(this);
      if (l.find(".kenburnimg").length == 0) l.append('<div class="kenburnimg" style="position:absolute;z-index:1;width:100%;height:100%;top:0px;left:0px;"><img src="' + t.attr("src") + '" style="-webkit-touch-callout: none;-webkit-user-select: none;-khtml-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;position:absolute;width:' + S.w + "%;height:" + S.h + '%;"></div>');
      var n = l.find(".kenburnimg img");
      var i = P(r, c, g, n),
          s = P(r, h, y, n);
      t.data("kenburn", TweenLite.fromTo(n, w, {
        autoAlpha: 1,
        transformPerspective: 1200,
        transformOrigin: "0% 0%",
        top: 0,
        left: 0,
        scale: i.w,
        x: i.x,
        y: i.y
      }, {
        autoAlpha: 1,
        rotationZ: m,
        ease: b,
        x: s.x,
        y: s.y,
        scale: s.w,
        onUpdate: function () {
          var e = n[0]._gsTransform.scaleX;
          var i = e * n.width() - r.width,
              s = e * n.height() - r.height,
              u = Math.abs(n[0]._gsTransform.x / i * 100),
              a = Math.abs(n[0]._gsTransform.y / s * 100);
          t.data("bgposition", u + "% " + a + "%");
          if (!o(8)) t.data("currotate", I(n));
          if (!o(8)) t.data("curscale", S.w * e + "%  " + (S.h * e + "%"));
          TweenLite.set(t, {
            rotation: t.data("currotate"),
            backgroundPosition: t.data("bgposition"),
            backgroundSize: t.data("curscale")
          });
        }
      }));
    });
  }

  function P(e, t, n, r) {
    var i = new Object();
    i.w = parseInt(n.split(" ")[0], 0) / 100;

    switch (t) {
      case "left top":
      case "top left":
        i.x = 0;
        i.y = 0;
        break;

      case "center top":
      case "top center":
        i.x = ((0 - r.width()) * i.w + e.width) / 2;
        i.y = 0;
        break;

      case "top right":
      case "right top":
        i.x = (0 - r.width()) * i.w + e.width;
        i.y = 0;
        break;

      case "center left":
      case "left center":
        i.x = 0;
        i.y = ((0 - r.height()) * i.w + e.height) / 2;
        break;

      case "center center":
        i.x = ((0 - r.width()) * i.w + e.width) / 2;
        i.y = ((0 - r.height()) * i.w + e.height) / 2;
        break;

      case "center right":
      case "right center":
        i.x = (0 - r.width()) * i.w + e.width;
        i.y = ((0 - r.height()) * i.w + e.height) / 2;
        break;

      case "bottom left":
      case "left bottom":
        i.x = 0;
        i.y = (0 - r.height()) * i.w + e.height;
        break;

      case "bottom center":
      case "center bottom":
        i.x = ((0 - r.width()) * i.w + e.width) / 2;
        i.y = (0 - r.height()) * i.w + e.height;
        break;

      case "bottom right":
      case "right bottom":
        i.x = (0 - r.width()) * i.w + e.width;
        i.y = (0 - r.height()) * i.w + e.height;
        break;
    }

    return i;
  }

  function H(e, t, n) {
    var r = t.data("owidth");
    var i = t.data("oheight");
    var s = n.container.width() / r;
    var o = i * s;
    var u = o / n.container.height() * e;
    return e + "% " + u + "%";
  }

  function B(e) {
    var t = e.css("-webkit-transform") || e.css("-moz-transform") || e.css("-ms-transform") || e.css("-o-transform") || e.css("transform");
    return t;
  }

  function j(e) {
    return e.replace(/^matrix(3d)?\((.*)\)$/, "$2").split(/, /);
  }

  function F(e) {
    var t = j(B(e)),
        n = 1;

    if (t[0] !== "none") {
      var r = t[0],
          i = t[1],
          s = 10;
      n = Math.round(Math.sqrt(r * r + i * i) * s) / s;
    }

    return n;
  }

  function I(e) {
    var t = e.css("-webkit-transform") || e.css("-moz-transform") || e.css("-ms-transform") || e.css("-o-transform") || e.css("transform");

    if (t !== "none") {
      var n = t.split("(")[1].split(")")[0].split(",");
      var r = n[0];
      var i = n[1];
      var s = Math.round(Math.atan2(i, r) * (180 / Math.PI));
    } else {
      var s = 0;
    }

    return s < 0 ? s += 360 : s;
  }

  function q(e, t, n, r, i, s) {
    S(e, t);
    n.find(".defaultimg").css({
      opacity: 1
    });
    if (i.index() != s.index()) r.find(".defaultimg").css({
      opacity: 0
    });
    t.act = t.next;
    f(e);
    if (n.data("kenburns") == "on") D(e, t);
  }

  function R(t) {
    var n = t.target.getVideoEmbedCode();
    var r = e("#" + n.split('id="')[1].split('"')[0]);
    var i = r.closest(".tp-simpleresponsive");
    var s = r.parent().data("player");

    if (t.data == YT.PlayerState.PLAYING) {
      var o = i.find(".tp-bannertimer");
      var u = o.data("opt");
      if (r.closest(".tp-caption").data("volume") == "mute") s.mute();
      u.videoplaying = true;
      i.trigger("stoptimer");
      i.trigger("revolution.slide.onvideoplay");
    } else {
      var o = i.find(".tp-bannertimer");
      var u = o.data("opt");

      if (t.data != -1) {
        u.videoplaying = false;
        i.trigger("playtimer");
        i.trigger("revolution.slide.onvideostop");
      }
    }

    if (t.data == 0 && u.nextslideatend == true) u.container.revnext();
  }

  function U(e, t, n) {
    if (e.addEventListener) e.addEventListener(t, n, false);else e.attachEvent(t, n, false);
  }

  function z(t, n) {
    var r = $f(t);
    var i = e("#" + t);
    var s = i.closest(".tp-simpleresponsive");
    r.addEvent("ready", function (e) {
      if (n) r.api("play");
      r.addEvent("play", function (e) {
        var t = s.find(".tp-bannertimer");
        var n = t.data("opt");
        n.videoplaying = true;
        s.trigger("stoptimer");
        if (i.closest(".tp-caption").data("volume") == "mute") r.api("setVolume", "0");
      });
      r.addEvent("finish", function (e) {
        var t = s.find(".tp-bannertimer");
        var n = t.data("opt");
        n.videoplaying = false;
        s.trigger("playtimer");
        s.trigger("revolution.slide.onvideoplay");
        if (n.nextslideatend == true) n.container.revnext();
      });
      r.addEvent("pause", function (e) {
        var t = s.find(".tp-bannertimer");
        var n = t.data("opt");
        n.videoplaying = false;
        s.trigger("playtimer");
        s.trigger("revolution.slide.onvideostop");
      });
    });
  }

  function W(e, t) {
    var n = t.width();
    var r = t.height();
    var i = e.data("mediaAspect");
    var s = n / r;
    e.css({
      position: "absolute"
    });
    var o = e.find("video");

    if (s < i) {
      e.width(r * i).height(r);
      e.css("top", 0).css("left", -(r * i - n) / 2).css("height", r);
    } else {
      e.width(n).height(n / i);
      e.css("top", -(n / i - r) / 2).css("left", 0).css("height", n / i);
    }
  }

  function X() {
    var e = new Object();
    e.x = 0;
    e.y = 0;
    e.rotationX = 0;
    e.rotationY = 0;
    e.rotationZ = 0;
    e.scale = 1;
    e.scaleX = 1;
    e.scaleY = 1;
    e.skewX = 0;
    e.skewY = 0;
    e.opacity = 0;
    e.transformOrigin = "center, center";
    e.transformPerspective = 400;
    e.rotation = 0;
    return e;
  }

  function V(t, n) {
    var r = n.split(";");
    e.each(r, function (e, n) {
      n = n.split(":");
      var r = n[0],
          i = n[1];
      if (r == "rotationX") t.rotationX = parseInt(i, 0);
      if (r == "rotationY") t.rotationY = parseInt(i, 0);
      if (r == "rotationZ") t.rotationZ = parseInt(i, 0);
      if (r == "rotationZ") t.rotation = parseInt(i, 0);
      if (r == "scaleX") t.scaleX = parseFloat(i);
      if (r == "scaleY") t.scaleY = parseFloat(i);
      if (r == "opacity") t.opacity = parseFloat(i);
      if (r == "skewX") t.skewX = parseInt(i, 0);
      if (r == "skewY") t.skewY = parseInt(i, 0);
      if (r == "x") t.x = parseInt(i, 0);
      if (r == "y") t.y = parseInt(i, 0);
      if (r == "z") t.z = parseInt(i, 0);
      if (r == "transformOrigin") t.transformOrigin = i.toString();
      if (r == "transformPerspective") t.transformPerspective = parseInt(i, 0);
    });
    return t;
  }

  function $(t) {
    var n = t.split("animation:");
    var r = new Object();
    r.animation = V(X(), n[1]);
    var i = n[0].split(";");
    e.each(i, function (e, t) {
      t = t.split(":");
      var n = t[0],
          i = t[1];
      if (n == "typ") r.typ = i;
      if (n == "speed") r.speed = parseInt(i, 0) / 1e3;
      if (n == "start") r.start = parseInt(i, 0) / 1e3;
      if (n == "elementdelay") r.elementdelay = parseFloat(i);
      if (n == "ease") r.ease = i;
    });
    return r;
  }

  function J(n, r, i) {
    var o = 0;
    var u = 0;
    n.find(".tp-caption").each(function (n) {
      o = r.width / 2 - r.startwidth * r.bw / 2;
      var a = r.bw;
      var f = r.bh;
      if (r.fullScreen == "on") u = r.height / 2 - r.startheight * r.bh / 2;
      if (r.autoHeight == "on") u = r.container.height() / 2 - r.startheight * r.bh / 2;
      if (u < 0) u = 0;
      var l = e(this);
      var c = 0;

      if (r.width < r.hideCaptionAtLimit && l.data("captionhidden") == "on") {
        l.addClass("tp-hidden-caption");
        c = 1;
      } else {
        if (r.width < r.hideAllCaptionAtLimit || r.width < r.hideAllCaptionAtLilmit) {
          l.addClass("tp-hidden-caption");
          c = 1;
        } else {
          l.removeClass("tp-hidden-caption");
        }
      }

      if (c == 0) {
        if (l.data("linktoslide") != t && !l.hasClass("hasclicklistener")) {
          l.addClass("hasclicklistener");
          l.css({
            cursor: "pointer"
          });

          if (l.data("linktoslide") != "no") {
            l.click(function () {
              var t = e(this);
              var n = t.data("linktoslide");

              if (n != "next" && n != "prev") {
                r.container.data("showus", n);
                r.container.parent().find(".tp-rightarrow").click();
              } else if (n == "next") r.container.parent().find(".tp-rightarrow").click();else if (n == "prev") r.container.parent().find(".tp-leftarrow").click();
            });
          }
        }

        if (o < 0) o = 0;
        var h = "iframe" + Math.round(Math.random() * 1e3 + 1);

        if (l.find("iframe").length > 0 || l.find("video").length > 0) {
          if (l.data("autoplayonlyfirsttime") == true || l.data("autoplayonlyfirsttime") == "true") {
            l.data("autoplay", true);
          }

          l.find("iframe").each(function () {
            var n = e(this);

            if (s()) {
              var o = n.attr("src");
              n.attr("src", "");
              n.attr("src", o);
            }

            r.nextslideatend = l.data("nextslideatend");

            if (l.data("thumbimage") != t && l.data("thumbimage").length > 2 && l.data("autoplay") != true && !i) {
              l.find(".tp-thumb-image").remove();
              l.append('<div class="tp-thumb-image" style="cursor:pointer; position:absolute;top:0px;left:0px;width:100%;height:100%;background-image:url(' + l.data("thumbimage") + '); background-size:cover"></div>');
            }

            if (n.attr("src").toLowerCase().indexOf("youtube") >= 0) {
              if (!n.hasClass("HasListener")) {
                try {
                  n.attr("id", h);
                  var u;
                  var a = setInterval(function () {
                    if (YT != t) if (typeof YT.Player != t && typeof YT.Player != "undefined") {
                      if (l.data("autoplay") == true) {
                        u = new YT.Player(h, {
                          events: {
                            onStateChange: R,
                            onReady: function (e) {
                              e.target.playVideo();
                            }
                          }
                        });
                      } else u = new YT.Player(h, {
                        events: {
                          onStateChange: R
                        }
                      });

                      n.addClass("HasListener");
                      l.data("player", u);
                      clearInterval(a);
                    }
                  }, 100);
                } catch (f) {}
              } else {
                if (l.data("autoplay") == true) {
                  var u = l.data("player");
                  l.data("timerplay", setTimeout(function () {
                    if (l.data("forcerewind") == "on") u.seekTo(0);
                    u.playVideo();
                  }, l.data("start")));
                }
              }

              l.find(".tp-thumb-image").click(function () {
                TweenLite.to(e(this), .3, {
                  opacity: 0,
                  ease: Power3.easeInOut,
                  onComplete: function () {
                    l.find(".tp-thumb-image").remove();
                  }
                });
                var t = l.data("player");
                t.playVideo();
              });
            } else {
              if (n.attr("src").toLowerCase().indexOf("vimeo") >= 0) {
                if (!n.hasClass("HasListener")) {
                  n.addClass("HasListener");
                  n.attr("id", h);
                  var c = n.attr("src");
                  var p = {},
                      d = c,
                      v = /([^&=]+)=([^&]*)/g,
                      m;

                  while (m = v.exec(d)) {
                    p[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
                  }

                  if (p["player_id"] != t) c = c.replace(p["player_id"], h);else c = c + "&player_id=" + h;

                  try {
                    c = c.replace("api=0", "api=1");
                  } catch (f) {}

                  c = c + "&api=1";
                  n.attr("src", c);
                  var u = l.find("iframe")[0];
                  var g = setInterval(function () {
                    if ($f != t) if (typeof $f(h).api != t && typeof $f(h).api != "undefined") {
                      $f(u).addEvent("ready", function () {
                        z(h, l.data("autoplay"));
                      });
                      clearInterval(g);
                    }
                  }, 100);
                } else {
                  if (l.data("autoplay") == true) {
                    var n = l.find("iframe");
                    var y = n.attr("id");
                    var g = setInterval(function () {
                      if ($f != t) if (typeof $f(y).api != t && typeof $f(y).api != "undefined") {
                        var e = $f(y);
                        l.data("timerplay", setTimeout(function () {
                          if (l.data("forcerewind") == "on") e.api("seekTo", 0);
                          e.api("play");
                        }, l.data("start")));
                        clearInterval(g);
                      }
                    }, 100);
                  }
                }

                l.find(".tp-thumb-image").click(function () {
                  TweenLite.to(e(this), .3, {
                    opacity: 0,
                    ease: Power3.easeInOut,
                    onComplete: function () {
                      l.find(".tp-thumb-image").remove();
                    }
                  });
                  var n = l.find("iframe");
                  var r = n.attr("id");
                  var i = setInterval(function () {
                    if ($f != t) if (typeof $f(r).api != t && typeof $f(r).api != "undefined") {
                      var e = $f(r);
                      e.api("play");
                      clearInterval(i);
                    }
                  }, 100);
                });
              }
            }
          });

          if (l.find("video").length > 0) {
            l.find("video").each(function (n) {
              var i = e(this);
              var s = this;

              if (!i.parent().hasClass("html5vid")) {
                i.wrap('<div class="html5vid" style="position:relative;top:0px;left:0px;width:auto;height:auto"></div>');
              }

              var o = e(this).parent();
              if (s.addEventListener) s.addEventListener("loadedmetadata", function () {
                o.data("metaloaded", 1);
              });else s.attachEvent("loadedmetadata", function () {
                o.data("metaloaded", 1);
              });

              if (!i.hasClass("HasListener")) {
                i.addClass("HasListener");
                s.addEventListener("play", function () {
                  o.addClass("videoisplaying");
                  o.find(".tp-poster").remove();
                  if (l.data("volume") == "mute") s.muted = true;
                  r.container.trigger("revolution.slide.onvideoplay");
                  r.videoplaying = true;
                  r.container.trigger("stoptimer");
                });
                s.addEventListener("pause", function () {
                  o.removeClass("videoisplaying");
                  r.videoplaying = false;
                  r.container.trigger("playtimer");
                  r.container.trigger("revolution.slide.onvideostop");
                });
                s.addEventListener("ended", function () {
                  o.removeClass("videoisplaying");
                  r.videoplaying = false;
                  r.container.trigger("playtimer");
                  r.container.trigger("revolution.slide.onvideostop");
                  if (r.nextslideatend == true) r.container.revnext();
                });
              }

              if (i.attr("poster") != t && o.find(".tp-poster").length == 0) o.append('<div class="tp-poster" style="position:absolute;z-index:1;width:100%;height:100%;top:0px;left:0px;background:url(' + i.attr("poster") + '); background-position:center center;background-size:100%;background-repeat:no-repeat;"></div>');

              if (i.attr("control") == t && o.find(".tp-video-play-button").length == 0) {
                o.append('<div class="tp-video-play-button"><i class="revicon-right-dir"></i><div class="tp-revstop"></div></div>');
                o.find(".tp-video-play-button").click(function () {
                  if (o.hasClass("videoisplaying")) s.pause();else s.play();
                });
              }

              if (i.attr("control") == t) {
                o.find("video, .tp-poster").click(function () {
                  if (o.hasClass("videoisplaying")) s.pause();else s.play();
                });
              }

              if (l.data("forcecover") == 1) {
                W(o, r.container);
                o.addClass("fullcoveredvideo");
                l.addClass("fullcoveredvideo");
              }

              if (l.data("forcecover") == 1 || l.hasClass("fullscreenvideo")) {
                o.css({
                  width: "100%",
                  height: "100%"
                });
              }

              var u = false;
              if (l.data("autoplayonlyfirsttime") == true || l.data("autoplayonlyfirsttime") == "true") u = true;
              clearInterval(o.data("interval"));
              o.data("interval", setInterval(function () {
                if (o.data("metaloaded") == 1 || s.duration != NaN) {
                  clearInterval(o.data("interval"));
                  if (l.data("dottedoverlay") != "none" && l.data("dottedoverlay") != t) if (l.find(".tp-dottedoverlay").length != 1) o.append('<div class="tp-dottedoverlay ' + l.data("dottedoverlay") + '"></div>');
                  var n = 16 / 9;
                  if (l.data("aspectratio") == "4:3") n = 4 / 3;
                  o.data("mediaAspect", n);

                  if (o.closest(".tp-caption").data("forcecover") == 1) {
                    W(o, r.container);
                    o.addClass("fullcoveredvideo");
                  }

                  i.css({
                    display: "block"
                  });
                  r.nextslideatend = l.data("nextslideatend");

                  if (l.data("autoplay") == true || u == true) {
                    var a = e("body").find("#" + r.container.attr("id")).find(".tp-bannertimer");
                    setTimeout(function () {
                      r.videoplaying = true;
                      r.container.trigger("stoptimer");
                    }, 200);
                    if (l.data("forcerewind") == "on" && !o.hasClass("videoisplaying")) if (s.currentTime > 0) s.currentTime = 0;
                    if (l.data("volume") == "mute") s.muted = true;
                    o.data("timerplay", setTimeout(function () {
                      if (l.data("forcerewind") == "on" && !o.hasClass("videoisplaying")) if (s.currentTime > 0) s.currentTime = 0;
                      if (l.data("volume") == "mute") s.muted = true;
                      setTimeout(function () {
                        s.play();
                      }, 500);
                    }, 10 + l.data("start")));
                  }

                  if (o.data("ww") == t) o.data("ww", i.attr("width"));
                  if (o.data("hh") == t) o.data("hh", i.attr("height"));

                  if (!l.hasClass("fullscreenvideo") && l.data("forcecover") == 1) {
                    try {
                      o.width(o.data("ww") * r.bw);
                      o.height(o.data("hh") * r.bh);
                    } catch (f) {}
                  }

                  clearInterval(o.data("interval"));
                }
              }), 100);
            });
          }

          if (l.data("autoplay") == true) {
            var p = e("body").find("#" + r.container.attr("id")).find(".tp-bannertimer");
            setTimeout(function () {
              r.videoplaying = true;
              r.container.trigger("stoptimer");
            }, 200);
            r.videoplaying = true;
            r.container.trigger("stoptimer");

            if (l.data("autoplayonlyfirsttime") == true || l.data("autoplayonlyfirsttime") == "true") {
              l.data("autoplay", false);
              l.data("autoplayonlyfirsttime", false);
            }
          }
        }

        var d = 0;
        var v = 0;

        if (l.find("img").length > 0) {
          var m = l.find("img");
          if (m.data("ww") == t) m.data("ww", m.width());
          if (m.data("hh") == t) m.data("hh", m.height());
          var g = m.data("ww");
          var y = m.data("hh");
          m.width(g * r.bw);
          m.height(y * r.bh);
          d = m.width();
          v = m.height();
        } else {
          if (l.find("iframe").length > 0 || l.find("video").length > 0) {
            var b = false;
            var m = l.find("iframe");

            if (m.length == 0) {
              m = l.find("video");
              b = true;
            }

            m.css({
              display: "block"
            });
            if (l.data("ww") == t) l.data("ww", m.width());
            if (l.data("hh") == t) l.data("hh", m.height());
            var g = l.data("ww");
            var y = l.data("hh");
            var w = l;
            if (w.data("fsize") == t) w.data("fsize", parseInt(w.css("font-size"), 0) || 0);
            if (w.data("pt") == t) w.data("pt", parseInt(w.css("paddingTop"), 0) || 0);
            if (w.data("pb") == t) w.data("pb", parseInt(w.css("paddingBottom"), 0) || 0);
            if (w.data("pl") == t) w.data("pl", parseInt(w.css("paddingLeft"), 0) || 0);
            if (w.data("pr") == t) w.data("pr", parseInt(w.css("paddingRight"), 0) || 0);
            if (w.data("mt") == t) w.data("mt", parseInt(w.css("marginTop"), 0) || 0);
            if (w.data("mb") == t) w.data("mb", parseInt(w.css("marginBottom"), 0) || 0);
            if (w.data("ml") == t) w.data("ml", parseInt(w.css("marginLeft"), 0) || 0);
            if (w.data("mr") == t) w.data("mr", parseInt(w.css("marginRight"), 0) || 0);
            if (w.data("bt") == t) w.data("bt", parseInt(w.css("borderTop"), 0) || 0);
            if (w.data("bb") == t) w.data("bb", parseInt(w.css("borderBottom"), 0) || 0);
            if (w.data("bl") == t) w.data("bl", parseInt(w.css("borderLeft"), 0) || 0);
            if (w.data("br") == t) w.data("br", parseInt(w.css("borderRight"), 0) || 0);
            if (w.data("lh") == t) w.data("lh", parseInt(w.css("lineHeight"), 0) || 0);
            var E = r.width;
            var S = r.height;
            if (E > r.startwidth) E = r.startwidth;
            if (S > r.startheight) S = r.startheight;
            if (!l.hasClass("fullscreenvideo")) l.css({
              "font-size": w.data("fsize") * r.bw + "px",
              "padding-top": w.data("pt") * r.bh + "px",
              "padding-bottom": w.data("pb") * r.bh + "px",
              "padding-left": w.data("pl") * r.bw + "px",
              "padding-right": w.data("pr") * r.bw + "px",
              "margin-top": w.data("mt") * r.bh + "px",
              "margin-bottom": w.data("mb") * r.bh + "px",
              "margin-left": w.data("ml") * r.bw + "px",
              "margin-right": w.data("mr") * r.bw + "px",
              "border-top": w.data("bt") * r.bh + "px",
              "border-bottom": w.data("bb") * r.bh + "px",
              "border-left": w.data("bl") * r.bw + "px",
              "border-right": w.data("br") * r.bw + "px",
              "line-height": w.data("lh") * r.bh + "px",
              height: y * r.bh + "px"
            });else {
              o = 0;
              u = 0;
              l.data("x", 0);
              l.data("y", 0);
              var x = r.height;
              if (r.autoHeight == "on") x = r.container.height();
              l.css({
                width: r.width,
                height: x
              });
            }

            if (b == false) {
              m.width(g * r.bw);
              m.height(y * r.bh);
            } else if (l.data("forcecover") != 1 && !l.hasClass("fullscreenvideo")) {
              m.width(g * r.bw);
              m.height(y * r.bh);
            }

            d = m.width();
            v = m.height();
          } else {
            l.find(".tp-resizeme, .tp-resizeme *").each(function () {
              G(e(this), r);
            });

            if (l.hasClass("tp-resizeme")) {
              l.find("*").each(function () {
                G(e(this), r);
              });
            }

            G(l, r);
            v = l.outerHeight(true);
            d = l.outerWidth(true);
            var T = l.outerHeight();
            var N = l.css("backgroundColor");
            l.find(".frontcorner").css({
              borderWidth: T + "px",
              left: 0 - T + "px",
              borderRight: "0px solid transparent",
              borderTopColor: N
            });
            l.find(".frontcornertop").css({
              borderWidth: T + "px",
              left: 0 - T + "px",
              borderRight: "0px solid transparent",
              borderBottomColor: N
            });
            l.find(".backcorner").css({
              borderWidth: T + "px",
              right: 0 - T + "px",
              borderLeft: "0px solid transparent",
              borderBottomColor: N
            });
            l.find(".backcornertop").css({
              borderWidth: T + "px",
              right: 0 - T + "px",
              borderLeft: "0px solid transparent",
              borderTopColor: N
            });
          }
        }

        if (r.fullScreenAlignForce == "on") {
          o = 0;
          u = 0;
        }

        if (l.data("voffset") == t) l.data("voffset", 0);
        if (l.data("hoffset") == t) l.data("hoffset", 0);
        var C = l.data("voffset") * a;
        var k = l.data("hoffset") * a;
        var L = r.startwidth * a;
        var A = r.startheight * a;

        if (r.fullScreenAlignForce == "on") {
          L = r.container.width();
          A = r.container.height();
        }

        if (l.data("x") == "center" || l.data("xcenter") == "center") {
          l.data("xcenter", "center");
          l.data("x", L / 2 - l.outerWidth(true) / 2 + k);
        }

        if (l.data("x") == "left" || l.data("xleft") == "left") {
          l.data("xleft", "left");
          l.data("x", 0 / a + k);
        }

        if (l.data("x") == "right" || l.data("xright") == "right") {
          l.data("xright", "right");
          l.data("x", (L - l.outerWidth(true) + k) / a);
        }

        if (l.data("y") == "center" || l.data("ycenter") == "center") {
          l.data("ycenter", "center");
          l.data("y", A / 2 - l.outerHeight(true) / 2 + C);
        }

        if (l.data("y") == "top" || l.data("ytop") == "top") {
          l.data("ytop", "top");
          l.data("y", 0 / r.bh + C);
        }

        if (l.data("y") == "bottom" || l.data("ybottom") == "bottom") {
          l.data("ybottom", "bottom");
          l.data("y", (A - l.outerHeight(true) + C) / a);
        }

        if (l.data("start") == t) l.data("start", 1e3);
        var O = l.data("easing");
        if (O == t) O = "Power1.easeOut";
        var M = l.data("start") / 1e3;

        var _ = l.data("speed") / 1e3;

        if (l.data("x") == "center" || l.data("xcenter") == "center") var D = l.data("x") + o;else {
          var D = a * l.data("x") + o;
        }
        if (l.data("y") == "center" || l.data("ycenter") == "center") var P = l.data("y") + u;else {
          var P = r.bh * l.data("y") + u;
        }
        TweenLite.set(l, {
          top: P,
          left: D,
          overwrite: "auto"
        });

        if (!i) {
          if (l.data("timeline") != t) l.data("timeline").clear();

          function H() {
            setTimeout(function () {
              l.css({
                transform: "none",
                "-moz-transform": "none",
                "-webkit-transform": "none"
              });
            }, 100);
          }

          function B() {
            l.data("timer", setTimeout(function () {
              if (l.hasClass("fullscreenvideo")) l.css({
                display: "block"
              });
            }, l.data("start")));
          }

          var j = new TimelineLite({
            smoothChildTiming: true,
            onStart: B
          });

          if (r.fullScreenAlignForce == "on") {}

          var F = l;
          if (l.data("mySplitText") != t) l.data("mySplitText").revert();

          if (l.data("splitin") == "chars" || l.data("splitin") == "words" || l.data("splitin") == "lines" || l.data("splitout") == "chars" || l.data("splitout") == "words" || l.data("splitout") == "lines") {
            if (l.find("a").length > 0) l.data("mySplitText", new SplitText(l.find("a"), {
              type: "lines,words,chars",
              charsClass: "tp-splitted",
              wordsClass: "tp-splitted",
              linesClass: "tp-splitted"
            }));else l.data("mySplitText", new SplitText(l, {
              type: "lines,words,chars",
              charsClass: "tp-splitted",
              wordsClass: "tp-splitted",
              linesClass: "tp-splitted"
            }));
            l.addClass("splitted");
          }

          if (l.data("splitin") == "chars") F = l.data("mySplitText").chars;
          if (l.data("splitin") == "words") F = l.data("mySplitText").words;
          if (l.data("splitin") == "lines") F = l.data("mySplitText").lines;
          var I = X();
          var q = X();
          if (l.data("repeat") != t) repeatV = l.data("repeat");
          if (l.data("yoyo") != t) yoyoV = l.data("yoyo");
          if (l.data("repeatdelay") != t) repeatdelayV = l.data("repeatdelay");
          if (l.hasClass("customin")) I = V(I, l.data("customin"));else if (l.hasClass("randomrotate")) {
            I.scale = Math.random() * 3 + 1;
            I.rotation = Math.round(Math.random() * 200 - 100);
            I.x = Math.round(Math.random() * 200 - 100);
            I.y = Math.round(Math.random() * 200 - 100);
          } else if (l.hasClass("lfr") || l.hasClass("skewfromright")) I.x = 15 + r.width;else if (l.hasClass("lfl") || l.hasClass("skewfromleft")) I.x = -15 - d;else if (l.hasClass("sfl") || l.hasClass("skewfromleftshort")) I.x = -50;else if (l.hasClass("sfr") || l.hasClass("skewfromrightshort")) I.x = 50;else if (l.hasClass("lft")) I.y = -25 - v;else if (l.hasClass("lfb")) I.y = 25 + r.height;else if (l.hasClass("sft")) I.y = -50;else if (l.hasClass("sfb")) I.y = 50;
          if (l.hasClass("skewfromright") || l.hasClass("skewfromrightshort")) I.skewX = -85;else if (l.hasClass("skewfromleft") || l.hasClass("skewfromleftshort")) I.skewX = 85;
          if (l.hasClass("fade") || l.hasClass("sft") || l.hasClass("sfl") || l.hasClass("sfb") || l.hasClass("skewfromleftshort") || l.hasClass("sfr") || l.hasClass("skewfromrightshort")) I.opacity = 0;

          if (K().toLowerCase() == "safari") {
            I.rotationX = 0;
            I.rotationY = 0;
          }

          var U = l.data("elementdelay") == t ? 0 : l.data("elementdelay");
          q.ease = I.ease = l.data("easing") == t ? Power1.easeInOut : l.data("easing");
          I.data = new Object();
          I.data.oldx = I.x;
          I.data.oldy = I.y;
          q.data = new Object();
          q.data.oldx = q.x;
          q.data.oldy = q.y;
          I.x = I.x * a;
          I.y = I.y * a;
          var J = new TimelineLite();

          if (l.hasClass("customin")) {
            if (F != l) j.add(TweenLite.set(l, {
              opacity: 1,
              scaleX: 1,
              scaleY: 1,
              rotationX: 0,
              rotationY: 0,
              rotationZ: 0,
              skewX: 0,
              skewY: 0,
              z: 0,
              x: 0,
              y: 0,
              visibility: "visible",
              opacity: 1,
              delay: 0,
              overwrite: "all"
            }));
            I.visibility = "hidden";
            q.visibility = "visible";
            q.overwrite = "all";
            q.opacity = 1;
            q.onComplete = H();
            q.delay = M;
            j.add(J.staggerFromTo(F, _, I, q, U), "frame0");
          } else {
            I.visibility = "visible";
            I.transformPerspective = 600;
            if (F != l) j.add(TweenLite.set(l, {
              opacity: 1,
              scaleX: 1,
              scaleY: 1,
              rotationX: 0,
              rotationY: 0,
              rotationZ: 0,
              skewX: 0,
              skewY: 0,
              z: 0,
              x: 0,
              y: 0,
              visibility: "visible",
              opacity: 1,
              delay: 0,
              overwrite: "all"
            }));
            q.visibility = "visible";
            q.delay = M;
            q.onComplete = H();
            q.opacity = 1;

            if (l.hasClass("randomrotate") && F != l) {
              for (var n = 0; n < F.length; n++) {
                var Q = new Object();
                var Y = new Object();
                e.extend(Q, I);
                e.extend(Y, q);
                I.scale = Math.random() * 3 + 1;
                I.rotation = Math.round(Math.random() * 200 - 100);
                I.x = Math.round(Math.random() * 200 - 100);
                I.y = Math.round(Math.random() * 200 - 100);
                if (n != 0) Y.delay = M + n * U;
                j.append(TweenLite.fromTo(F[n], _, Q, Y), "frame0");
              }
            } else j.add(J.staggerFromTo(F, _, I, q, U), "frame0");
          }

          l.data("timeline", j);
          var tt = new Array();

          if (l.data("frames") != t) {
            var nt = l.data("frames");
            nt = nt.replace(/\s+/g, "");
            nt = nt.replace("{", "");
            var rt = nt.split("}");
            e.each(rt, function (e, t) {
              if (t.length > 0) {
                var n = $(t);
                Z(l, r, n, "frame" + (e + 10), a);
              }
            });
          }

          j = l.data("timeline");

          if (l.data("end") != t) {
            et(l, r, l.data("end") / 1e3, I, "frame99", a);
          } else {
            et(l, r, 999999, I, "frame99", a);
          }

          j = l.data("timeline");
          l.data("timeline", j);
          l.find(".rs-pendulum").each(function () {
            var n = e(this);

            if (n.data("timeline") == t) {
              n.data("timeline", new TimelineLite());
              var r = n.data("startdeg") == t ? -20 : n.data("startdeg"),
                  i = n.data("enddeg") == t ? 20 : n.data("enddeg");
              speed = n.data("speed") == t ? 2 : n.data("speed"), origin = n.data("origin") == t ? "50% 50%" : n.data("origin"), easing = n.data("ease") == t ? Power2.easeInOut : n.data("ease");
              n.data("timeline").append(new TweenLite.fromTo(n, speed, {
                rotation: r,
                transformOrigin: origin
              }, {
                rotation: i,
                ease: easing
              }));
              n.data("timeline").append(new TweenLite.fromTo(n, speed, {
                rotation: i,
                transformOrigin: origin
              }, {
                rotation: r,
                ease: easing,
                onComplete: function () {
                  n.data("timeline").restart();
                }
              }));
            }
          });
          l.find(".rs-slideloop").each(function () {
            var n = e(this);

            if (n.data("timeline") == t) {
              n.data("timeline", new TimelineLite());
              var r = n.data("xs") == t ? 0 : n.data("xs"),
                  i = n.data("ys") == t ? 0 : n.data("ys");
              xe = n.data("xe") == t ? 0 : n.data("xe"), ye = n.data("ye") == t ? 0 : n.data("ye"), speed = n.data("speed") == t ? 2 : n.data("speed"), easing = n.data("ease") == t ? Power2.easeInOut : n.data("ease");
              n.data("timeline").append(new TweenLite.fromTo(n, speed, {
                x: r,
                y: i
              }, {
                x: xe,
                y: ye,
                ease: easing
              }));
              n.data("timeline").append(new TweenLite.fromTo(n, speed, {
                x: xe,
                y: ye
              }, {
                x: r,
                y: i,
                onComplete: function () {
                  n.data("timeline").restart();
                }
              }));
            }
          });
          l.find(".rs-pulse").each(function () {
            var n = e(this);

            if (n.data("timeline") == t) {
              n.data("timeline", new TimelineLite());
              var r = n.data("zoomstart") == t ? 0 : n.data("zoomstart"),
                  i = n.data("zoomend") == t ? 0 : n.data("zoomend");
              speed = n.data("speed") == t ? 2 : n.data("speed"), easing = n.data("ease") == t ? Power2.easeInOut : n.data("ease");
              n.data("timeline").append(new TweenLite.fromTo(n, speed, {
                scale: r
              }, {
                scale: i,
                ease: easing
              }));
              n.data("timeline").append(new TweenLite.fromTo(n, speed, {
                scale: i
              }, {
                scale: r,
                onComplete: function () {
                  n.data("timeline").restart();
                }
              }));
            }
          });
          l.find(".rs-wave").each(function () {
            var n = e(this);

            if (n.data("timeline") == t) {
              n.data("timeline", new TimelineLite());
              var r = n.data("angle") == t ? 10 : n.data("angle"),
                  i = n.data("radius") == t ? 10 : n.data("radius"),
                  s = n.data("speed") == t ? -20 : n.data("speed"),
                  o = n.data("origin") == t ? -20 : n.data("origin"),
                  u = {
                a: 0,
                ang: r,
                element: n,
                unit: i
              };
              n.data("timeline").append(new TweenLite.fromTo(u, s, {
                a: 360
              }, {
                a: 0,
                ease: Linear.easeNone,
                onUpdate: function () {
                  var e = u.a * (Math.PI / 180);
                  TweenLite.to(u.element, .1, {
                    x: Math.cos(e) * u.unit,
                    y: u.unit * (1 - Math.sin(e))
                  });
                },
                onComplete: function () {
                  n.data("timeline").restart();
                }
              }));
            }
          });
        }
      }

      if (i) {
        if (l.data("timeline") != t) {
          var it = l.data("timeline").getTweensOf();
          e.each(it, function (e, n) {
            if (n.vars.data != t) {
              var r = n.vars.data.oldx * a;
              var i = n.vars.data.oldy * a;

              if (n.progress() != 1 && n.progress() != 0) {
                try {
                  n.vars.x = r;
                  n.vary.y = i;
                } catch (s) {}
              } else {
                if (n.progress() == 1) {
                  TweenLite.set(n.target, {
                    x: r,
                    y: i
                  });
                }
              }
            }
          });
        }
      }
    });
    var a = e("body").find("#" + r.container.attr("id")).find(".tp-bannertimer");
    a.data("opt", r);
  }

  function K() {
    var e = navigator.appName,
        t = navigator.userAgent,
        n;
    var r = t.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
    if (r && (n = t.match(/version\/([\.\d]+)/i)) != null) r[2] = n[1];
    r = r ? [r[1], r[2]] : [e, navigator.appVersion, "-?"];
    return r[0];
  }

  function Q() {
    var e = navigator.appName,
        t = navigator.userAgent,
        n;
    var r = t.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
    if (r && (n = t.match(/version\/([\.\d]+)/i)) != null) r[2] = n[1];
    r = r ? [r[1], r[2]] : [e, navigator.appVersion, "-?"];
    return r[1];
  }

  function G(e, n) {
    if (e.data("fsize") == t) e.data("fsize", parseInt(e.css("font-size"), 0) || 0);
    if (e.data("pt") == t) e.data("pt", parseInt(e.css("paddingTop"), 0) || 0);
    if (e.data("pb") == t) e.data("pb", parseInt(e.css("paddingBottom"), 0) || 0);
    if (e.data("pl") == t) e.data("pl", parseInt(e.css("paddingLeft"), 0) || 0);
    if (e.data("pr") == t) e.data("pr", parseInt(e.css("paddingRight"), 0) || 0);
    if (e.data("mt") == t) e.data("mt", parseInt(e.css("marginTop"), 0) || 0);
    if (e.data("mb") == t) e.data("mb", parseInt(e.css("marginBottom"), 0) || 0);
    if (e.data("ml") == t) e.data("ml", parseInt(e.css("marginLeft"), 0) || 0);
    if (e.data("mr") == t) e.data("mr", parseInt(e.css("marginRight"), 0) || 0);
    if (e.data("bt") == t) e.data("bt", parseInt(e.css("borderTopWidth"), 0) || 0);
    if (e.data("bb") == t) e.data("bb", parseInt(e.css("borderBottomWidth"), 0) || 0);
    if (e.data("bl") == t) e.data("bl", parseInt(e.css("borderLeftWidth"), 0) || 0);
    if (e.data("br") == t) e.data("br", parseInt(e.css("borderRightWidth"), 0) || 0);
    if (e.data("ls") == t) e.data("ls", parseInt(e.css("letterSpacing"), 0) || 0);
    if (e.data("lh") == t) e.data("lh", parseInt(e.css("lineHeight"), 0) || 0);
    if (e.data("minwidth") == t) e.data("minwidth", parseInt(e.css("minWidth"), 0) || 0);
    if (e.data("minheight") == t) e.data("minheight", parseInt(e.css("minHeight"), 0) || 0);
    if (e.data("maxwidth") == t) e.data("maxwidth", parseInt(e.css("maxWidth"), 0) || "none");
    if (e.data("maxheight") == t) e.data("maxheight", parseInt(e.css("maxHeight"), 0) || "none");
    if (e.data("wan") == t) e.data("wan", e.css("-webkit-transition"));
    if (e.data("moan") == t) e.data("moan", e.css("-moz-animation-transition"));
    if (e.data("man") == t) e.data("man", e.css("-ms-animation-transition"));
    if (e.data("ani") == t) e.data("ani", e.css("transition"));

    if (!e.hasClass("tp-splitted")) {
      e.css("-webkit-transition", "none");
      e.css("-moz-transition", "none");
      e.css("-ms-transition", "none");
      e.css("transition", "none");
      TweenLite.set(e, {
        fontSize: Math.round(e.data("fsize") * n.bw) + "px",
        letterSpacing: Math.floor(e.data("ls") * n.bw) + "px",
        paddingTop: Math.round(e.data("pt") * n.bh) + "px",
        paddingBottom: Math.round(e.data("pb") * n.bh) + "px",
        paddingLeft: Math.round(e.data("pl") * n.bw) + "px",
        paddingRight: Math.round(e.data("pr") * n.bw) + "px",
        marginTop: e.data("mt") * n.bh + "px",
        marginBottom: e.data("mb") * n.bh + "px",
        marginLeft: e.data("ml") * n.bw + "px",
        marginRight: e.data("mr") * n.bw + "px",
        borderTopWidth: Math.round(e.data("bt") * n.bh) + "px",
        borderBottomWidth: Math.round(e.data("bb") * n.bh) + "px",
        borderLeftWidth: Math.round(e.data("bl") * n.bw) + "px",
        borderRightWidth: Math.round(e.data("br") * n.bw) + "px",
        lineHeight: Math.round(e.data("lh") * n.bh) + "px",
        minWidth: e.data("minwidth") * n.bw + "px",
        minHeight: e.data("minheight") * n.bh + "px",
        overwrite: "auto"
      });
      setTimeout(function () {
        e.css("-webkit-transition", e.data("wan"));
        e.css("-moz-transition", e.data("moan"));
        e.css("-ms-transition", e.data("man"));
        e.css("transition", e.data("ani"));
      }, 30);
      if (e.data("maxheight") != "none") e.css({
        maxHeight: e.data("maxheight") * n.bh + "px"
      });
      if (e.data("maxwidth") != "none") e.css({
        maxWidth: e.data("maxwidth") * n.bw + "px"
      });
    }
  }

  function Y(t, n) {
    t.find(".tp-caption").each(function (t) {
      var n = e(this);

      if (n.find("iframe").length > 0) {
        try {
          var r = n.find("iframe");
          var i = r.attr("id");
          var s = $f(i);
          s.api("pause");
          clearTimeout(n.data("timerplay"));
        } catch (o) {}

        try {
          var u = n.data("player");
          u.stopVideo();
          clearTimeout(n.data("timerplay"));
        } catch (o) {}
      }

      if (n.find("video").length > 0) {
        try {
          n.find("video").each(function (t) {
            var n = e(this).parent();
            var r = n.attr("id");
            clearTimeout(n.data("timerplay"));
            var i = this;
            i.pause();
          });
        } catch (o) {}
      }

      try {
        var a = n.data("timeline");
        var f = a.getLabelTime("frame99");
        var l = a.time();

        if (f > l) {
          var c = a.getTweensOf(n);
          e.each(c, function (e, t) {
            if (e != 0) t.pause();
          });
          if (n.css("opacity") != 0) a.play("frame99");else a.progress(1, false);
        }
      } catch (o) {}
    });
  }

  function Z(e, n, r, i, s) {
    var o = e.data("timeline");
    var u = new TimelineLite();
    var a = e;
    if (r.typ == "chars") a = e.data("mySplitText").chars;else if (r.typ == "words") a = e.data("mySplitText").words;else if (r.typ == "lines") a = e.data("mySplitText").lines;
    r.animation.ease = r.ease;
    if (r.animation.rotationZ != t) r.animation.rotation = r.animation.rotationZ;
    r.animation.data = new Object();
    r.animation.data.oldx = r.animation.x;
    r.animation.data.oldy = r.animation.y;
    r.animation.x = r.animation.x * s;
    r.animation.y = r.animation.y * s;
    o.add(u.staggerTo(a, r.speed, r.animation, r.elementdelay), r.start);
    o.addLabel(i, r.start);
    e.data("timeline", o);
  }

  function et(e, n, r, i, s, o) {
    var u = e.data("timeline");
    var a = new TimelineLite();
    var f = X();
    var l = e.data("endspeed") == t ? e.data("speed") : e.data("endspeed");
    f.ease = e.data("endeasing") == t ? Power1.easeInOut : e.data("endeasing");
    l = l / 1e3;

    if (e.hasClass("ltr") || e.hasClass("ltl") || e.hasClass("str") || e.hasClass("stl") || e.hasClass("ltt") || e.hasClass("ltb") || e.hasClass("stt") || e.hasClass("stb") || e.hasClass("skewtoright") || e.hasClass("skewtorightshort") || e.hasClass("skewtoleft") || e.hasClass("skewtoleftshort") || e.hasClass("fadeout") || e.hasClass("randomrotateout")) {
      if (e.hasClass("skewtoright") || e.hasClass("skewtorightshort")) f.skewX = 35;else if (e.hasClass("skewtoleft") || e.hasClass("skewtoleftshort")) f.skewX = -35;
      if (e.hasClass("ltr") || e.hasClass("skewtoright")) f.x = n.width + 60;else if (e.hasClass("ltl") || e.hasClass("skewtoleft")) f.x = 0 - (n.width + 60);else if (e.hasClass("ltt")) f.y = 0 - (n.height + 60);else if (e.hasClass("ltb")) f.y = n.height + 60;else if (e.hasClass("str") || e.hasClass("skewtorightshort")) {
        f.x = 50;
        f.opacity = 0;
      } else if (e.hasClass("stl") || e.hasClass("skewtoleftshort")) {
        f.x = -50;
        f.opacity = 0;
      } else if (e.hasClass("stt")) {
        f.y = -50;
        f.opacity = 0;
      } else if (e.hasClass("stb")) {
        f.y = 50;
        f.opacity = 0;
      } else if (e.hasClass("randomrotateout")) {
        f.x = Math.random() * n.width;
        f.y = Math.random() * n.height;
        f.scale = Math.random() * 2 + .3;
        f.rotation = Math.random() * 360 - 180;
        f.opacity = 0;
      } else if (e.hasClass("fadeout")) {
        f.opacity = 0;
      }
      if (e.hasClass("skewtorightshort")) f.x = 270;else if (e.hasClass("skewtoleftshort")) f.x = -270;
      f.data = new Object();
      f.data.oldx = f.x;
      f.data.oldy = f.y;
      f.x = f.x * o;
      f.y = f.y * o;
      f.overwrite = "auto";
      var c = e;
      var c = e;
      if (e.data("splitout") == "chars") c = e.data("mySplitText").chars;else if (e.data("splitout") == "words") c = e.data("mySplitText").words;else if (e.data("splitout") == "lines") c = e.data("mySplitText").lines;
      var h = e.data("endelementdelay") == t ? 0 : e.data("endelementdelay");
      u.add(a.staggerTo(c, l, f, h), r);
    } else if (e.hasClass("customout")) {
      f = V(f, e.data("customout"));
      var c = e;
      if (e.data("splitout") == "chars") c = e.data("mySplitText").chars;else if (e.data("splitout") == "words") c = e.data("mySplitText").words;else if (e.data("splitout") == "lines") c = e.data("mySplitText").lines;
      var h = e.data("endelementdelay") == t ? 0 : e.data("endelementdelay");

      f.onStart = function () {
        TweenLite.set(e, {
          transformPerspective: f.transformPerspective,
          transformOrigin: f.transformOrigin,
          overwrite: "auto"
        });
      };

      f.data = new Object();
      f.data.oldx = f.x;
      f.data.oldy = f.y;
      f.x = f.x * o;
      f.y = f.y * o;
      u.add(a.staggerTo(c, l, f, h), r);
    } else {
      i.delay = 0;
      u.add(TweenLite.to(e, l, i), r);
    }

    u.addLabel(s, r);
    e.data("timeline", u);
  }

  function tt(t, n) {
    t.children().each(function () {
      try {
        e(this).die("click");
      } catch (t) {}

      try {
        e(this).die("mouseenter");
      } catch (t) {}

      try {
        e(this).die("mouseleave");
      } catch (t) {}

      try {
        e(this).unbind("hover");
      } catch (t) {}
    });

    try {
      t.die("click", "mouseenter", "mouseleave");
    } catch (r) {}

    clearInterval(n.cdint);
    t = null;
  }

  function nt(n, r) {
    r.cd = 0;
    r.loop = 0;
    if (r.stopAfterLoops != t && r.stopAfterLoops > -1) r.looptogo = r.stopAfterLoops;else r.looptogo = 9999999;
    if (r.stopAtSlide != t && r.stopAtSlide > -1) r.lastslidetoshow = r.stopAtSlide;else r.lastslidetoshow = 999;
    r.stopLoop = "off";
    if (r.looptogo == 0) r.stopLoop = "on";

    if (r.slideamount > 1 && !(r.stopAfterLoops == 0 && r.stopAtSlide == 1)) {
      var i = n.find(".tp-bannertimer");
      n.on("stoptimer", function () {
        i.data("tween").pause();
        if (r.hideTimerBar == "on") i.css({
          visibility: "hidden"
        });
      });
      n.on("starttimer", function () {
        if (r.conthover != 1 && r.videoplaying != true && r.width > r.hideSliderAtLimit && r.bannertimeronpause != true && r.overnav != true) if (r.stopLoop == "on" && r.next == r.lastslidetoshow - 1) {} else {
          i.css({
            visibility: "visible"
          });
          i.data("tween").play();
        }
        if (r.hideTimerBar == "on") i.css({
          visibility: "hidden"
        });
      });
      n.on("restarttimer", function () {
        if (r.stopLoop == "on" && r.next == r.lastslidetoshow - 1) {} else {
          i.css({
            visibility: "visible"
          });
          i.data("tween", TweenLite.fromTo(i, r.delay / 1e3, {
            width: "0%"
          }, {
            width: "100%",
            ease: Linear.easeNone,
            onComplete: o,
            delay: 1
          }));
        }

        if (r.hideTimerBar == "on") i.css({
          visibility: "hidden"
        });
      });
      n.on("nulltimer", function () {
        i.data("tween").pause(0);
        if (r.hideTimerBar == "on") i.css({
          visibility: "hidden"
        });
      });

      function o() {
        if (e("body").find(n).length == 0) {
          tt(n, r);
          clearInterval(r.cdint);
        }

        if (n.data("conthover-changed") == 1) {
          r.conthover = n.data("conthover");
          n.data("conthover-changed", 0);
        }

        r.act = r.next;
        r.next = r.next + 1;

        if (r.next > n.find(">ul >li").length - 1) {
          r.next = 0;
          r.looptogo = r.looptogo - 1;

          if (r.looptogo <= 0) {
            r.stopLoop = "on";
          }
        }

        if (r.stopLoop == "on" && r.next == r.lastslidetoshow - 1) {
          n.find(".tp-bannertimer").css({
            visibility: "hidden"
          });
          n.trigger("revolution.slide.onstop");
        } else {
          i.data("tween").restart();
        }

        C(n, r);
      }

      i.data("tween", TweenLite.fromTo(i, r.delay / 1e3, {
        width: "0%"
      }, {
        width: "100%",
        ease: Linear.easeNone,
        onComplete: o,
        delay: 1
      }));
      i.data("opt", r);
      n.hover(function () {
        if (r.onHoverStop == "on" && !s()) {
          n.trigger("stoptimer");
          n.trigger("revolution.slide.onpause");
          var i = n.find(">ul >li:eq(" + r.next + ") .slotholder");
          i.find(".defaultimg").each(function () {
            var n = e(this);

            if (n.data("kenburn") != t) {
              n.data("kenburn").pause();
            }
          });
        }
      }, function () {
        if (n.data("conthover") != 1) {
          n.trigger("revolution.slide.onresume");
          n.trigger("starttimer");
          var i = n.find(">ul >li:eq(" + r.next + ") .slotholder");
          i.find(".defaultimg").each(function () {
            var n = e(this);

            if (n.data("kenburn") != t) {
              n.data("kenburn").play();
            }
          });
        }
      });
    }
  }

  e.fn.extend({
    revolution: function (i) {
      e.fn.revolution.defaults = {
        delay: 9e3,
        startheight: 500,
        startwidth: 960,
        fullScreenAlignForce: "off",
        autoHeight: "off",
        hideTimerBar: "off",
        hideThumbs: 200,
        hideNavDelayOnMobile: 1500,
        thumbWidth: 100,
        thumbHeight: 50,
        thumbAmount: 3,
        navigationType: "bullet",
        navigationArrows: "solo",
        hideThumbsOnMobile: "off",
        hideBulletsOnMobile: "off",
        hideArrowsOnMobile: "off",
        hideThumbsUnderResoluition: 0,
        navigationStyle: "round",
        navigationHAlign: "center",
        navigationVAlign: "bottom",
        navigationHOffset: 0,
        navigationVOffset: 20,
        soloArrowLeftHalign: "left",
        soloArrowLeftValign: "center",
        soloArrowLeftHOffset: 20,
        soloArrowLeftVOffset: 0,
        soloArrowRightHalign: "right",
        soloArrowRightValign: "center",
        soloArrowRightHOffset: 20,
        soloArrowRightVOffset: 0,
        keyboardNavigation: "on",
        touchenabled: "on",
        onHoverStop: "on",
        stopAtSlide: -1,
        stopAfterLoops: -1,
        hideCaptionAtLimit: 0,
        hideAllCaptionAtLimit: 0,
        hideSliderAtLimit: 0,
        shadow: 0,
        fullWidth: "off",
        fullScreen: "off",
        minFullScreenHeight: 0,
        fullScreenOffsetContainer: "",
        dottedOverlay: "none",
        forceFullWidth: "off",
        spinner: "spinner0",
        swipe_velocity: .4,
        swipe_max_touches: 1,
        swipe_min_touches: 1,
        drag_block_vertical: false,
        isJoomla: false,
        parallax: "off",
        parallaxLevels: [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85],
        parallaxBgFreeze: "off"
      };
      i = e.extend({}, e.fn.revolution.defaults, i);
      return this.each(function () {
        var o = i;
        o.desktop = !navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry|BB10|mobi|tablet|opera mini|nexus 7)/i);
        if (o.fullWidth != "on" && o.fullScreen != "on") o.autoHeight = "off";
        if (o.fullScreen == "on") o.autoHeight = "on";
        if (o.fullWidth != "on" && o.fullScreen != "on") forceFulWidth = "off";
        var u = e(this);
        if (o.fullWidth == "on" && o.autoHeight == "off") u.css({
          maxHeight: o.startheight + "px"
        });
        if (s() && o.hideThumbsOnMobile == "on" && o.navigationType == "thumb") o.navigationType = "none";
        if (s() && o.hideBulletsOnMobile == "on" && o.navigationType == "bullet") o.navigationType = "none";
        if (s() && o.hideBulletsOnMobile == "on" && o.navigationType == "both") o.navigationType = "none";
        if (s() && o.hideArrowsOnMobile == "on") o.navigationArrows = "none";

        if (o.forceFullWidth == "on") {
          var f = u.parent().offset().left;
          var l = u.parent().css("marginBottom");
          var m = u.parent().css("marginTop");
          if (l == t) l = 0;
          if (m == t) m = 0;
          u.parent().wrap('<div style="position:relative;width:100%;height:auto;margin-top:' + m + ";margin-bottom:" + l + '" class="forcefullwidth_wrapper_tp_banner"></div>');
          u.closest(".forcefullwidth_wrapper_tp_banner").append('<div class="tp-fullwidth-forcer" style="width:100%;height:' + u.height() + 'px"></div>');
          u.css({
            backgroundColor: u.parent().css("backgroundColor"),
            backgroundImage: u.parent().css("backgroundImage")
          });
          u.parent().css({
            left: 0 - f + "px",
            position: "absolute",
            width: e(window).width()
          });
          o.width = e(window).width();
        }

        try {
          if (o.hideThumbsUnderResolution > e(window).width() && o.hideThumbsUnderResolution != 0) {
            u.parent().find(".tp-bullets.tp-thumbs").css({
              display: "none"
            });
          } else {
            u.parent().find(".tp-bullets.tp-thumbs").css({
              display: "block"
            });
          }
        } catch (g) {}

        if (!u.hasClass("revslider-initialised")) {
          u.addClass("revslider-initialised");
          if (u.attr("id") == t) u.attr("id", "revslider-" + Math.round(Math.random() * 1e3 + 5));
          o.firefox13 = false;
          o.ie = !e.support.opacity;
          o.ie9 = document.documentMode == 9;
          o.origcd = o.delay;
          var b = e.fn.jquery.split("."),
              w = parseFloat(b[0]),
              E = parseFloat(b[1]),
              S = parseFloat(b[2] || "0");

          if (w == 1 && E < 7) {
            u.html('<div style="text-align:center; padding:40px 0px; font-size:20px; color:#992222;"> The Current Version of jQuery:' + b + " <br>Please update your jQuery Version to min. 1.7 in Case you wish to use the Revolution Slider Plugin</div>");
          }

          if (w > 1) o.ie = false;
          if (!e.support.transition) e.fn.transition = e.fn.animate;
          u.find(".caption").each(function () {
            e(this).addClass("tp-caption");
          });

          if (s()) {
            u.find(".tp-caption").each(function () {
              if (e(this).data("autoplay") == true) e(this).data("autoplay", false);
            });
          }

          var x = 0;
          var T = 0;
          var N = 0;
          var k = "http";

          if (location.protocol === "https:") {
            k = "https";
          }

          u.find(".tp-caption iframe").each(function (t) {
            try {
              if (e(this).attr("src").indexOf("you") > 0 && x == 0) {
                x = 1;
                var n = document.createElement("script");
                var r = "https";
                n.src = r + "://www.youtube.com/iframe_api";
                var i = document.getElementsByTagName("script")[0];
                var s = true;
                e("head").find("*").each(function () {
                  if (e(this).attr("src") == r + "://www.youtube.com/iframe_api") s = false;
                });

                if (s) {
                  i.parentNode.insertBefore(n, i);
                }
              }
            } catch (o) {}
          });
          u.find(".tp-caption iframe").each(function (t) {
            try {
              if (e(this).attr("src").indexOf("vim") > 0 && T == 0) {
                T = 1;
                var n = document.createElement("script");
                n.src = k + "://a.vimeocdn.com/js/froogaloop2.min.js";
                var r = document.getElementsByTagName("script")[0];
                var i = true;
                e("head").find("*").each(function () {
                  if (e(this).attr("src") == k + "://a.vimeocdn.com/js/froogaloop2.min.js") i = false;
                });
                if (i) r.parentNode.insertBefore(n, r);
              }
            } catch (s) {}
          });
          u.find(".tp-caption video").each(function (t) {
            e(this).removeClass("video-js").removeClass("vjs-default-skin");
            e(this).attr("preload", "");
            e(this).css({
              display: "none"
            });
          });

          if (o.shuffle == "on") {
            for (var L = 0; L < u.find(">ul:first-child >li").length; L++) {
              var A = Math.round(Math.random() * u.find(">ul:first-child >li").length);
              u.find(">ul:first-child >li:eq(" + A + ")").prependTo(u.find(">ul:first-child"));
            }
          }

          o.slots = 4;
          o.act = -1;
          o.next = 0;
          if (o.startWithSlide != t) o.next = o.startWithSlide;
          var M = n("#")[0];

          if (M.length < 9) {
            if (M.split("slide").length > 1) {
              var _ = parseInt(M.split("slide")[1], 0);

              if (_ < 1) _ = 1;
              if (_ > u.find(">ul:first >li").length) _ = u.find(">ul:first >li").length;
              o.next = _ - 1;
            }
          }

          o.firststart = 1;
          if (o.navigationHOffset == t) o.navOffsetHorizontal = 0;
          if (o.navigationVOffset == t) o.navOffsetVertical = 0;
          u.append('<div class="tp-loader ' + o.spinner + '">' + '<div class="dot1"></div>' + '<div class="dot2"></div>' + '<div class="bounce1"></div>' + '<div class="bounce2"></div>' + '<div class="bounce3"></div>' + "</div>");
          if (u.find(".tp-bannertimer").length == 0) u.append('<div class="tp-bannertimer" style="visibility:hidden"></div>');
          var D = u.find(".tp-bannertimer");

          if (D.length > 0) {
            D.css({
              width: "0%"
            });
          }

          u.addClass("tp-simpleresponsive");
          o.container = u;
          o.slideamount = u.find(">ul:first >li").length;
          if (u.height() == 0) u.height(o.startheight);
          if (o.startwidth == t || o.startwidth == 0) o.startwidth = u.width();
          if (o.startheight == t || o.startheight == 0) o.startheight = u.height();
          o.width = u.width();
          o.height = u.height();
          o.bw = o.startwidth / u.width();
          o.bh = o.startheight / u.height();

          if (o.width != o.startwidth) {
            o.height = Math.round(o.startheight * (o.width / o.startwidth));
            u.height(o.height);
          }

          if (o.shadow != 0) {
            u.parent().append('<div class="tp-bannershadow tp-shadow' + o.shadow + '"></div>');
            var f = 0;
            if (o.forceFullWidth == "on") f = 0 - o.container.parent().offset().left;
            u.parent().find(".tp-bannershadow").css({
              width: o.width,
              left: f
            });
          }

          u.find("ul").css({
            display: "none"
          });
          var P = u;
          u.find("ul").css({
            display: "block"
          });
          y(u, o);
          if (o.parallax != "off") O(u, o);
          if (o.slideamount > 1) c(u, o);
          if (o.slideamount > 1) a(u, o);
          if (o.slideamount > 1) h(u, o);
          if (o.keyboardNavigation == "on") p(u, o);
          d(u, o);
          if (o.hideThumbs > 0) v(u, o);
          C(u, o);
          if (o.slideamount > 1) nt(u, o);
          setTimeout(function () {
            u.trigger("revolution.slide.onloaded");
          }, 500);
          e("body").data("rs-fullScreenMode", false);
          e(window).on("mozfullscreenchange webkitfullscreenchange fullscreenchange", function () {
            e("body").data("rs-fullScreenMode", !e("body").data("rs-fullScreenMode"));

            if (e("body").data("rs-fullScreenMode")) {
              setTimeout(function () {
                e(window).trigger("resize");
              }, 200);
            }
          });
          e(window).resize(function () {
            if (e("body").find(u) != 0) if (o.forceFullWidth == "on") {
              var t = o.container.closest(".forcefullwidth_wrapper_tp_banner").offset().left;
              o.container.parent().css({
                left: 0 - t + "px",
                width: e(window).width()
              });
            }

            if (u.outerWidth(true) != o.width || u.is(":hidden")) {
              r(u, o);
            }
          });

          try {
            if (o.hideThumbsUnderResoluition != 0 && o.navigationType == "thumb") {
              if (o.hideThumbsUnderResoluition > e(window).width()) e(".tp-bullets").css({
                display: "none"
              });else e(".tp-bullets").css({
                display: "block"
              });
            }
          } catch (g) {}

          u.find(".tp-scrollbelowslider").on("click", function () {
            var t = 0;

            try {
              t = e("body").find(o.fullScreenOffsetContainer).height();
            } catch (n) {}

            try {
              t = t - e(this).data("scrolloffset");
            } catch (n) {}

            e("body,html").animate({
              scrollTop: u.offset().top + u.find(">ul >li").height() - t + "px"
            }, {
              duration: 400
            });
          });
          var H = u.parent();

          if (e(window).width() < o.hideSliderAtLimit) {
            u.trigger("stoptimer");
            if (H.css("display") != "none") H.data("olddisplay", H.css("display"));
            H.css({
              display: "none"
            });
          }
        }
      });
    },
    revscroll: function (t) {
      return this.each(function () {
        var n = e(this);
        e("body,html").animate({
          scrollTop: n.offset().top + n.find(">ul >li").height() - t + "px"
        }, {
          duration: 400
        });
      });
    },
    revredraw: function (t) {
      return this.each(function () {
        var t = e(this);
        var n = t.parent().find(".tp-bannertimer");
        var i = n.data("opt");
        r(t, i);
      });
    },
    revpause: function (t) {
      return this.each(function () {
        var t = e(this);
        t.data("conthover", 1);
        t.data("conthover-changed", 1);
        t.trigger("revolution.slide.onpause");
        var n = t.parent().find(".tp-bannertimer");
        var r = n.data("opt");
        r.bannertimeronpause = true;
        t.trigger("stoptimer");
      });
    },
    revresume: function (t) {
      return this.each(function () {
        var t = e(this);
        t.data("conthover", 0);
        t.data("conthover-changed", 1);
        t.trigger("revolution.slide.onresume");
        var n = t.parent().find(".tp-bannertimer");
        var r = n.data("opt");
        r.bannertimeronpause = false;
        t.trigger("starttimer");
      });
    },
    revnext: function (t) {
      return this.each(function () {
        var t = e(this);
        t.parent().find(".tp-rightarrow").click();
      });
    },
    revprev: function (t) {
      return this.each(function () {
        var t = e(this);
        t.parent().find(".tp-leftarrow").click();
      });
    },
    revmaxslide: function (t) {
      return e(this).find(">ul:first-child >li").length;
    },
    revcurrentslide: function (t) {
      var n = e(this);
      var r = n.parent().find(".tp-bannertimer");
      var i = r.data("opt");
      return i.act;
    },
    revlastslide: function (t) {
      var n = e(this);
      var r = n.parent().find(".tp-bannertimer");
      var i = r.data("opt");
      return i.lastslide;
    },
    revshowslide: function (t) {
      return this.each(function () {
        var n = e(this);
        n.data("showus", t);
        n.parent().find(".tp-rightarrow").click();
      });
    }
  });

  var N = function (n, r, i) {
    x(n, 0);
    var s = setInterval(function () {
      i.bannertimeronpause = true;
      i.container.trigger("stoptimer");
      i.cd = 0;
      var o = 0;
      n.find("img, .defaultimg").each(function (t) {
        if (e(this).data("lazydone") != 1) {
          o++;
        }
      });
      if (o > 0) x(n, o);else {
        clearInterval(s);
        if (r != t) r();
      }
    }, 100);
  };
})(jQuery);

(function (e) {
  "use strict";

  var t = e.GreenSockGlobals || e,
      n = function (e) {
    var n,
        r = e.split("."),
        i = t;

    for (n = 0; r.length > n; n++) i[r[n]] = i = i[r[n]] || {};

    return i;
  },
      r = n("com.greensock.utils"),
      i = function (e) {
    var t = e.nodeType,
        n = "";

    if (1 === t || 9 === t || 11 === t) {
      if ("string" == typeof e.textContent) return e.textContent;

      for (e = e.firstChild; e; e = e.nextSibling) n += i(e);
    } else if (3 === t || 4 === t) return e.nodeValue;

    return n;
  },
      s = document,
      o = s.defaultView ? s.defaultView.getComputedStyle : function () {},
      u = /([A-Z])/g,
      a = function (e, t, n, r) {
    var i;
    return (n = n || o(e, null)) ? (e = n.getPropertyValue(t.replace(u, "-$1").toLowerCase()), i = e || n.length ? e : n[t]) : e.currentStyle && (n = e.currentStyle, i = n[t]), r ? i : parseInt(i, 10) || 0;
  },
      f = function (e) {
    return e.length && e[0] && (e[0].nodeType && e[0].style && !e.nodeType || e[0].length && e[0][0]) ? !0 : !1;
  },
      l = function (e) {
    var t,
        n,
        r,
        i = [],
        s = e.length;

    for (t = 0; s > t; t++) if (n = e[t], f(n)) for (r = n.length, r = 0; n.length > r; r++) i.push(n[r]);else i.push(n);

    return i;
  },
      c = ")eefec303079ad17405c",
      h = /(?:<br>|<br\/>|<br \/>)/gi,
      p = s.all && !s.addEventListener,
      d = "<div style='position:relative;display:inline-block;" + (p ? "*display:inline;*zoom:1;'" : "'"),
      v = function (e) {
    e = e || "";
    var t = -1 !== e.indexOf("++"),
        n = 1;
    return t && (e = e.split("++").join("")), function () {
      return d + (e ? " class='" + e + (t ? n++ : "") + "'>" : ">");
    };
  },
      m = r.SplitText = t.SplitText = function (e, t) {
    if ("string" == typeof e && (e = m.selector(e)), !e) throw "cannot split a null element.";
    this.elements = f(e) ? l(e) : [e], this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = t || {}, this.split(t);
  },
      g = function (e, t, n, r, u) {
    h.test(e.innerHTML) && (e.innerHTML = e.innerHTML.replace(h, c));

    var f,
        l,
        p,
        d,
        m,
        g,
        y,
        b,
        w,
        E,
        S,
        x,
        T,
        N = i(e),
        C = t.type || t.split || "chars,words,lines",
        k = -1 !== C.indexOf("lines") ? [] : null,
        L = -1 !== C.indexOf("words"),
        A = -1 !== C.indexOf("chars"),
        O = "absolute" === t.position || t.absolute === !0,
        M = O ? "&#173; " : " ",
        _ = -999,
        D = o(e),
        P = a(e, "paddingLeft", D),
        H = a(e, "borderBottomWidth", D) + a(e, "borderTopWidth", D),
        B = a(e, "borderLeftWidth", D) + a(e, "borderRightWidth", D),
        j = a(e, "paddingTop", D) + a(e, "paddingBottom", D),
        F = a(e, "paddingLeft", D) + a(e, "paddingRight", D),
        I = a(e, "textAlign", D, !0),
        q = e.clientHeight,
        R = e.clientWidth,
        U = N.length,
        z = "</div>",
        W = v(t.wordsClass),
        X = v(t.charsClass),
        V = -1 !== (t.linesClass || "").indexOf("++"),
        $ = t.linesClass;

    for (V && ($ = $.split("++").join("")), p = W(), d = 0; U > d; d++) g = N.charAt(d), ")" === g && N.substr(d, 20) === c ? (p += z + "<BR/>", d !== U - 1 && (p += " " + W()), d += 19) : " " === g && " " !== N.charAt(d - 1) && d !== U - 1 ? (p += z, d !== U - 1 && (p += M + W())) : p += A && " " !== g ? X() + g + "</div>" : g;

    for (e.innerHTML = p + z, m = e.getElementsByTagName("*"), U = m.length, y = [], d = 0; U > d; d++) y[d] = m[d];

    if (k || O) for (d = 0; U > d; d++) b = y[d], l = b.parentNode === e, (l || O || A && !L) && (w = b.offsetTop, k && l && w !== _ && "BR" !== b.nodeName && (f = [], k.push(f), _ = w), O && (b._x = b.offsetLeft, b._y = w, b._w = b.offsetWidth, b._h = b.offsetHeight), k && (L !== l && A || (f.push(b), b._x -= P), l && d && (y[d - 1]._wordEnd = !0)));

    for (d = 0; U > d; d++) b = y[d], l = b.parentNode === e, "BR" !== b.nodeName ? (O && (S = b.style, L || l || (b._x += b.parentNode._x, b._y += b.parentNode._y), S.left = b._x + "px", S.top = b._y + "px", S.position = "absolute", S.display = "block", S.width = b._w + 1 + "px", S.height = b._h + "px"), L ? l ? r.push(b) : A && n.push(b) : l ? (e.removeChild(b), y.splice(d--, 1), U--) : !l && A && (w = !k && !O && b.nextSibling, e.appendChild(b), w || e.appendChild(s.createTextNode(" ")), n.push(b))) : k || O ? (e.removeChild(b), y.splice(d--, 1), U--) : L || e.appendChild(b);

    if (k) {
      for (O && (E = s.createElement("div"), e.appendChild(E), x = E.offsetWidth + "px", w = E.offsetParent === e ? 0 : e.offsetLeft, e.removeChild(E)), S = e.style.cssText, e.style.cssText = "display:none;"; e.firstChild;) e.removeChild(e.firstChild);

      for (T = !O || !L && !A, d = 0; k.length > d; d++) {
        for (f = k[d], E = s.createElement("div"), E.style.cssText = "display:block;text-align:" + I + ";position:" + (O ? "absolute;" : "relative;"), $ && (E.className = $ + (V ? d + 1 : "")), u.push(E), U = f.length, m = 0; U > m; m++) "BR" !== f[m].nodeName && (b = f[m], E.appendChild(b), T && (b._wordEnd || L) && E.appendChild(s.createTextNode(" ")), O && (0 === m && (E.style.top = b._y + "px", E.style.left = P + w + "px"), b.style.top = "0px", w && (b.style.left = b._x - w + "px")));

        L || A || (E.innerHTML = i(E).split(String.fromCharCode(160)).join(" ")), O && (E.style.width = x, E.style.height = b._h + "px"), e.appendChild(E);
      }

      e.style.cssText = S;
    }

    O && (q > e.clientHeight && (e.style.height = q - j + "px", q > e.clientHeight && (e.style.height = q + H + "px")), R > e.clientWidth && (e.style.width = R - F + "px", R > e.clientWidth && (e.style.width = R + B + "px")));
  },
      y = m.prototype;

  y.split = function (e) {
    this.isSplit && this.revert(), this.vars = e || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;

    for (var t = 0; this.elements.length > t; t++) this._originals[t] = this.elements[t].innerHTML, g(this.elements[t], this.vars, this.chars, this.words, this.lines);

    return this.isSplit = !0, this;
  }, y.revert = function () {
    if (!this._originals) throw "revert() call wasn't scoped properly.";

    for (var e = this._originals.length; --e > -1;) this.elements[e].innerHTML = this._originals[e];

    return this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this;
  }, m.selector = e.$ || e.jQuery || function (t) {
    return e.$ ? (m.selector = e.$, e.$(t)) : s ? s.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t;
  };
})(window || {});
//# sourceMappingURL=core.lib.min.js.map